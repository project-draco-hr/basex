{
  super.paintComponent(g);
  if (tdata.rows == null)   return;
  gui.painting=true;
  BaseXLayout.antiAlias(g);
  g.setFont(GUIConstants.font);
  final int w=getWidth() - scroll.getWidth();
  final int h=getHeight();
  final Context context=tdata.context;
  final Data data=context.data();
  final int rfocus=tdata.getRoot(data,gui.focused);
  final int focus=gui.focused;
  int mpos=0;
  final int nCols=tdata.cols.length;
  final int nRows=tdata.rows.size();
  final int rowH=tdata.rowH;
  final TableIterator ti=new TableIterator(data,tdata);
  final TokenBuilder[] tb=new TokenBuilder[nCols];
  for (int i=0; i < nCols; i++)   tb[i]=new TokenBuilder();
  focusedString=null;
  final Nodes marked=context.marked();
  int l=scroll.pos() / rowH - 1;
  int posY=-scroll.pos() + l * rowH;
  while (++l < nRows) {
    if (posY > h || l >= tdata.rows.size())     break;
    posY+=rowH;
    final int pre=tdata.rows.get(l);
    while (mpos < marked.size() && marked.nodes[mpos] < pre)     mpos++;
    g.setColor(GUIConstants.color3);
    g.drawLine(0,posY + rowH - 1,w,posY + rowH - 1);
    g.setColor(Color.white);
    g.drawLine(0,posY + rowH,w,posY + rowH);
    final boolean rm=mpos < marked.size() && marked.nodes[mpos] == pre;
    final boolean rf=pre == rfocus;
    final int col=rm ? rf ? 5 : 4 : 3;
    if (rm || rf) {
      g.setColor(GUIConstants.COLORS[col]);
      g.fillRect(0,posY - 1,w,rowH);
      g.setColor(GUIConstants.COLORS[col + 4]);
      g.drawLine(0,posY - 1,w,posY - 1);
    }
    g.setColor(Color.black);
    if (rowH < GUIProp.fontsize)     continue;
    ti.init(pre);
    int fcol=-1;
    while (ti.more()) {
      final int c=ti.col;
      if (ti.pre == focus || data.parent(ti.pre,data.kind(ti.pre)) == focus)       fcol=c;
      if (tb[c].size() < 100) {
        if (tb[c].size() != 0)         tb[c].add("; ");
        if (ti.elem) {
          tb[c].add(data.text(ti.pre));
        }
 else {
          byte[] txt=data.attValue(ti.pre);
          if (data.fs != null) {
            final boolean size=tdata.cols[c].id == data.sizeID;
            final boolean time=tdata.cols[c].id == data.fs.mtimeID;
            if (size || time) {
              txt=token(BaseXLayout.value(toDouble(txt),size,time));
            }
          }
          tb[c].add(txt);
        }
      }
    }
    for (    final TokenBuilder t : tb)     if (t.size() > 100)     t.add("...");
    byte[] focusStr=null;
    int fx=-1;
    double x=1;
    for (int c=0; c < nCols; c++) {
      double cw=w * tdata.cols[c].width;
      final double ce=x + cw;
      if (ce != 0) {
        final byte[] str=tb[c].size() != 0 ? tb[c].finish() : null;
        if (str != null) {
          if (data.fs != null && tdata.cols[c].id == data.fs.suffixID) {
            g.drawImage(GUIFS.images(str,false),(int)x + 2,posY - 8 + rowH / 2,this);
            x+=22;
            cw-=22;
          }
          if (tdata.mouseX > x && tdata.mouseX < ce || fcol == c) {
            fx=(int)x;
            focusStr=str;
          }
          BaseXLayout.chopString(g,str,(int)x + 1,posY + 2,(int)cw - 4);
          tb[c].reset();
        }
      }
      x=ce;
    }
    if (rf || fcol != -1) {
      if (focusStr != null) {
        final int sw=BaseXLayout.width(g,focusStr) + 8;
        if (fx > w - sw - 2)         fx=w - sw - 2;
        g.setColor(GUIConstants.COLORS[col + 2]);
        g.fillRect(fx - 2,posY,sw,rowH - 1);
        g.setColor(Color.black);
        BaseXLayout.chopString(g,focusStr,fx + 1,posY + 2,sw);
        focusedString=string(focusStr);
        final int i=focusedString.indexOf("; ");
        if (i != -1)         focusedString=focusedString.substring(0,i);
      }
    }
  }
  gui.painting=false;
}
