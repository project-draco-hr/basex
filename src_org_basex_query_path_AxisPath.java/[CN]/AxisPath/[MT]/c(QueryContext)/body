{
  for (int i=0; i != step.length; i++) {
    final Expr e=step[i].comp(ctx);
    if (!(e instanceof Step))     return e;
    step[i]=(Step)e;
  }
  mergeDesc(ctx);
  boolean pos=false;
  for (  final Step s : step) {
    if (s.pred.length != 0) {
      if (s.uses(Use.POS,ctx)) {
        if (s.uses(Use.VAR,ctx))         return this;
        pos=true;
      }
    }
  }
  cache=root != null && !root.uses(Use.VAR,ctx);
  final Data data=ctx.data();
  if (data != null) {
    boolean doc=true;
    final Item item=ctx.item;
    if (item.size(ctx) != ctx.docs || !(item instanceof Seq) || ((Seq)item).val != ctx.doc) {
      final Iter iter=item.iter();
      Item it;
      while ((it=iter.next()) != null)       doc&=it.type == Type.DOC;
    }
    if (doc) {
      if (!pos) {
        final Expr e=index(ctx,data);
        if (e != this)         return e;
      }
      final Expr e=children(ctx,data);
      if (e != this)       return e;
    }
  }
  return iterator(ctx);
}
