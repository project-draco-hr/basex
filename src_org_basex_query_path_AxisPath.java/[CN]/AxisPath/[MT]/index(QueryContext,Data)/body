{
  for (  final Step s : step)   if (!s.axis.down)   return this;
  for (int i=0; i < step.length; i++) {
    final Step stp=step[i];
    IndexContext ictx=null;
    int minp=0;
    final boolean d=stp.pred.length == 0 || node(data,i) == null;
    for (int p=0; p < stp.pred.length; p++) {
      final IndexContext ic=new IndexContext(data,stp,d);
      stp.pred[p].indexAccessible(ctx,ic);
      if (ic.io && ic.iu) {
        if (ictx == null || ictx.is > ic.is) {
          ictx=ic;
          minp=p;
        }
      }
    }
    if (ictx == null || !ictx.io || !ictx.iu)     continue;
    if (ictx.is == 0) {
      if (ictx.ftnot) {
        stp.pred[minp]=Bln.TRUE;
        continue;
      }
      ctx.compInfo(OPTNOINDEX,this);
      return Seq.EMPTY;
    }
    final Expr ie=stp.pred[minp].indexEquivalent(ctx,ictx);
    if (ictx.seq) {
      stp.pred[minp]=ie;
    }
 else {
      Step[] inv={};
      final Expr[] newPreds=new Expr[stp.pred.length - 1];
      int c=0;
      for (int p=0; p != stp.pred.length; p++) {
        if (p != minp)         newPreds[c++]=stp.pred[p];
      }
      for (int j=i; j >= 0; j--) {
        final Axis a=step[j].axis.invert();
        if (a == null)         break;
        if (j == 0) {
          if (a == Axis.PARENT)           inv=Array.add(inv,Step.get(a,new KindTest(Type.DOC)));
        }
 else {
          final Step prev=step[j - 1];
          if (prev.pred.length != 0)           break;
          inv=Array.add(inv,Step.get(a,prev.test));
        }
      }
      final boolean add=inv.length != 0 || newPreds.length != 0;
      AxisPath result=null;
      if (ie instanceof AxisPath) {
        result=(AxisPath)ie;
      }
 else       if (add || i + 1 < step.length) {
        result=add ? new AxisPath(ie,Step.get(Axis.SELF,Test.NODE)) : new AxisPath(ie);
      }
 else {
        return ie;
      }
      final int sl=result.step.length - 1;
      for (      final Expr np : newPreds) {
        result.step[sl]=result.step[sl].addPred(np);
      }
      if (inv.length != 0) {
        result.step[sl]=result.step[sl].addPred(AxisPath.get(null,inv));
      }
      for (int j=i + 1; j < step.length; j++) {
        result.step=Array.add(result.step,step[j]);
      }
      return result.comp(ctx);
    }
  }
  return this;
}
