{
  for (int i=0; i < step.length; i++) {
    if (step[i].axis != Axis.DESC)     continue;
    ArrayList<SkelNode> nodes=node(data,i);
    if (nodes == null)     continue;
    ctx.compInfo(OPTCHILD,step[i]);
    final TokenList tl=new TokenList();
    ArrayList<SkelNode> temp=new ArrayList<SkelNode>();
    while (nodes.size() != 0) {
      SkelNode rootNode=nodes.get(0);
      temp.add(rootNode.par);
      boolean same=true;
      for (int j=1; j < nodes.size(); j++) {
        SkelNode node=nodes.get(j);
        temp.add(node.par);
        if (rootNode.name != node.name)         same=false;
        if (j == nodes.size() - 1) {
          nodes=temp;
          temp=null;
          if (same)           tl.add(data.tags.key(node.name));
 else           tl.add(null);
        }
      }
    }
    int ts=tl.size;
    final Step[] steps=new Step[ts + step.length - i - 1];
    for (int t=0; t < ts - 1; t++) {
      steps[t]=Step.get(Axis.CHILD,new NameTest(new QNm(tl.list[ts - t - 1]),Kind.NAME,false));
    }
    steps[ts - 1]=Step.get(Axis.CHILD,new NameTest(new QNm(tl.list[0]),Kind.NAME,false),step[i].pred);
    while (++i < step.length)     steps[ts++]=step[i];
    return get(root,steps).children(ctx,data);
  }
  return this;
}
