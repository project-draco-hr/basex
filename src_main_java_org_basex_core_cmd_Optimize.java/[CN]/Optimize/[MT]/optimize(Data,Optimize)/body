{
  final MetaData md=data.meta;
  if (!md.uptodate) {
    data.paths.close();
    data.resources.init();
    data.tagindex.init();
    data.atnindex.init();
    md.dirty=true;
    final IntList pars=new IntList();
    final IntList tags=new IntList();
    int n=0;
    for (int pre=0; pre < md.size; ++pre) {
      final byte kind=(byte)data.kind(pre);
      final int par=data.parent(pre,kind);
      while (!pars.isEmpty() && pars.peek() > par) {
        pars.pop();
        tags.pop();
      }
      final int level=pars.size();
      if (kind == Data.DOC) {
        data.paths.index(0,kind,level);
        pars.push(pre);
        tags.push(0);
        ++n;
      }
 else       if (kind == Data.ELEM) {
        final int id=data.name(pre);
        data.tagindex.index(data.tagindex.key(id),null,true);
        data.paths.index(id,kind,level);
        pars.push(pre);
        tags.push(id);
      }
 else       if (kind == Data.ATTR) {
        final int id=data.name(pre);
        final byte[] val=data.text(pre,false);
        data.atnindex.index(data.atnindex.key(id),val,true);
        data.paths.index(id,kind,level,val,md);
      }
 else {
        final byte[] val=data.text(pre,true);
        if (kind == Data.TEXT && level > 1)         data.tagindex.index(tags.peek(),val);
        data.paths.index(0,kind,level,val,md);
      }
      if (c != null)       c.pre=pre;
    }
    md.ndocs=n;
    md.uptodate=true;
  }
  optimize(IndexType.ATTRIBUTE,data,md.createattr,md.attrindex,c);
  optimize(IndexType.TEXT,data,md.createtext,md.textindex,c);
  optimize(IndexType.FULLTEXT,data,md.createftxt,md.ftxtindex,c);
}
