{
  size=0;
  boolean ne=false;
  for (  final Expr e : expr) {
    final long c=e.size();
    ne|=c > 0 || e.type().occ.min == 1;
    if (c == -1) {
      size=-1;
      break;
    }
 else     if (size >= 0) {
      size+=c;
    }
  }
  if (size >= 0) {
    if (size == 0 && !uses(Use.NDT) && !uses(Use.UPD))     return optPre(null,ctx);
    if (allAreValues() && size <= MAX_MAT_SIZE) {
      final int s=(int)size;
      Type all=null;
      final Value[] vs=new Value[expr.length];
      int n=0;
      for (      final Expr e : expr) {
        final Value v=e.value(ctx);
        if (v.size() > 0) {
          vs[n++]=v;
          if (n == 0)           all=v.type;
 else           if (v.type != all || !v.homogeneous())           all=null;
        }
      }
      Value val=null;
      if (all != null) {
        if (all == AtomType.STR)         val=StrSeq.get(vs,n);
 else         if (all == AtomType.BLN)         val=BlnSeq.get(vs,n);
 else         if (all == AtomType.FLT)         val=FltSeq.get(vs,n);
 else         if (all == AtomType.DBL)         val=DblSeq.get(vs,n);
 else         if (all == AtomType.DEC)         val=DecSeq.get(vs,n);
 else         if (all == AtomType.BYT)         val=BytSeq.get(vs,n);
 else         if (all.instanceOf(AtomType.ITR))         val=IntSeq.get(vs,n,all);
      }
      if (val == null) {
        final ValueBuilder vb=new ValueBuilder(s);
        for (int i=0; i < n; i++)         vb.add(vs[i]);
        val=vb.value();
      }
      return optPre(val,ctx);
    }
  }
  if (size == 0) {
    type=SeqType.EMP;
  }
 else {
    final Occ o=size == 1 ? Occ.ONE : size < 0 && !ne ? Occ.ZERO_MORE : Occ.ONE_MORE;
    SeqType t=null;
    for (    final Expr e : expr) {
      final SeqType st=e.type();
      if (e.size() != 0 && st.occ != Occ.ZERO)       t=t == null ? st : t.union(st);
    }
    type=SeqType.get(t == null ? AtomType.ITEM : t.type,o);
  }
  return this;
}
