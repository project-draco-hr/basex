{
  boolean opt=false;
  final int sl=steps.length;
  final ExprList stps=new ExprList(sl);
  for (int s=0; s < sl; s++) {
    final Expr step=steps[s];
    if (s < sl - 1 && step instanceof Step) {
      final Step curr=(Step)step;
      if (curr.simple(DESCORSELF,false)) {
        final Expr next=steps[s + 1];
        if (next instanceof Step) {
          final Step stp=(Step)next;
          if (stp.axis == CHILD && !stp.has(Flag.FCS)) {
            stp.axis=DESC;
            opt=true;
            continue;
          }
          if (stp.axis == ATTR && !stp.has(Flag.FCS)) {
            curr.test=new NameTest(false);
            opt=true;
          }
        }
        Expr e=mergeList(next);
        if (e != null) {
          steps[s + 1]=e;
          opt=true;
          continue;
        }
        if (next instanceof Filter) {
          final Filter f=(Filter)next;
          e=mergeList(f.root);
          if (e != null) {
            f.root=e;
            opt=true;
            continue;
          }
        }
      }
    }
    stps.add(step);
  }
  if (opt) {
    qc.compInfo(OPTDESC);
    return get(info,root,stps.finish());
  }
  return this;
}
