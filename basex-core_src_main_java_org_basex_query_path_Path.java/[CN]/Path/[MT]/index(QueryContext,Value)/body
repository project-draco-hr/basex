{
  final Data data=rt.data();
  if (data == null)   return this;
  IndexCosts index=null;
  int iPred=0, iStep=0;
  final int sl=steps.length;
  for (int s=0; s < sl; s++) {
    final Step step=axisStep(s);
    if (step == null || !step.axis.down || step.has(Flag.FCS))     break;
    final boolean iter=pathNodes(data,s) != null;
    final IndexContext ictx=new IndexContext(data,iter);
    final int pl=step.preds.length;
    for (int p=0; p < pl; p++) {
      final IndexCosts ic=new IndexCosts(ictx,ctx,step);
      if (!step.preds[p].indexAccessible(ic))       continue;
      if (ic.costs() == 0) {
        if (ic.not) {
          step.preds[p]=Bln.TRUE;
          continue;
        }
        ctx.compInfo(OPTNOINDEX,this);
        return Empty.SEQ;
      }
      if (index == null || index.costs() > ic.costs()) {
        index=ic;
        iPred=p;
        iStep=s;
      }
    }
  }
  if (index == null || index.costs() > data.meta.size)   return this;
  final Step indexStep=index.step;
  Expr indexExpr=indexStep.preds[iPred].indexEquivalent(index);
  if (index.seq) {
    indexStep.preds[iPred]=indexExpr;
  }
 else {
    final int pl=indexStep.preds.length;
    final ExprList newPreds=new ExprList(pl - 1);
    for (int p=0; p < pl; p++) {
      if (p != iPred)       newPreds.add(indexStep.preds[p]);
    }
    final Test test=InvDocTest.get(rt);
    boolean inv=true;
    if (test == Test.DOC && data.meta.uptodate) {
      int s=0;
      for (; s <= iStep; s++) {
        final Step step=axisStep(s);
        if (step.test.kind != Kind.NAME || step.axis != Axis.CHILD || s != iStep && step.preds.length > 0)         break;
        final int name=data.tagindex.id(step.test.name.local());
        final ArrayList<PathNode> pn=data.paths.desc(name,Data.ELEM);
        if (pn.size() != 1 || pn.get(0).level() != s + 1)         break;
      }
      inv=s <= iStep;
    }
    final ExprList invSteps=new ExprList();
    if (inv) {
      for (int s=iStep; s >= 0; s--) {
        final Axis ax=axisStep(s).axis.invert();
        if (s == 0) {
          if (test != Test.DOC || ax != Axis.ANC && ax != Axis.ANCORSELF)           invSteps.add(Step.get(info,ax,test));
        }
 else {
          final Step prev=axisStep(s - 1);
          invSteps.add(Step.get(info,ax,prev.test,prev.preds));
        }
      }
    }
    if (!invSteps.isEmpty())     newPreds.add(get(info,null,invSteps.finish()));
    final ExprList resultSteps=new ExprList();
    final Expr resultRoot;
    if (indexExpr instanceof Path) {
      final Path p=(Path)indexExpr;
      resultRoot=p.root;
      resultSteps.add(p.steps);
    }
 else {
      resultRoot=indexExpr;
    }
    if (!newPreds.isEmpty()) {
      int ls=resultSteps.size() - 1;
      Step step;
      if (ls < 0 || !(resultSteps.get(ls) instanceof Step)) {
        step=Step.get(info,Axis.SELF,Test.NOD);
        ls++;
      }
 else {
        step=(Step)resultSteps.get(ls);
      }
      resultSteps.set(ls,step.addPreds(newPreds.finish()));
    }
    for (int s=iStep + 1; s < sl; s++)     resultSteps.add(steps[s]);
    return get(info,resultRoot,resultSteps.finish());
  }
  return this;
}
