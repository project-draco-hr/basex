{
  if ((s.length & 3) != 0)   castErr(s);
  final int l=s.length;
  final int g=l >>> 2;
  int m=0, n=g;
  if (l != 0) {
    if (s[l - 1] == '=') {
      m++;
      n--;
    }
    if (s[l - 2] == '=')     m++;
    if (m == 2 && !Token.contains(ENDING,s[l - 3]))     castErr(Token.substring(s,l - 3));
  }
  val=new byte[3 * g - m];
  int c=0, o=0;
  for (int i=0; i < n; i++) {
    final int c0=b2h(s[c++]);
    final int c1=b2h(s[c++]);
    final int c2=b2h(s[c++]);
    final int c3=b2h(s[c++]);
    val[o++]=(byte)((c0 << 2) | (c1 >> 4));
    val[o++]=(byte)((c1 << 4) | (c2 >> 2));
    val[o++]=(byte)((c2 << 6) | c3);
  }
  if (m != 0) {
    final int c0=b2h(s[c++]);
    final int c1=b2h(s[c++]);
    val[o++]=(byte)((c0 << 2) | (c1 >> 4));
    if (m == 1)     val[o++]=(byte)((c1 << 4) | (b2h(s[c++]) >> 2));
  }
}
