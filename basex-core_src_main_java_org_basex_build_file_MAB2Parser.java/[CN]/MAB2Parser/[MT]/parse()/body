{
  index(mediatypes,"mediatypes");
  index(subjects,"subjects");
  index(languages,"lang");
  index(mvids,"mvids");
  index(lendings,"lendings");
  index(status,"status");
  index(posters,"posters");
  index(genres,"genres");
  for (  final byte[] key : mvids) {
    final int id=toInt(mvids.get(key));
    if (maxid < id)     maxid=id;
  }
  if (input.read1() != '#' || input.read1() != '#' || input.read1() != '#') {
    throw new BuildException("Invalid MAB2 input (doesn't start with ###)");
  }
  builder.openElem(LIBRARY,atts.clear(),nsp);
  final Performance p=new Performance();
  final TokenObjMap<MAB2Entry> ids=new TokenObjMap<MAB2Entry>();
  int i=0;
  for (byte[] id; (id=id(input)) != null; ) {
    final long pos=off;
    final byte[] par=par(input);
    final boolean child=par != null;
    final byte[] key=child ? par : id;
    MAB2Entry entry=ids.get(key);
    if (entry == null) {
      entry=new MAB2Entry();
      ids.put(key,entry);
    }
    if (child)     entry.add(pos);
 else     entry.pos(pos);
    if (Prop.debug) {
      if ((++i & 0x7FFF) == 0)       Util.err(" " + i + '\n');
 else       if ((i & 0xFFF) == 0)       Util.err("!");
 else       if ((i & 0x3FF) == 0)       Util.err(".");
    }
  }
  if (Prop.debug)   Util.err("\nParse Offsets (%): %/%\n",ids.size(),p,Performance.getMemory());
  for (  final byte[] id : ids) {
    final MAB2Entry entry=ids.get(id);
    final long pos=entry.pos;
    final byte[] l=pos != 0 ? addEntry(input,pos,entry.size,null) : null;
    for (int j=0; j < entry.size; ++j) {
      addEntry(input,entry.children[j],0,l);
    }
    if (entry.size != 0 && pos != 0 && !flat)     builder.closeElem();
  }
  if (Prop.debug)   Util.err("\nCreate Titles: %/%\n",p,Performance.getMemory());
  builder.closeElem();
  final PrintOutput out=new PrintOutput("mvids.dat");
  for (  final byte[] id : mvids) {
    out.print(id);
    out.write('\t');
    out.println(mvids.get(id));
  }
  out.close();
}
