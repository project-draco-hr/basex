{
  final Data data=GUI.context.data();
  super.paintComponent(g);
  BaseXLayout.antiAlias(g);
  g.setColor(Color.BLACK);
  g.setFont(GUIConstants.font);
  final Performance perf=new Performance();
  perf.initTimer();
  fontHeight=g.getFontMetrics().getHeight();
  pointerx=getWidth() / 2;
  pointery=topdistance;
  if (windowSizeChanged()) {
switch (3) {
case 1:
      drawTree(g,0,0,0,getWidth());
    break;
case 2:
  drawPrePost(g,1,1);
break;
case 3:
realImage=createImage();
Graphics rg=realImage.getGraphics();
rects=new ArrayList<RealRect[]>();
Nodes curr=GUI.context.current();
for (int i=0; i < curr.size; i++) {
temperature(curr.nodes[i],rg,i);
}
}
focus();
}
g.drawImage(realImage,0,0,getWidth(),getHeight(),this);
if (focusedRealRect != null) {
RealRect r=focusedRealRect;
g.drawRect(r.x1,r.y1,r.x2 - r.x1,r.y2 - r.y1);
final int pre=r.p;
String s="";
if (data.kind(pre) == Data.ELEM) {
s=Token.string(data.tag(pre));
}
 else {
s=Token.string(data.text(pre));
}
for (int y=0; y < data.attSize(pre,data.kind(pre)) - 1; y++) {
s+=" " + Token.string(data.attName(pre + y + 1)) + "="+ "\""+ Token.string(data.attValue(pre + y + 1))+ "\" ";
}
int w=BaseXLayout.width(g,s);
g.setColor(Color.WHITE);
g.fillRect(r.x1,r.y1 - fontHeight,w,fontHeight);
g.setColor(Color.BLACK);
g.drawString(s,r.x1,(int)(r.y1 - fontHeight / 4f));
}
if (!rects.isEmpty() && GUI.context.marked().size > 0) {
g.setColor(Color.GREEN);
Iterator<RealRect[]> it=rects.iterator();
while (it.hasNext()) {
final RealRect[] r=it.next();
int size=GUI.context.marked().size;
final int[] markedNodes=new int[size];
System.arraycopy(GUI.context.marked().nodes,0,markedNodes,0,size);
for (int i=0; i < r.length; i++) {
for (int j=0; j < size; j++) {
if (r[i].p == markedNodes[j]) {
g.drawRect(r[i].x1,r[i].y1,r[i].x2 - r[i].x1,r[i].y2 - r[i].y1);
if (size < 2) {
return;
}
 else if (j < size - 1) {
markedNodes[j]=markedNodes[size - 1];
}
size--;
}
}
}
}
}
}
