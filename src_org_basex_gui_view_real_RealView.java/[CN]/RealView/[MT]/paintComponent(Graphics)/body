{
  final Data data=gui.context.data();
  super.paintComponent(g);
  BaseXLayout.antiAlias(g);
  g.setColor(Color.BLACK);
  g.setFont(GUIConstants.font);
  final Performance perf=new Performance();
  perf.initTimer();
  fontHeight=g.getFontMetrics().getHeight();
  if (windowSizeChanged()) {
    realImage=createImage();
    Graphics rg=realImage.getGraphics();
    rects=new ArrayList<ViewRect[]>();
    Nodes curr=gui.context.current();
    for (int i=0; i < curr.size; i++) {
      temperature(curr.nodes[i],rg,i);
    }
    focus();
  }
  g.drawImage(realImage,0,0,getWidth(),getHeight(),this);
  if (focusedRect != null) {
    ViewRect r=focusedRect;
    g.drawRect(r.x,r.y,r.w,r.h);
    final int pre=r.pre;
    String s="";
    if (data.kind(pre) == Data.ELEM) {
      s=Token.string(data.tag(pre));
    }
 else {
      s=Token.string(data.text(pre));
    }
    for (int y=0; y < data.attSize(pre,data.kind(pre)) - 1; y++) {
      s+=" " + Token.string(data.attName(pre + y + 1)) + "="+ "\""+ Token.string(data.attValue(pre + y + 1))+ "\" ";
    }
    int w=BaseXLayout.width(g,s);
    g.setColor(Color.WHITE);
    g.fillRect(r.x,r.y - fontHeight,w,fontHeight);
    g.setColor(Color.BLACK);
    g.drawString(s,r.x,(int)(r.y - fontHeight / 4f));
  }
  if (!rects.isEmpty() && gui.context.marked().size > 0) {
    g.setColor(Color.GREEN);
    Iterator<ViewRect[]> it=rects.iterator();
    while (it.hasNext()) {
      final ViewRect[] r=it.next();
      int size=gui.context.marked().size;
      final int[] markedNodes=new int[size];
      System.arraycopy(gui.context.marked().nodes,0,markedNodes,0,size);
      for (int i=0; i < r.length; i++) {
        for (int j=0; j < size; j++) {
          if (r[i].pre == markedNodes[j]) {
            g.drawRect(r[i].x,r[i].y,r[i].w,r[i].h);
            if (size < 2) {
              return;
            }
 else             if (j < size - 1) {
              markedNodes[j]=markedNodes[size - 1];
            }
            size--;
          }
        }
      }
    }
  }
}
