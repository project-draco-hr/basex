{
  tk.st=is(ST);
  tk.dc=is(DC);
  tk.cs=is(CS);
  tk.sd=sd;
  tk.init();
  qu.init(q);
  qu.st=tk.st;
  qu.dc=tk.dc;
  qu.cs=tk.cs;
  qu.sd=tk.sd;
  qu.uc=is(UC);
  qu.lc=is(LC);
  qu.wc=is(WC);
  qu.fz=is(FZ);
  if (qu.fz && ls == null)   ls=new Levenshtein();
  query.reset();
  qu.init();
  while (qu.more())   query.add(qu.get());
  int c=0;
  while (tk.more()) {
    final int tp=tk.p;
    final int tpos=tk.pos;
    byte[] t=tk.get();
    boolean f=false;
    boolean m=false;
    qu.init();
    int i=-1;
    while (++i < query.size()) {
      if (m) {
        tk.more();
        t=tk.get();
      }
 else {
        m=true;
      }
      final byte[] s=query.get(i);
      if (sw != null && sw.id(s) != 0)       continue;
      f=qu.fz ? ls.similar(t,s,lserr) : qu.wc ? wc(words.input,t,s,0,0) : eq(t,s);
      if (!f)       break;
    }
    if (!f && th != null) {
      i=0;
      for (      final byte[] txt : th.find(words.input,qu)) {
        qu.init(txt);
        qu.more();
        f|=eq(qu.get(),t);
        if (f)         break;
      }
    }
    if (f) {
      c++;
      if (words.add(tpos,tpos + i - 1))       break;
    }
    tk.p=tp;
    tk.pos=tpos;
  }
  words.all.sTokenNum++;
  words.first=false;
  return c;
}
