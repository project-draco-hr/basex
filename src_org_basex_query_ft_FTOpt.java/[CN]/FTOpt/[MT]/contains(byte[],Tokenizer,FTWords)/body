{
  tk.st=is(ST);
  tk.dc=is(DC);
  tk.cs=is(CS);
  tk.sd=sd;
  tk.init();
  qu.init(q);
  qu.st=tk.st;
  qu.dc=tk.dc;
  qu.cs=tk.cs;
  qu.sd=tk.sd;
  qu.uc=is(UC);
  qu.lc=is(LC);
  qu.wc=is(WC);
  qu.fz=is(FZ);
  if (qu.fz && ls == null)   ls=new Levenshtein();
  int count=0;
  while (tk.more()) {
    final int tp=tk.p;
    final int tpos=tk.pos;
    byte[] t=tk.get();
    boolean f=false;
    boolean c=false;
    qu.init();
    while (qu.more()) {
      if (c) {
        tk.more();
        t=tk.get();
      }
 else {
        c=true;
      }
      final byte[] s=qu.get();
      if (sw != null && sw.id(s) != 0)       continue;
      f=qu.fz ? ls.similar(t,s,lserr) : qu.wc ? wc(t,s,0,0) : eq(t,s);
      if (!f)       break;
    }
    if (!f && th != null) {
      final byte[] tmp=qu.text;
      for (      final byte[] txt : th.find(qu)) {
        qu.init(txt);
        qu.more();
        f|=eq(qu.get(),t);
        if (f)         break;
      }
      qu.text=tmp;
    }
    if (f) {
      count++;
      if (words.add(tpos,tpos + qu.pos - 1))       break;
    }
    tk.p=tp;
    tk.pos=tpos;
  }
  words.all.sTokenNum++;
  words.first=false;
  return count;
}
