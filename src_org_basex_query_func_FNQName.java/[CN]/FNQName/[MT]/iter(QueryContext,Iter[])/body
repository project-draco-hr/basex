{
switch (func) {
case RESQNAME:
    Item it=arg[0].atomic(this,true);
  return it == null ? Iter.EMPTY : resolve(ctx,it,arg[1].atomic(this,false));
case QNAME:
it=arg[0].atomic(this,true);
final Uri uri=Uri.uri(it == null ? EMPTY : check(it,Type.STR).str());
it=arg[1].atomic(this,true);
it=it == null ? Str.ZERO : check(it,Type.STR);
final byte[] str=it.str();
if (!XMLToken.isQName(str)) Err.value(Type.QNM,it);
QNm nm=new QNm(str,uri);
if (nm.ns() && uri == Uri.EMPTY) Err.value(Type.URI,uri);
return nm.iter();
case LOCNAMEQNAME:
it=arg[0].atomic(this,true);
if (it == null) return Iter.EMPTY;
return new NCN(((QNm)check(it,Type.QNM)).ln()).iter();
case PREQNAME:
it=arg[0].atomic(this,true);
if (it == null) return Iter.EMPTY;
nm=(QNm)check(it,Type.QNM);
return !nm.ns() ? Iter.EMPTY : new NCN(nm.pre()).iter();
case NSURIPRE:
it=check(arg[1].atomic(this,false),Type.ELM);
final byte[] pre=checkStr(arg[0]);
if (pre.length == 0) return Uri.uri(ctx.nsElem).iter();
final Atts at=((Nod)it).ns();
for (int a=0; a < at.size; a++) {
if (eq(pre,at.key[a])) return Uri.uri(at.val[a]).iter();
}
return Iter.EMPTY;
case INSCOPE:
return inscope(ctx,(Nod)check(arg[0].atomic(this,false),Type.ELM));
case RESURI:
it=arg[0].atomic(this,true);
if (it == null) return Iter.EMPTY;
final Uri rel=Uri.uri(checkStr(it));
if (!rel.valid()) Err.or(URIINV,it);
final Uri base=arg.length == 1 ? ctx.baseURI : Uri.uri(checkStr(arg[1].atomic(this,false)));
if (!base.valid()) Err.or(URIINV,base);
return base.resolve(rel).iter();
default :
BaseX.notexpected(func);
return null;
}
}
