{
  Iter res=ctx.value.iter();
  final int el=steps.length;
  for (int ex=0; ex < el; ex++) {
    final Expr e=steps[ex];
    final boolean last=ex + 1 == el;
    final ItemCache ic=new ItemCache();
    ctx.size=res.size();
    ctx.pos=1;
    boolean nodes=false;
    for (Item it; (it=res.next()) != null; ) {
      if (!it.node())       NODESPATH.thrw(input,this,it.type);
      ctx.value=it;
      final Iter ir=ctx.iter(e);
      for (Item i; (i=ir.next()) != null; ) {
        if (ic.size() == 0)         nodes=i.node();
 else         if (last && nodes != i.node())         EVALNODESVALS.thrw(input);
        ic.add(i);
      }
      ctx.pos++;
    }
    if (nodes) {
      final NodeCache nc=new NodeCache().random();
      for (Item it; (it=ic.next()) != null; )       nc.add((ANode)it);
      res=nc.value().cache();
    }
 else {
      res=ic;
    }
  }
  return res;
}
