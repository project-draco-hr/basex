{
  int l=0;
  int p=pre;
  final int s=pre + data.size(pre,data.kind(p));
  while (p < s) {
    if (finished())     return s;
    int k=data.kind(p);
    final int pa=data.parent(p,k);
    while (l > 0 && parent[l - 1] >= pa)     closeElement(token[--l]);
    if (k == Data.DOC) {
      p++;
    }
 else     if (k == Data.TEXT) {
      text(data.text(p++));
    }
 else     if (k == Data.COMM) {
      comment(data.text(p++));
    }
 else     if (k == Data.PI) {
      pi(data.text(p++));
    }
 else {
      final byte[] name=data.tag(p);
      startElement(name);
      nms.reset();
      vls.reset();
      final int ps=p + data.size(p,k);
      final int as=p + data.attSize(p,k);
      int pp=p;
      while (++p != as)       attribute(data.attName(p),data.attValue(p));
      if (level == 0 && l == 0) {
        do {
          addNS(data,pp);
          pp=data.parent(pp,k);
          k=data.kind(pp);
        }
 while (k == Data.ELEM);
      }
 else {
        addNS(data,pp);
      }
      for (int n=0; n < nms.size; n++)       attribute(nms.list[n],vls.list[n]);
      if (as == ps) {
        emptyElement();
      }
 else {
        finishElement();
        token[l]=name;
        parent[l++]=pa;
      }
    }
  }
  while (l > 0)   closeElement(token[--l]);
  return p;
}
