{
  if (where == null)   return;
  for (  final ForLet f : fl) {
    if (f instanceof For && (!f.simple(false) || !where.removable(f.var)))     return;
  }
  final Expr[] tests=where instanceof And ? ((And)where).expr : new Expr[]{where};
  final int[] tar=new int[tests.length];
  for (int t=0; t < tests.length; ++t) {
    int fr=-1;
    for (int f=fl.length - 1; f >= 0; --f) {
      if (fl[f] instanceof For)       fr=f;
      if (tests[t].count(fl[f].var) != 0) {
        if (fr == -1)         return;
        tar[t]=fr;
        break;
      }
    }
  }
  ctx.compInfo(OPTWHERE);
  for (int f=0; f < fl.length; ++f) {
    final ForLet c=fl[f];
    final ExprList el=new ExprList();
    for (int t=0; t < tests.length; ++t) {
      if (tar[t] == f)       el.add(tests[t].remove(c.var));
    }
    if (el.isEmpty())     continue;
    final Expr a;
    if (el.size() == 1) {
      final Expr e=el.get(0);
      a=e.type().mayBeNumber() ? Function.BOOLEAN.get(info,e) : e;
    }
 else {
      a=new And(info,el.finish());
    }
    if (c.expr instanceof AxisPath) {
      c.expr=((AxisPath)c.expr).addPreds(a);
    }
 else     if (c.expr instanceof Filter) {
      c.expr=((Filter)c.expr).addPred(a);
    }
 else {
      c.expr=new Filter(info,c.expr,a);
    }
  }
  where=null;
}
