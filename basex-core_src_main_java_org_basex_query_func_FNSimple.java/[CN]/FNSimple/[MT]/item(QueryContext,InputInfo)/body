{
  final Expr e=exprs.length == 1 ? exprs[0] : null;
switch (func) {
case FALSE:
    return Bln.FALSE;
case TRUE:
  return Bln.TRUE;
case EMPTY:
return Bln.get(e.iter(qc).next() == null);
case EXISTS:
return Bln.get(e.iter(qc).next() != null);
case BOOLEAN:
return Bln.get(e.ebv(qc,info).bool(info));
case NOT:
return Bln.get(!e.ebv(qc,info).bool(info));
case DEEP_EQUAL:
return Bln.get(deep(qc));
case DEEP_EQUAL_OPT:
return Bln.get(deepOpt(qc));
case ZERO_OR_ONE:
Iter ir=e.iter(qc);
Item it=ir.next();
if (it != null && ir.next() != null) throw ZEROORONE.get(info);
return it;
case EXACTLY_ONE:
ir=e.iter(qc);
it=ir.next();
if (it == null || ir.next() != null) throw EXACTLYONE.get(info);
return it;
default :
return super.item(qc,ii);
}
}
