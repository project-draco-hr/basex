{
  final HashMap<String,Value> bindings=bindings(1,ctx);
  final QueryContext qc=ctx.proc(new QueryContext(ctx));
  final Timer to=new Timer(true);
  final Perm tmp=ctx.context.user.perm;
  if (exprs.length > 2) {
    final Options opts=checkOptions(2,Q_OPTIONS,new XQueryOptions(),ctx);
    ctx.context.user.perm=Perm.get(opts.get(XQueryOptions.PERMISSION));
    Performance.gc(2);
    final long mb=opts.get(XQueryOptions.MEMORY);
    if (mb != 0) {
      final long limit=Performance.memory() + (mb << 20);
      to.schedule(new TimerTask(){
        @Override public void run(){
          if (Performance.memory() > limit) {
            Performance.gc(1);
            if (Performance.memory() > limit)             qc.stop();
          }
        }
      }
,500,500);
    }
    final long ms=opts.get(XQueryOptions.TIMEOUT) * 1000L;
    if (ms != 0) {
      to.schedule(new TimerTask(){
        @Override public void run(){
          qc.stop();
        }
      }
,ms);
    }
  }
  try {
    final StaticContext sctx=new StaticContext(qc.context);
    for (    final Map.Entry<String,Value> it : bindings.entrySet()) {
      final String k=it.getKey();
      final Value v=it.getValue();
      if (k.isEmpty())       qc.context(v,null,sctx);
 else       qc.bind(k,v,null);
    }
    qc.parseMain(string(qu),path,sctx);
    if (updating) {
      if (!sc.mixUpdates && !qc.updating && !qc.root.expr.isVacuous())       throw BXXQ_NOUPDATE.get(info);
    }
 else {
      if (qc.updating)       throw BXXQ_UPDATING.get(info);
    }
    qc.compile();
    final ValueBuilder vb=new ValueBuilder();
    cache(qc.iter(),vb,ctx);
    return vb;
  }
 catch (  final ProcException ex) {
    throw BXXQ_STOPPED.get(info);
  }
catch (  final QueryException ex) {
    throw ex.err() == BASX_PERM ? BXXQ_PERM.get(info,ex.getLocalizedMessage()) : ex;
  }
 finally {
    ctx.context.user.perm=tmp;
    ctx.proc(null);
    qc.close();
    to.cancel();
  }
}
