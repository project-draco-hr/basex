{
  final HashMap<String,Value> bindings=bindings(1,qc);
  final QueryContext qctx=qc.proc(new QueryContext(qc));
  final Timer to=new Timer(true);
  final Perm tmp=qc.context.user.perm;
  if (exprs.length > 2) {
    final Options opts=checkOptions(2,Q_OPTIONS,new XQueryOptions(),qc);
    qc.context.user.perm=Perm.get(opts.get(XQueryOptions.PERMISSION));
    Performance.gc(2);
    final long mb=opts.get(XQueryOptions.MEMORY);
    if (mb != 0) {
      final long limit=Performance.memory() + (mb << 20);
      to.schedule(new TimerTask(){
        @Override public void run(){
          if (Performance.memory() > limit) {
            Performance.gc(1);
            if (Performance.memory() > limit)             qctx.stop();
          }
        }
      }
,500,500);
    }
    final long ms=opts.get(XQueryOptions.TIMEOUT) * 1000L;
    if (ms != 0) {
      to.schedule(new TimerTask(){
        @Override public void run(){
          qctx.stop();
        }
      }
,ms);
    }
  }
  try {
    final StaticContext sctx=new StaticContext(qctx.context);
    for (    final Map.Entry<String,Value> it : bindings.entrySet()) {
      final String k=it.getKey();
      final Value v=it.getValue();
      if (k.isEmpty())       qctx.context(v,null,sctx);
 else       qctx.bind(k,v,null);
    }
    qctx.parseMain(string(qu),path,sctx);
    if (updating) {
      if (!sc.mixUpdates && !qctx.updating && !qctx.root.expr.isVacuous())       throw BXXQ_NOUPDATE.get(info);
    }
 else {
      if (qctx.updating)       throw BXXQ_UPDATING.get(info);
    }
    qctx.compile();
    final ValueBuilder vb=new ValueBuilder();
    cache(qctx.iter(),vb,qctx);
    return vb;
  }
 catch (  final ProcException ex) {
    throw BXXQ_STOPPED.get(info);
  }
catch (  final QueryException ex) {
    throw ex.err() == BASX_PERM ? BXXQ_PERM.get(info,ex.getLocalizedMessage()) : ex;
  }
 finally {
    qc.context.user.perm=tmp;
    qc.proc(null);
    qctx.close();
    to.cancel();
  }
}
