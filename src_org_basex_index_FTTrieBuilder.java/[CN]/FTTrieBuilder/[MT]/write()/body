{
  writeSortedList(csize++);
  if (!merge)   return;
  final DataOutput outb=new DataOutput(data.meta.file(DATAFTX + 'b'));
  final DataOutput outt=new DataOutput(data.meta.file(DATAFTX + 't'));
  final byte[][] tok=new byte[csize][];
  final int[][] pres=new int[csize][];
  final int[][] pos=new int[csize][];
  final FTSortedList[] v=new FTSortedList[csize];
  for (int b=0; b < csize; b++) {
    v[b]=new FTSortedList(data,b);
    tok[b]=v[b].nextTok();
    pres[b]=v[b].nextPreValues();
    pos[b]=v[b].nextPosValues();
  }
  int min;
  final IntList mert=new IntList();
  while (check(tok)) {
    min=0;
    mert.reset();
    mert.add(min);
    for (int i=0; i < csize; i++) {
      if (min == i || tok[i].length == 0)       continue;
      final int d=diff(tok[min],tok[i]);
      if (d > 0 || tok[min].length == 0) {
        min=i;
        mert.reset();
        mert.add(min);
      }
 else       if (d == 0 && tok[i].length > 0) {
        mert.add(i);
      }
    }
    outt.write(tok[min].length);
    outt.write(tok[min]);
    int s=0;
    final TokenBuilder tbp=new TokenBuilder();
    final TokenBuilder tbo=new TokenBuilder();
    tbp.add(new byte[4]);
    tbo.add(new byte[4]);
    for (int j=0; j < mert.size(); j++) {
      final int m=mert.get(j);
      for (      final int p : pres[m])       tbp.add(Num.num(p));
      for (      final int p : pos[m])       tbo.add(Num.num(p));
      s+=v[m].nextFTDataSize();
      tok[m]=nextToken(v,m);
      pres[m]=tok[m].length > 0 ? v[m].nextPreValues() : new int[0];
      pos[m]=tok[m].length > 0 ? v[m].nextPosValues() : new int[0];
    }
    outt.writeInt(s);
    outt.write5(outb.size());
    final byte[] p=tbp.finish();
    Num.size(p,p.length);
    final byte[] o=tbo.finish();
    Num.size(o,o.length);
    writeFTData(outb,p,o);
  }
  outt.write(0);
  outt.close();
  outb.close();
  writeTrie();
}
