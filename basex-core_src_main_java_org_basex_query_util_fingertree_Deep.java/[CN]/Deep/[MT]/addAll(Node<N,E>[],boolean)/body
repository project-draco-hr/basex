{
  final int k=nodes.length;
  if (k == 0)   return this;
  if (k == 1)   return appendLeft ? cons(nodes[0]) : snoc(nodes[0]);
  if (appendLeft) {
    int l=k + left.length;
    final Node<N,E>[] ls=slice(nodes,0,l);
    System.arraycopy(left,0,ls,k,left.length);
    if (l <= 4)     return Deep.get(ls,middle,right);
    FingerTree<Node<N,E>,E> newMid=middle;
    for (; l > 4; l-=3) {
      final InnerNode<N,E> sub=new InnerNode3<>(ls[l - 3],ls[l - 2],ls[l - 1]);
      newMid=newMid.cons(sub);
    }
    return Deep.get(slice(ls,0,l),newMid,right);
  }
  final int r=right.length + k;
  final Node<N,E>[] rs=slice(right,0,r);
  System.arraycopy(nodes,0,rs,right.length,k);
  if (k + right.length <= 4)   return Deep.get(left,middle,rs);
  FingerTree<Node<N,E>,E> newMid=middle;
  int i=0;
  for (; r - i > 4; i+=3) {
    final InnerNode<N,E> sub=new InnerNode3<>(rs[i],rs[i + 1],rs[i + 2]);
    newMid=newMid.snoc(sub);
  }
  return Deep.get(left,newMid,slice(rs,i,r));
}
