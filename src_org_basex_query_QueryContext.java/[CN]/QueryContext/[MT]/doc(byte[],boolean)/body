{
  if (contains(db,'<') || contains(db,'>'))   Err.or(INVDOC,db);
  for (int c=0; c < colls; c++) {
    for (int n=0; n < collect[c].size; n++) {
      if (eq(db,collect[c].list[n].base()))       return (DBNode)collect[c].list[n];
    }
  }
  final String dbname=string(db);
  for (int d=0; d < docs; d++)   if (doc[d].data.meta.dbname.equals(dbname))   return doc[d];
  final IO bxw=IO.get(string(db));
  for (int d=0; d < docs; d++)   if (doc[d].data.meta.file.eq(bxw))   return doc[d];
  Data data=null;
  String msg=bxw.toString();
  try {
    data=Prop.web ? Open.open(dbname) : Check.check(dbname);
  }
 catch (  final IOException ex) {
    if (Prop.web) {
      Err.or(INVDOC,dbname);
    }
 else {
      msg=ex.getMessage();
      if (file != null) {
        try {
          data=Check.check(file.merge(bxw).path());
        }
 catch (        final IOException e) {
          msg=e.getMessage();
        }
      }
    }
  }
  if (data == null)   Err.or(coll ? NOCOLL : NODOC,msg);
  if (docs == doc.length)   doc=Array.extend(doc);
  doc[docs]=new DBNode(data,0);
  return doc[docs++];
}
