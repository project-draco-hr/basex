{
  final Constr c=new Constr(ii,sc).add(ctx,expr[1]);
  final ANodeList cList=c.children;
  final ANodeList aList=c.atts;
  if (c.errAtt)   throw UPNOATTRPER.get(info);
  if (c.duplAtt != null)   throw UPATTDUPL.get(info,new QNm(c.duplAtt));
  final Iter t=ctx.iter(expr[0]);
  final Item i=t.next();
  if (i == null)   throw UPSEQEMP.get(info,Util.className(this));
  if (!(i instanceof ANode) || t.next() != null)   throw (before || after ? UPTRGTYP2 : UPTRGTYP).get(info);
  final ANode n=(ANode)i;
  final ANode par=n.parent();
  if (before || after) {
    if (n.type == NodeType.ATT || n.type == NodeType.DOC)     throw UPTRGTYP2.get(info);
    if (par == null)     throw UPPAREMPTY.get(info);
  }
 else {
    if (n.type != NodeType.ELM && n.type != NodeType.DOC)     throw UPTRGTYP.get(info);
  }
  UpdatePrimitive up;
  DBNode dbn;
  if (!aList.isEmpty()) {
    final ANode targ=before || after ? par : n;
    if (targ.type != NodeType.ELM)     throw (before || after ? UPATTELM : UPATTELM2).get(info);
    dbn=ctx.updates.determineDataRef(targ,ctx);
    up=new InsertAttribute(dbn.pre,dbn.data,info,checkNS(aList,targ));
    ctx.updates.add(up,ctx);
  }
  if (!cList.isEmpty()) {
    dbn=ctx.updates.determineDataRef(n,ctx);
    if (before)     up=new InsertBefore(dbn.pre,dbn.data,info,cList);
 else     if (after)     up=new InsertAfter(dbn.pre,dbn.data,info,cList);
 else     if (first)     up=new InsertIntoAsFirst(dbn.pre,dbn.data,info,cList);
 else     if (last)     up=new InsertIntoAsLast(dbn.pre,dbn.data,info,cList);
 else     up=new InsertInto(dbn.pre,dbn.data,info,cList);
    ctx.updates.add(up,ctx);
  }
  return null;
}
