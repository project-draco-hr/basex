{
  if (in == null) {
    final IO io=IO.get(args[1]);
    if (!io.exists())     return error(RES_NOT_FOUND_X,io);
    in=io.inputSource();
  }
  final String path=MetaData.normPath(args[0]);
  if (path == null || path.isEmpty())   return error(NO_DIR_ALLOWED_X,args[0]);
  final Data data=context.data();
  if (!startUpdate())   return false;
  try {
    final IOFile file=data.inMemory() ? null : data.meta.binary(path);
    if (file != null && file.exists()) {
      final Store store=new Store(path);
      store.setInput(in);
      store.lock=false;
      if (!store.run(context))       return error(store.info());
    }
 else {
      final Add add=new Add(path);
      try {
        add.setInput(in);
        add.init(context,out);
        if (!add.build())         return error(add.info());
        final AtomicUpdateCache auc=new AtomicUpdateCache(data);
        final IntList docs=data.resources.docs(path,true);
        if (docs.isEmpty()) {
          auc.addInsert(data.meta.size,-1,add.clip);
        }
 else {
          auc.addReplace(docs.get(0),add.clip);
          final int ds=docs.size();
          for (int d=1; d < ds; d++)           auc.addDelete(docs.get(d));
        }
        context.invalidate();
        auc.execute(false);
      }
  finally {
        add.close();
      }
    }
    return info(RES_REPLACED_X_X,1,perf);
  }
  finally {
    finishUpdate();
  }
}
