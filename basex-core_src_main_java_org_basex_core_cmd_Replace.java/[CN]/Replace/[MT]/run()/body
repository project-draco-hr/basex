{
  if (in == null) {
    final IO io=IO.get(args[1]);
    if (!io.exists())     return error(RES_NOT_FOUND_X,io);
    in=io.inputSource();
  }
  final String path=MetaData.normPath(args[0]);
  if (path == null || path.isEmpty() || path.endsWith("."))   return error(PATH_INVALID_X,args[0]);
  final Data data=context.data();
  final IOFile bin=data.meta.binary(path);
  if (bin == null || bin.isDir())   return error(PATH_INVALID_X,args[0]);
  if (!startUpdate())   return false;
  try {
    final AtomicUpdateCache auc=new AtomicUpdateCache(data);
    final IntList docs=data.resources.docs(path);
    int d=0, bs=0;
    if (bin.exists()) {
      final Store store=new Store(path);
      store.setInput(in);
      store.lock=false;
      if (!store.run(context))       return error(store.info());
      bs=1;
    }
 else {
      final Add add=new Add(path);
      try {
        add.setInput(in);
        add.init(context,out);
        if (!add.build())         return error(add.info());
        if (docs.isEmpty()) {
          auc.addInsert(data.meta.size,-1,add.clip);
        }
 else {
          auc.addReplace(docs.get(0),add.clip);
          d=1;
        }
        context.invalidate();
      }
  finally {
        add.close();
      }
    }
    final int ds=docs.size();
    for (; d < ds; d++)     auc.addDelete(docs.get(d));
    auc.execute(false);
    return info(RES_REPLACED_X_X,ds + bs,perf);
  }
  finally {
    finishUpdate();
  }
}
