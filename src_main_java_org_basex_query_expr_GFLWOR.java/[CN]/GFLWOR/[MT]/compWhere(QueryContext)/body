{
  if (where == null)   return;
  for (  final ForLet f : fl) {
    if (f instanceof For && (!f.simple(false) || !where.removable(f.var)))     return;
  }
  final Expr[] tests=where instanceof And ? ((And)where).expr : new Expr[]{where};
  final int[] tar=new int[tests.length];
  for (int t=0; t < tests.length; ++t) {
    int fr=-1;
    for (int f=fl.length - 1; f >= 0; --f) {
      if (fl[f] instanceof For)       fr=f;
      if (tests[t].count(fl[f].var) != 0) {
        if (fr == -1)         return;
        tar[t]=fr;
        break;
      }
    }
  }
  ctx.compInfo(OPTWHERE);
  for (int t=0; t < tests.length; ++t) {
    final ForLet f=fl[tar[t]];
    Expr e=tests[t].remove(f.var);
    if (e.type().mayBeNum())     e=Function.BOOLEAN.get(input,e);
    if (f.expr instanceof AxisPath) {
      f.expr=((AxisPath)f.expr).addPreds(e);
    }
 else     if (f.expr instanceof Filter) {
      f.expr=((Filter)f.expr).addPred(e);
    }
 else {
      f.expr=new Filter(input,f.expr,e);
    }
  }
  where=null;
}
