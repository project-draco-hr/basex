{
  treeAwareUpdates();
  int par=-2;
  int first=-1;
  for (int i=nodes.size() - 1; i >= 0; i--) {
    final int pre=nodes.get(i);
    final int parT=d.parent(pre,d.kind(pre));
    if (parT != par) {
      if (first > -1)       mergeTexts(par,first);
      first=-1;
      par=parT;
    }
    int add=0;
    final NodePrimitives prim=op.get(pre);
    prim.optimize();
    if (prim.textAdjacency())     first=pre;
    for (    final Primitive up : prim)     add+=up.apply(add);
  }
  if (first > -1)   mergeTexts(par,first);
  d.flush();
  if (d.meta.prop.is(Prop.WRITEBACK) && !d.meta.path.isEmpty()) {
    try {
      final Context c=ctx.context;
      Export.export(c.prop,d,d.meta.path);
    }
 catch (    final IOException ex) {
      UPPUTERR.thrw(null,d.meta.path);
    }
  }
}
