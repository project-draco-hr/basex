{
  final Data src=clip.data;
  final int srcSize=clip.size();
  if (srcSize != data.size(location,data.kind(location)))   return false;
  final List<BasicUpdate> valueUpdates=new ArrayList<>();
  for (int c=0; c < srcSize; c++) {
    final int s=clip.start + c;
    final int t=location + c;
    final int sk=src.kind(s);
    final int tk=data.kind(t);
    if (sk != tk)     return false;
    if (c > 0 && src.dist(s,sk) != data.dist(t,tk))     return false;
    if (sk == Data.TEXT || sk == Data.COMM) {
      final byte[] srcText=src.text(s,true);
      if (data.textLen(t,true) != src.textLen(s,true) || !eq(data.text(t,true),srcText))       valueUpdates.add(UpdateValue.getInstance(data,t,srcText));
    }
 else {
      final byte[] srcName=src.name(s,sk);
      final byte[] trgName=data.name(t,tk);
      if (!eq(srcName,trgName))       valueUpdates.add(Rename.getInstance(data,t,srcName,EMPTY));
switch (sk) {
case Data.ELEM:
        if (src.attSize(s,sk) != data.attSize(t,tk) || src.size(s,sk) != data.size(t,tk))         return false;
      break;
case Data.ATTR:
    byte[] srcValue=src.text(s,false);
  if (!eq(data.text(t,false),srcValue))   valueUpdates.add(UpdateValue.getInstance(data,t,srcValue));
break;
case Data.PI:
final byte[] srcText=src.text(s,true);
final byte[] trgText=data.text(t,true);
final int i=indexOf(srcText,' ');
srcValue=i == -1 ? EMPTY : substring(srcText,i + 1);
if (!eq(srcValue,indexOf(trgText,' ') == -1 ? EMPTY : substring(trgText,i + 1))) {
valueUpdates.add(UpdateValue.getInstance(data,t,srcValue));
}
break;
}
}
}
for (final BasicUpdate bu : valueUpdates) bu.apply(data);
return true;
}
