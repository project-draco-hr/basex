{
  if (cn == 0) {
    if (nextL.list[cn].length > 3) {
      final int p=getInsertingPosition(cn,v[0]);
      if (!found) {
        int[] e;
        e=new int[3];
        e[0]=tokensL.size;
        tokensL.add(v);
        if (d == null) {
          e[1]=0;
          e[2]=0;
        }
 else {
          e[1]=d[0].length;
          e[2]=addDataToNode(0,d,0);
        }
        nextL.add(e);
        insertNodeInNextArray(cn,nextL.size - 1,p);
        return nextL.size - 1;
      }
 else {
        return insertNodeIntoTrie(nextL.list[cn][p],v,d);
      }
    }
  }
  final byte[] is=(nextL.list[cn][0] == -1) ? null : calculateIntersection(tokensL.list[nextL.list[cn][0]],v);
  byte[] r1=(nextL.list[cn][0] == -1) ? null : tokensL.list[nextL.list[cn][0]];
  byte[] r2=v;
  if (is != null) {
    r1=getBytes(r1,is.length,r1.length);
    r2=getBytes(v,is.length,v.length);
  }
  if (is != null) {
    if (r1 == null) {
      if (r2 == null) {
        if (d != null) {
          if (nextL.list[cn][nextL.list[cn].length - 2] == 0) {
            nextL.list[cn][nextL.list[cn].length - 1]=addDataToNode(nextL.list[cn][nextL.list[cn].length - 2],d,nextL.list[cn][nextL.list[cn].length - 1]);
            nextL.list[cn][nextL.list[cn].length - 2]=d[0].length;
          }
 else {
            addDataToNode(nextL.list[cn][nextL.list[cn].length - 2],d,nextL.list[cn][nextL.list[cn].length - 1]);
            nextL.list[cn][nextL.list[cn].length - 2]+=d[0].length;
          }
        }
        return cn;
      }
 else {
        final int posti=getInsertingPosition(cn,r2[0]);
        if (!found) {
          int[] e;
          e=new int[3];
          e[0]=tokensL.size;
          tokensL.add(r2);
          if (d == null) {
            e[1]=0;
            e[2]=0;
          }
 else {
            e[1]=d[0].length;
            e[2]=addDataToNode(0,d,0);
          }
          nextL.add(e);
          insertNodeInNextArray(cn,nextL.size - 1,posti);
          return nextL.size - 1;
        }
 else {
          return insertNodeIntoTrie(nextL.list[cn][posti],r2,d);
        }
      }
    }
 else {
      if (r2 == null) {
        int[] oe=new int[4];
        tokensL.list[nextL.list[cn][0]]=is;
        oe[0]=nextL.list[cn][0];
        int did=nextL.list[cn][nextL.list[cn].length - 1];
        if (d != null) {
          oe[3]=addDataToNode(0,d,0);
          oe[2]=d[0].length;
        }
 else {
          oe[3]=0;
          oe[2]=0;
        }
        int[] ne=new int[nextL.list[cn].length];
        System.arraycopy(nextL.list[cn],0,ne,0,ne.length);
        ne[0]=tokensL.size;
        tokensL.add(r1);
        ne[ne.length - 1]=did;
        ne[ne.length - 2]=preL.list[did].length;
        nextL.add(ne);
        oe[1]=nextL.size - 1;
        nextL.list[cn]=oe;
        return nextL.size - 1;
      }
 else {
        tokensL.list[nextL.list[cn][0]]=is;
        int[] one=nextL.list[cn];
        int[] ne=new int[5];
        ne[0]=one[0];
        if (Token.lc(r2[0]) < Token.lc(r1[0]) || (Token.lc(r2[0]) == Token.lc(r1[0]) && Token.uc(r2[0]) == r1[0])) {
          ne[1]=nextL.size;
          ne[2]=nextL.size + 1;
        }
 else {
          ne[1]=nextL.size + 1;
          ne[2]=nextL.size;
        }
        ne[3]=0;
        ne[4]=0;
        nextL.list[cn]=ne;
        ne=new int[3];
        ne[0]=tokensL.size;
        tokensL.add(r2);
        if (d != null) {
          ne[1]=d[0].length;
          ne[2]=addDataToNode(0,d,0);
        }
 else {
          ne[1]=0;
          ne[2]=0;
        }
        nextL.add(ne);
        ne=new int[one.length];
        System.arraycopy(one,0,ne,0,ne.length);
        ne[0]=tokensL.size;
        tokensL.add(r1);
        nextL.add(ne);
        return nextL.size - 1;
      }
    }
  }
 else {
    int[] ne=new int[3];
    ne[0]=tokensL.size;
    tokensL.add(v);
    if (d != null) {
      ne[2]=addDataToNode(0,d,0);
      ne[1]=d[0].length;
    }
 else {
      ne[1]=0;
      ne[2]=0;
    }
    nextL.add(ne);
    final int ip=getInsertingPosition(cn,v[0]);
    insertNodeInNextArray(cn,nextL.size - 1,ip);
    return nextL.size - 1;
  }
}
