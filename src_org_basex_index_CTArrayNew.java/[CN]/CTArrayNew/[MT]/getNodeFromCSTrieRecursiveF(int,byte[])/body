{
  byte[] vsn=sn;
  if (cn != 0) {
    int i=0;
    while (i < vsn.length && i < tokens[next[cn][0]].length && Token.lc(tokens[next[cn][0]][i]) == vsn[i]) {
      i++;
    }
    if (tokens[next[cn][0]].length == i) {
      if (vsn.length == i) {
        int[][] tmp=new int[2][];
        tmp[0]=pre[next[cn][next[cn].length - 1]];
        tmp[1]=pos[next[cn][next[cn].length - 1]];
        return tmp;
      }
 else {
        final byte[] tmp=new byte[vsn.length - i];
        for (int j=0; j < tmp.length; j++) {
          tmp[j]=vsn[i + j];
        }
        vsn=tmp;
        final int p=getInsPosLinCSF(cn,vsn[0]);
        if (!found) {
          if (Token.lc(tokens[next[next[cn][p]][0]][0]) != vsn[0])           return null;
 else           return getNodeFromCSTrieRecursiveF(next[cn][p],vsn);
        }
 else {
          int[][] d=getNodeFromCSTrieRecursiveF(next[cn][p],vsn);
          if (Token.lc(tokens[next[next[cn][p + 1]][0]][0]) == vsn[0]) {
            d=FTUnion.calculateFTOr(d,getNodeFromCSTrieRecursiveF(next[cn][p + 1],vsn));
          }
          return d;
        }
      }
    }
 else {
      return null;
    }
  }
 else {
    final int p=getInsPosLinCSF(cn,vsn[0]);
    if (!found) {
      if (Token.lc(tokens[next[next[cn][p]][0]][0]) != vsn[0])       return null;
 else       return getNodeFromCSTrieRecursiveF(next[cn][p],vsn);
    }
 else {
      int[][] d=getNodeFromCSTrieRecursiveF(next[cn][p],vsn);
      if (Token.lc(tokens[next[next[cn][p + 1]][0]][0]) == vsn[0]) {
        d=FTUnion.calculateFTOr(d,getNodeFromCSTrieRecursiveF(next[cn][p + 1],vsn));
      }
      return d;
    }
  }
}
