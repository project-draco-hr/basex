{
  if (cn == 0) {
    if (nextL.list[cn].length > 3) {
      final int p=getPointer(cn);
      if (tokensL.list[nextL.list[nextL.list[cn][p]][0]][0] != v[0]) {
        int[] e;
        e=new int[2 + offset.length];
        e[0]=tokensL.size;
        tokensL.add(v);
        e[1]=s;
        System.arraycopy(offset,0,e,2,offset.length);
        nextL.add(e);
        insertNodeInNextArray(cn,nextL.size - 1,p + 1);
        return nextL.size - 1;
      }
 else {
        return insertNodeSorted(nextL.list[cn][p],v,s,offset);
      }
    }
  }
  final byte[] is=(nextL.list[cn][0] == -1) ? null : calculateIntersection(tokensL.list[nextL.list[cn][0]],v);
  byte[] r1=(nextL.list[cn][0] == -1) ? null : tokensL.list[nextL.list[cn][0]];
  byte[] r2=v;
  if (is != null) {
    r1=getBytes(r1,is.length,r1.length);
    r2=getBytes(v,is.length,v.length);
  }
  if (is != null) {
    if (r1 == null) {
      if (r2 != null) {
        final int p=getPointer(cn);
        if (p == 0 || tokensL.list[nextL.list[nextL.list[cn][p]][0]][0] != r2[0]) {
          int[] e;
          e=new int[2 + offset.length];
          e[0]=tokensL.size;
          tokensL.add(r2);
          e[1]=s;
          System.arraycopy(offset,0,e,2,offset.length);
          nextL.add(e);
          insertNodeInNextArray(cn,nextL.size - 1,p + 1);
          return nextL.size - 1;
        }
 else {
          return insertNodeSorted(nextL.list[cn][p],r2,s,offset);
        }
      }
    }
 else {
      if (r2 == null) {
        int[] oe=new int[3 + offset.length];
        tokensL.list[nextL.list[cn][0]]=is;
        oe[0]=nextL.list[cn][0];
        System.arraycopy(offset,0,oe,3,offset.length);
        oe[2]=s;
        nextL.list[cn][0]=tokensL.size;
        tokensL.add(r1);
        nextL.add(nextL.list[cn]);
        oe[1]=nextL.size - 1;
        nextL.list[cn]=oe;
        return nextL.size - 1;
      }
 else {
        tokensL.list[nextL.list[cn][0]]=is;
        int[] one=nextL.list[cn];
        int[] ne=new int[5];
        ne[0]=one[0];
        if (r2[0] < r1[0]) {
          ne[1]=nextL.size;
          ne[2]=nextL.size + 1;
        }
 else {
          ne[1]=nextL.size + 1;
          ne[2]=nextL.size;
        }
        ne[3]=0;
        ne[4]=0;
        nextL.list[cn]=ne;
        ne=new int[2 + offset.length];
        ne[0]=tokensL.size;
        tokensL.add(r2);
        ne[1]=s;
        System.arraycopy(offset,0,ne,2,offset.length);
        nextL.add(ne);
        ne=new int[one.length];
        System.arraycopy(one,0,ne,0,ne.length);
        ne[0]=tokensL.size;
        tokensL.add(r1);
        nextL.add(ne);
        return nextL.size - 1;
      }
    }
  }
 else {
    int[] ne=new int[2 + offset.length];
    ne[0]=tokensL.size;
    tokensL.add(v);
    System.arraycopy(offset,0,ne,2,offset.length);
    ne[1]=s;
    nextL.add(ne);
    final int p=nextL.list[cn].length - 2;
    insertNodeInNextArray(cn,nextL.size - 1,p);
    return nextL.size - 1;
  }
  return -1;
}
