{
  super.paintComponent(g);
  BaseXLayout.antiAlias(g,gui.prop);
  g.setColor(Color.BLACK);
  g.setFont(GUIConstants.font);
  final Performance perf=new Performance();
  perf.initTimer();
  fontHeight=g.getFontMetrics().getHeight();
  if (windowSizeChanged()) {
    realImage=createImage();
    final Graphics rg=realImage.getGraphics();
    rects=new ArrayList<TreeRect>();
    final Nodes curr=gui.context.current();
    for (int i=0; i < curr.size(); i++) {
      treeView(curr.nodes[i],rg,i);
    }
  }
  g.drawImage(realImage,0,0,getWidth(),getHeight(),this);
  final Data data=gui.context.data();
  if (focus()) {
    final TreeRect r=focusedRect;
    g.setColor(markColor);
    g.drawRect(r.x,r.y,r.w,r.h);
    String s="";
    final int l=r.multiPres.length;
    for (int i=0; i < l; i++) {
      if (s.length() > 0)       s+=" | ";
      final int pre=r.multiPres[i];
      if (data.kind(pre) == Data.ELEM) {
        s+=string(data.tag(pre));
      }
 else {
        s+=string(data.text(pre));
      }
      for (int y=0; y < data.attSize(pre,data.kind(pre)) - 1; y++) {
        s+=" " + string(data.attName(pre + y + 1)) + "="+ "\""+ string(data.attValue(pre + y + 1))+ "\" ";
      }
    }
    final int w=BaseXLayout.width(g,s);
    g.setColor(highlightColor);
    g.fillRect(r.x - 1,r.y - fontHeight,w + 1,fontHeight);
    g.setColor(Color.WHITE);
    g.drawString(s,r.x + 1,(int)(r.y - fontHeight / 4f));
  }
  if (!rects.isEmpty() && gui.context.marked().size() > 0) {
    final Iterator<TreeRect> it=rects.iterator();
    while (it.hasNext()) {
      final TreeRect r=it.next();
      int size=gui.context.marked().size();
      final int[] markedNodes=new int[size];
      System.arraycopy(gui.context.marked().nodes,0,markedNodes,0,size);
      for (int j=0; j < size; j++) {
        for (        final int multiPre : r.multiPres) {
          if (multiPre == markedNodes[j]) {
            g.setColor(Color.RED);
            g.fillRect(r.x + 1,r.y + 1,r.w - 1,r.h - 1);
            drawTextIntoRectangle(g,data.kind(r.pre),r.pre,r.x + (int)(r.w / 2f),r.w,r.y);
            if (size < 2) {
              return;
            }
 else             if (j < size - 1) {
              markedNodes[j]=markedNodes[size - 1];
            }
            size--;
            break;
          }
        }
      }
    }
  }
}
