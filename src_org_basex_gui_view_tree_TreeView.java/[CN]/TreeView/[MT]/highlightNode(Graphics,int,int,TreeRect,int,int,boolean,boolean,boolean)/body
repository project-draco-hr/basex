{
  if (l == -1)   return;
  final int y=getYperLevel(l);
  final int h=nodeHeight;
  final boolean br=cache.isBigRectangle(rn,l);
  final Data d=gui.context.data;
  final int k=d.kind(pre);
  final int size=d.size(pre,k);
  int multiPreX=-1;
  if (fillNodes) {
    drawRectangle(g,rn,l,r,pre,false,true,DRAW_HIGHLIGHT);
  }
 else {
    drawRectangle(g,rn,l,r,pre,true,false,DRAW_HIGHLIGHT);
  }
  if (br) {
    final int index=cache.getPreIndex(rn,l,pre);
    final double ratio=index / (double)(cache.getLevelSize(rn,l) - 1);
    multiPreX=(int)(r.w * ratio);
    g.drawLine(multiPreX,y,multiPreX,y + nodeHeight);
  }
  if (childX > -1) {
    g.drawLine(childX,getYperLevel(l + 1) - 1,multiPreX == -1 ? (2 * r.x + r.w) / 2 : multiPreX,y + nodeHeight + 1);
  }
  if (showParent && pre > 0) {
    final int par=d.parent(pre,k);
    final int lv=l - 1;
    TreeRect parRect=null;
    if (lv >= 0) {
      if (cache.isBigRectangle(rn,lv)) {
      }
 else {
        parRect=cache.searchRect(rn,lv,par);
        if (parRect != null) {
          highlightNode(g,rn,par,parRect,lv,multiPreX == -1 ? (2 * r.x + r.w) / 2 : multiPreX,true,true,false);
        }
      }
    }
  }
  if (showDescendants && size > 1 && l + 1 < cache.getHeight(rn)) {
    int lv=l + 1;
    TreeBorder[] sbo=cache.generateSubtreeBorders(d,pre);
    if (cache.isBigRectangle(rn,lv)) {
    }
 else {
      if (sbo.length < 2)       return;
      TreeBorder bo=sbo[1];
      TreeBorder bos=cache.getTreeBorder(rn,lv);
      for (int j=0; j < bo.size; j++) {
        int pi=cache.getPrePerIndex(bo,j);
        final TreeRect sr=cache.getTreeRectPerIndex(rn,lv,j + bo.start - bos.start);
        final int parX=multiPreX == -1 ? (2 * r.x + r.w) / 2 : multiPreX;
        if (SHOW_DESCENDANTS_CONN) {
          g.setColor(Color.GREEN);
          g.fillPolygon(new int[]{parX,sr.x + 2,sr.x + 2},new int[]{getYperLevel(l) + nodeHeight,getYperLevel(lv) - 1,getYperLevel(lv) - 1 + nodeHeight},3);
          g.setColor(Color.RED);
          g.fillPolygon(new int[]{parX,sr.x + sr.w - 2,sr.x + sr.w - 2},new int[]{getYperLevel(l) + nodeHeight,getYperLevel(lv) - 1,getYperLevel(lv) - 1 + nodeHeight},3);
          g.setColor(new Color(0x38323D4F,false));
          g.fillPolygon(new int[]{parX,sr.x,sr.x + sr.w,sr.x,sr.x + sr.w},new int[]{getYperLevel(l) + nodeHeight,getYperLevel(lv) - 1,getYperLevel(lv) - 1,getYperLevel(lv) - 1 + nodeHeight,getYperLevel(lv) - 1 + nodeHeight},3);
        }
        highlightNode(g,rn,pi,sr,lv,-1,true,false,true);
      }
      lv++;
    }
  }
  if (!(showParent && showDescendants) || gui.context.current.nodes[rn] == pre)   return;
  final String s=Token.string(cache.getText(gui.context,rn,pre));
  final int w=BaseXLayout.width(g,s);
  g.setColor(COLORS[l + 5]);
  g.fillRect(r.x,y - fontHeight,w + 2,fontHeight);
  g.setColor(Color.WHITE);
  g.drawString(s,r.x + 1,(int)(y - h / (float)fontHeight) - 2);
}
