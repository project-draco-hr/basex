{
  final byte[] tag=utf8(name,meta.encoding);
  final int tid=tags.index(tag,null,true);
  path.add(tid,level,Data.ELEM);
  tagStack[level]=tid;
  parStack[level]=meta.size;
  final int pre=meta.size;
  final boolean n=ns.open(meta.size);
  final int dis=level != 0 ? meta.size - parStack[level - 1] : 1;
  final int al=att.size;
  int tns=ns.get(tag);
  if (tns == 0)   tns=nsStack[level];
  addElem(tid,tns,dis,al + 1,n);
  for (int a=0; a < al; a++) {
    final byte[] av=att.val[a];
    final int an=atts.index(att.key[a],av,true);
    final int ans=ns.get(att.key[a]);
    path.add(an,level + 1,Data.ATTR);
    addAttr(an,ans,av,a + 1);
  }
  if (level != 0) {
    if (level == 1) {
      if (inDoc && !Prop.fuse)       error(MOREROOTS,parser.det(),tag);
    }
 else {
      tags.stat(tagStack[level - 1]).leaf=false;
    }
  }
  if (open) {
    if (meta.height < ++level)     meta.height=level;
    nsStack[level]=nsStack[level - 1];
  }
  if (meta.size != 1)   inDoc=true;
  if (Prop.debug) {
    if (++elms % 500000 == 0)     BaseX.err(" " + elms + "\n");
 else     if (elms % 50000 == 0)     BaseX.err("!");
 else     if (elms % 10000 == 0)     BaseX.err(".");
  }
  return pre;
}
