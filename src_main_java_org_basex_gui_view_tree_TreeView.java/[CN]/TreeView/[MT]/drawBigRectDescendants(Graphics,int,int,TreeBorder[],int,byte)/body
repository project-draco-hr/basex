{
  int lvv=lv;
  int cen=parc;
  int i;
  for (i=1; i < subt.length && tr.isBigRectangle(sub,rn,lvv); ++i) {
    final TreeBorder bos=sub.getTreeBorder(rn,lvv);
    final TreeBorder bo=subt[i];
    final TreeRect r=tr.getTreeRectPerIndex(rn,lvv,0);
    final int start=bo.start - bos.start;
    final double sti=start / (double)bos.size;
    final double eni=(start + bo.size) / (double)bos.size;
    final int df=r.x + (int)(r.w * sti);
    final int dt=r.x + (int)(r.w * eni);
    final int ww=Math.max(dt - df,2);
    if (MIN_NODE_DIST_CONN <= levelDistance)     drawDescendantsConn(g,lvv,new TreeRect(df,ww),cen,t);
    cen=(2 * df + ww) / 2;
switch (t) {
case DRAW_CONN:
      break;
default :
    final int rgb=COLORS[7].getRGB();
  final int alpha=0x33000000;
g.setColor(nodeHeight < 4 ? SMALL_SPACE_COLOR : new Color(rgb + alpha,false));
if (nodeHeight > 2) {
g.drawRect(df,getYperLevel(lvv) + 1,ww,nodeHeight - 2);
}
 else {
g.drawRect(df,getYperLevel(lvv),ww,nodeHeight);
}
}
if (lvv + 1 < sub.getSubtreeHeight(rn) && !tr.isBigRectangle(sub,rn,lvv + 1)) {
final Data d=gui.context.current.data;
for (int j=start; j < start + bo.size; ++j) {
final int pre=sub.getPrePerIndex(rn,lvv,j);
final int pos=getBigRectPosition(rn,lvv,pre,r);
final int k=d.kind(pre);
final int s=d.size(pre,k);
if (s > 1) highlightDescendants(g,rn,lvv,r,pre,pos,t == DRAW_HIGHLIGHT || t == DRAW_DESCENDANTS ? DRAW_DESCENDANTS : DRAW_CONN);
}
}
++lvv;
}
}
