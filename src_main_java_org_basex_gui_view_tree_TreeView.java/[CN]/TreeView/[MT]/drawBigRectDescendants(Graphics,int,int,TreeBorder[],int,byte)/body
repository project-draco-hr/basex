{
  int lvv=lv;
  int cen=parc;
  int i;
  for (i=1; i < subt.length && cache.isBigRectangle(rn,lvv); i++) {
    final TreeBorder bos=cache.getTreeBorder(rn,lvv);
    final TreeBorder bo=subt[i];
    final TreeRect r=cache.getTreeRectPerIndex(rn,lvv,0);
    final int start=bo.start - bos.start;
    final double sti=start / (double)bos.size;
    final double eni=(start + bo.size) / (double)bos.size;
    final int df=r.x + (int)(r.w * sti);
    final int dt=r.x + (int)(r.w * eni);
    final int ww=Math.max(dt - df,2);
    if (MIN_NODE_DIST_CONN <= levelDistance)     drawDescendantsConn(g,lvv,new TreeRect(df,ww),cen,t);
    cen=(2 * df + ww) / 2;
switch (t) {
case DRAW_CONN:
      break;
default :
    final int rgb=COLORS[7].getRGB();
  final int alpha=0x33000000;
g.setColor(nodeHeight < 4 ? SMALL_SPACE_COLOR : new Color(rgb + alpha,false));
g.fillRect(df,getYperLevel(lvv),ww,nodeHeight + 1);
}
lvv++;
}
}
