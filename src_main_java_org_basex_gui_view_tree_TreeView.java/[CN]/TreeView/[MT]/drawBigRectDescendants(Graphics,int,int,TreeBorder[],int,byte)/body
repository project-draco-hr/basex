{
  final int h=cache.getHeight(rn);
  int lvv=lv;
  int cen=parc;
  int i;
  for (i=1; i < subt.length && cache.isBigRectangle(rn,lvv); i++) {
    final TreeBorder bos=cache.getTreeBorder(rn,lvv);
    final TreeBorder bo=subt[i];
    final TreeRect r=cache.getTreeRectPerIndex(rn,lvv,0);
    final int start=bo.start - bos.start;
    final double sti=start / (double)bos.size;
    final double eni=(start + bo.size) / (double)bos.size;
    final int df=r.x + (int)(r.w * sti);
    final int dt=r.x + (int)(r.w * eni);
    final int ww=Math.max(dt - df,2);
    if (MIN_NODE_DIST_CONN <= levelDistance)     drawDescendantsConn(g,lvv,new TreeRect(df,ww),cen,t);
    cen=(2 * df + ww) / 2;
switch (t) {
case DRAW_CONN:
      break;
default :
    final int rgb=COLORS[7].getRGB();
  final int alpha=0x33000000;
g.setColor(new Color(rgb + alpha,false));
g.fillRect(df,getYperLevel(lvv),ww,nodeHeight);
}
if (lvv + 1 < h && !cache.isBigRectangle(rn,lvv + 1)) {
final Data d=gui.context.current.data;
for (int j=subt[i].start; j < subt[i].start + subt[i].size; j++) {
final int pre=cache.getPrePerIndex(rn,lvv,j);
final int k=d.kind(pre);
final int s=d.size(pre,k) - d.attSize(pre,k);
if (s > 0) highlightDescendants(g,rn,pre,r,lvv,cen,t == DRAW_HIGHLIGHT || t == DRAW_DESCENDANTS ? DRAW_DESCENDANTS : DRAW_CONN);
}
}
lvv++;
}
}
