{
  final int y=getYperLevel(lv);
  final int h=nodeHeight;
  final boolean br=cache.isBigRectangle(rn,lv);
  boolean txt=!br && fontHeight <= h;
  boolean fill=false;
  boolean border=false;
  Color borderColor=null;
  Color fillColor=null;
  Color textColor=Color.BLACK;
switch (type) {
case DRAW_RECTANGLE:
    borderColor=getColorPerLevel(lv,false);
  fillColor=getColorPerLevel(lv,true);
txt=txt && DRAW_NODE_TEXT;
border=BORDER_RECTANGLES;
fill=FILL_RECTANGLES;
break;
case DRAW_HIGHLIGHT:
borderColor=color6;
fillColor=GUIConstants.COLORCELL;
border=true;
fill=!br;
break;
case DRAW_MARK:
borderColor=h > 2 && r.w > 4 ? colormarkA : colormark1;
fillColor=colormark1;
fill=border=true;
break;
case DRAW_DESCENDANT:
if (h > 2) {
fillColor=COLORS[6];
textColor=Color.WHITE;
fill=true;
}
 else {
borderColor=colormark1;
border=true;
}
break;
case DRAW_PARENT:
fillColor=COLORS[6];
textColor=Color.WHITE;
fill=!br;
}
if (border) {
final int xx=r.x + BORDER_PADDING;
final int ww=r.w - BORDER_PADDING;
g.setColor(borderColor);
g.drawRect(xx,y,ww,h);
if (type == DRAW_HIGHLIGHT) g.drawRect(xx + 1,y + 1,ww - 2,h - 2);
}
if (fill) {
final int xx=r.x + BORDER_PADDING + 1;
final int ww=r.w - BORDER_PADDING - 1;
g.setColor(fillColor);
g.fillRect(xx,y + 1,ww,h - 1);
}
if (txt && (fill || !FILL_RECTANGLES)) {
g.setColor(textColor);
drawRectangleText(g,rn,lv,r,pre);
}
}
