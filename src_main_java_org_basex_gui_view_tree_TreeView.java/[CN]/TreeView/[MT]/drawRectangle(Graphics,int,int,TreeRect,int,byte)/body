{
  final int y=getYperLevel(lv);
  final int h=nodeHeight;
  final boolean br=cache.isBigRectangle(rn,lv);
  boolean txt=!br && fontHeight <= h;
  boolean fill=false;
  boolean border=false;
  Color borderColor=null;
  Color fillColor=null;
  Color textColor=Color.BLACK;
switch (type) {
case DRAW_RECTANGLE:
    borderColor=getColorPerLevel(lv,false);
  fillColor=getColorPerLevel(lv,true);
txt=txt && DRAW_NODE_TEXT;
border=BORDER_RECTANGLES;
fill=FILL_RECTANGLES;
break;
case DRAW_HIGHLIGHT:
borderColor=color6;
final int alpha=0xDD000000;
final int rgb=GUIConstants.COLORCELL.getRGB();
fillColor=new Color(rgb + alpha,true);
border=true;
fill=!br;
break;
case DRAW_MARK:
borderColor=h > 2 && r.w > 4 ? colormarkA : colormark1;
fillColor=colormark1;
fill=border=true;
break;
case DRAW_DESCENDANTS:
final int alphaD=0xDD000000;
final int rgbD=COLORS[6].getRGB();
fillColor=new Color(rgbD + alphaD,true);
borderColor=COLORS[8];
textColor=Color.WHITE;
fill=true;
border=true;
if (h < 2 || r.w < 4) {
borderColor=COLORS[6];
txt=false;
}
break;
case DRAW_PARENT:
fillColor=COLORS[6];
textColor=Color.WHITE;
fill=!br;
if (h < 2 || r.w < 4) {
borderColor=COLORS[6];
border=true;
txt=false;
}
break;
case DRAW_CONN:
txt=false;
break;
}
if (border) {
final int xx=r.x + BORDER_PADDING;
final int ww=r.w - BORDER_PADDING;
g.setColor(borderColor);
g.drawRect(xx,y,ww,h);
}
if (fill) {
final int xx=r.x + BORDER_PADDING + 1;
final int ww=r.w - BORDER_PADDING - 1;
g.setColor(fillColor);
g.fillRect(xx,y + 1,ww,h - 1);
}
if (txt && (fill || !FILL_RECTANGLES)) {
g.setColor(textColor);
drawRectangleText(g,rn,lv,r,pre);
}
}
