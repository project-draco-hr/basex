{
  final int x=selectRect.w < 0 ? selectRect.x + selectRect.w : selectRect.x;
  final int y=selectRect.h < 0 ? selectRect.y + selectRect.h : selectRect.y;
  final int w=Math.abs(selectRect.w);
  final int h=Math.abs(selectRect.h);
  final int t=y + h;
  final int size=sub.getMaxSubtreeHeight();
  final IntList list=new IntList();
  for (int i=0; i < size; i++) {
    final int yL=getYperLevel(i);
    if (i < sub.getSubtreeHeight(frn) && (yL >= y || yL + nodeHeight >= y) && (yL <= t || yL + nodeHeight <= t)) {
      final TreeRect[] rlv=tr.getTreeRectsPerLevel(frn,i);
      final int s=sub.getLevelSize(frn,i);
      if (tr.isBigRectangle(sub,frn,i)) {
        final TreeRect mRect=rlv[0];
        int sPrePos=(int)(s * x / (double)mRect.w);
        int ePrePos=(int)(s * (x + w) / (double)mRect.w);
        if (sPrePos < 0)         sPrePos=0;
        if (ePrePos >= s)         ePrePos=s - 1;
        while (sPrePos++ < ePrePos)         list.add(sub.getPrePerIndex(frn,i,sPrePos));
      }
 else {
        for (int j=0; j < s; j++) {
          final TreeRect rect=rlv[j];
          if (rect.contains(x,w))           list.add(sub.getPrePerIndex(frn,i,j));
        }
      }
    }
  }
  gui.notify.mark(new Nodes(list.finish(),gui.context.data),this);
}
