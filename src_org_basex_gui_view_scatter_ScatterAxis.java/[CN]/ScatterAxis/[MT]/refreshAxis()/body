{
  if (attr == null || attr.length == 0)   return;
  final Data data=GUI.context.data();
  final StatsKey key=isTag ? data.tags.stat(data.tags.id(attr)) : data.atts.stat(data.atts.id(attr));
  numeric=key.kind == Kind.INT || key.kind == Kind.DBL || key.kind == Kind.TEXT;
  if (numeric) {
    if (key.kind == Kind.TEXT)     numType=TYPETEXT;
 else     numType=key.kind == Kind.INT ? TYPEINT : TYPEDBL;
  }
 else {
    cats=key.cats.keys();
    final String[] tmpCats=new String[cats.length];
    for (int i=0; i < tmpCats.length; i++) {
      tmpCats[i]=string(cats[i]);
    }
    Arrays.sort(tmpCats);
    for (int i=0; i < tmpCats.length; i++) {
      cats[i]=token(tmpCats[i]);
    }
    nrCats=cats.length;
  }
  final int[] items=scatterData.pres;
  co=new double[items.length];
  vals=new byte[items.length][];
  for (int i=0; i < items.length; i++) {
    int p=items[i];
    final int limit=p + data.size(p,Data.ELEM);
    byte[] value={};
    p++;
    while (p < limit) {
      final int kind=data.kind(p);
      if (kind == Data.ELEM) {
        final byte[] currName=data.tag(p);
        if (isTag && (eq(attr,currName))) {
          final int attSize=data.attSize(p,kind);
          if (numeric && numType == 2) {
            final int tl=data.textLen(p + attSize);
            value=tl >= TEXTLENGTH ? substring(data.text(p + attSize),0,TEXTLENGTH) : substring(data.text(p + attSize),0,value.length);
          }
 else           value=data.text(p + attSize);
          break;
        }
      }
 else       if (kind == Data.ATTR) {
        final byte[] currName=data.attName(p);
        if ((eq(attr,currName)) && !isTag) {
          value=data.attValue(p);
          break;
        }
      }
      p++;
    }
    vals[i]=value;
  }
  if (numeric) {
    if (numType == TYPETEXT)     textToNum();
    calcExtremeValues();
  }
  for (int i=0; i < vals.length; i++) {
    final byte[] val=vals[i];
    if (val.length > 0) {
      co[i]=calcPosition(val);
    }
  }
  vals=null;
}
