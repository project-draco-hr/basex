{
  final StringList eval=new StringList(1);
  final StringList comp=new StringList(1);
  final StringList plan=new StringList(1);
  final StringList result=new StringList(1);
  final StringList stack=new StringList(1);
  final StringList err=new StringList(1);
  final StringList origqu=new StringList(1);
  final StringList optqu=new StringList(1);
  final StringList command=new StringList(1);
  final StringList timings=new StringList(5);
  final IntList times=new IntList(5);
  final int runs=Math.max(1,gui.context.options.get(MainOptions.RUNS));
  final String[] split=info.split(NL);
  final int sl=split.length;
  for (int s=0; s < sl; s++) {
    final String line=split[s];
    if (line.startsWith(PARSING_CC) || line.startsWith(COMPILING_CC) || line.startsWith(EVALUATING_CC)|| line.startsWith(PRINTING_CC)|| line.startsWith(TOTAL_TIME_CC)) {
      final int t=line.indexOf(" ms");
      final int d=line.indexOf(':');
      final int tm=(int)(Double.parseDouble(line.substring(d + 1,t)) * 100);
      times.add(tm);
      final String key=line.substring(0,d).trim();
      final String val=Performance.getTime(tm * 10000L * runs,runs);
      timings.add(LI + key + COLS+ val);
    }
 else     if (line.startsWith(HITS_X_CC) || line.startsWith(UPDATED_CC) || line.startsWith(PRINTED_CC)|| line.startsWith(READ_LOCKING_CC)|| line.startsWith(WRITE_LOCKING_CC)) {
      result.add(LI + line);
    }
 else     if (line.equals(COMPILING + COL)) {
      while (++s < sl && !split[s].isEmpty())       comp.add(split[s]);
    }
 else     if (line.equals(QUERY + COL)) {
      while (++s < sl && !split[s].isEmpty())       origqu.add(split[s]);
    }
 else     if (line.equals(OPTIMIZED_QUERY + COL)) {
      while (++s < sl && !split[s].isEmpty())       optqu.add(split[s]);
    }
 else     if (line.startsWith(EVALUATING)) {
      while (++s < sl && split[s].startsWith(LI))       eval.add(split[s]);
    }
 else     if (line.equals(QUERY_PLAN + COL)) {
      while (++s < sl && !split[s].isEmpty())       plan.add(split[s]);
    }
 else     if (line.equals(Text.ERROR + COL)) {
      while (++s < sl && !split[s].isEmpty()) {
        final Pattern p=Pattern.compile(STOPPED_AT + "(.*)" + COL);
        final Matcher m=p.matcher(split[s]);
        if (m.find()) {
          final TokenBuilder tb=new TokenBuilder();
          tb.add(STOPPED_AT).uline().add(m.group(1)).uline().add(COL);
          split[s]=tb.toString();
        }
        err.add(split[s]);
      }
    }
 else     if (line.equals(STACK_TRACE + COL)) {
      while (++s < sl && !split[s].isEmpty()) {
        final TokenBuilder tb=new TokenBuilder();
        final String sp=split[s].replaceAll("<.*","");
        final boolean last=!sp.equals(split[s]);
        if (sp.startsWith(LI)) {
          tb.add(LI).uline().add(sp.substring(2)).uline();
        }
 else {
          tb.add(sp);
        }
        stack.add(tb.toString());
        if (last)         break;
      }
    }
 else     if (!ok && !line.isEmpty()) {
      err.add(line);
    }
  }
  stat=times;
  strings=timings;
  if (clear || !times.isEmpty() || !ok)   text.reset();
  String inf=null;
  if (!(cmd instanceof AQuery)) {
    if (cmd != null)     command.add(cmd.toString());
    if (ok && !info.isEmpty()) {
      if (reset)       result.add(info.trim());
 else       if (cmd == null)       inf=info.trim();
    }
  }
  add(COMMAND + COL,command);
  add(Text.ERROR + COL,err);
  add(STACK_TRACE + COL,stack);
  add(EVALUATING + COL,eval);
  add(COMPILING + COL,comp);
  add(QUERY + COL,origqu);
  add(OPTIMIZED_QUERY + COL,optqu);
  add(RESULT + COL,result);
  add(TIMING + COL,timings);
  add(QUERY_PLAN + COL,plan);
  if (inf != null)   text.add(inf).nline();
  changed=true;
  clear=reset;
  String total=time;
  if (!times.isEmpty()) {
    total=Performance.getTime(times.get(times.size() - 1) * 10000L * runs,runs);
  }
  if (total != null)   timer.setText(TOTAL_TIME_CC + total);
  repaint();
}
