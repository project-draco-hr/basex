{
  final XQuery query=new XQuery("\n" + "declare namespace map = \"http://snelson.org.uk/functions/map\";\n" + "\n"+ "declare function map:key($pair as function() as item()+) as item()\n"+ "{\n"+ "  $pair()[1]\n"+ "};\n"+ "\n"+ "declare function map:value($pair as function() as item()+) as item()*\n"+ "{\n"+ "  subsequence($pair(), 2)\n"+ "};\n"+ "\n"+ "declare function map:contains($map as (function() as item()+)*, $key as item())\n"+ "  as xs:boolean\n"+ "{\n"+ "  map:process($map, $key, function($a) { true() }, false(),\n"+ "    function($a) { () })\n"+ "};\n"+ "\n"+ "declare function map:get($map as (function() as item()+)*, $key as item())\n"+ "  as item()*\n"+ "{\n"+ "  map:process($map, $key, map:value#1, (), function($a) { () })\n"+ "};\n"+ "\n"+ "declare function map:process(\n"+ "  $map as (function() as item()+)*,\n"+ "  $key as item(),\n"+ "  $found as function(function() as item()+) as item()*,\n"+ "  $notfound as item()*,\n"+ "  $unused as function((function() as item()+)*) as item()*\n"+ ") as item()*\n"+ "{\n"+ "  if(empty($map)) then $notfound\n"+ "  else\n"+ "\n"+ "  let $length := count($map)\n"+ "  let $middle := $length idiv 2 + 1\n"+ "  let $pair := $map[$middle]\n"+ "  let $pair_key := $pair()[1]\n"+ "  return\n"+ "    if($pair_key eq $key) then (\n"+ "      $unused(subsequence($map, 1, $middle - 1)),\n"+ "      $found($pair),\n"+ "      $unused(subsequence($map, $middle + 1))\n"+ "    )\n"+ "    else if($pair_key gt $key) then (\n"+ "      map:process(subsequence($map, 1, $middle - 1), $key,\n"+ "        $found, $notfound, $unused),\n"+ "      $unused(subsequence($map, $middle))\n"+ "    )\n"+ "    else (\n"+ "      $unused(subsequence($map, 1, $middle)),\n"+ "      map:process(subsequence($map, $middle + 1), $key,\n"+ "        $found, $notfound, $unused)\n"+ "    )\n"+ "};\n"+ "\n"+ "declare function map:pair($key as item(), $value as item()*)\n"+ "  as function() as item()+\n"+ "{\n"+ "  function() { $key, $value }\n"+ "};\n"+ "\n"+ "declare function map:put(\n"+ "  $map as (function() as item()+)*,\n"+ "  $key as item(),\n"+ "  $value as item()*\n"+ ") as (function() as item()+)+\n"+ "{\n"+ "  let $pair := map:pair($key, $value)\n"+ "  return\n"+ "    map:process($map, $key, function($a) { $pair }, $pair,\n"+ "      function($a) { $a })\n"+ "};\n"+ "\n"+ "string-join(let $map := map:put(map:put(map:put(map:put(map:put(map:put((),\n"+ "  \"a\", \"aardvark\"),\n"+ "  \"z\", \"zebra\"),\n"+ "  \"e\", (\"elephant\", \"eagle\")),\n"+ "  \"o\", \"osterich\"),\n"+ "  \"t\", \"terrapin\"),\n"+ "  \"a\", \"antelope\")\n"+ "return (\n"+ "  map:get($map, \"o\"),\n"+ "\n"+ "  for $m in $map\n"+ "  return concat(\"key: \", map:key($m), \", value: (\",\n"+ "    string-join(map:value($m), \", \"), \")\"))\n"+ ", \"\n"+ "\")\n"+ "",ctx);
  try {
    result=new QT3Result(query.value());
  }
 catch (  final Throwable trw) {
    result=new QT3Result(trw);
  }
 finally {
    query.close();
  }
  test(assertEq("\"osterich\nkey: a, value: (antelope)\nkey: e, value: (elephant, eagle)\nkey: o, value: (osterich)\nkey: t, value: (terrapin)\nkey: z, value: (zebra)\""));
}
