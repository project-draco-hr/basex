{
  final UserFunc uf=function.function;
  final BaseFuncCall bfc=new BaseFuncCall(null,uf.name,uf.args);
  bfc.init(uf);
  function.bind(http);
  String redirect=null;
  String forward=null;
  try {
    qc.updating=bfc.uses(Use.UPD);
    qc.context(http,null);
    qc.context.register(qc);
    final StringList o=qc.dbOptions;
    for (int s=0; s < o.size(); s+=2)     qc.context.prop.set(o.get(s),o.get(s + 1));
    Value result=qc.value(bfc.compile(qc));
    final Value update=qc.update();
    if (update != null)     result=update;
    final ValueIter iter=result.iter();
    Item item=iter.next();
    ANode resp=null;
    if (item != null && item.type.isNode()) {
      final ANode node=(ANode)item;
      if (RESTXQ_RESPONSE.eq(node)) {
        resp=node;
        item=iter.next();
      }
    }
    if (function.methods.size() == 1 && function.methods.contains(HTTPMethod.HEAD)) {
      if (resp == null || item != null)       function.error(HEAD_METHOD);
    }
    final SerializerProp sp=process(resp);
    http.initResponse(sp);
    final Serializer ser=Serializer.get(http.res.getOutputStream(),sp);
    for (; item != null; item=iter.next())     ser.serialize(item);
    ser.close();
  }
 catch (  final QueryException ex) {
    final QNm name=ex.qname();
    if (name.eq(Q_REDIRECT)) {
      redirect=ex.getLocalizedMessage();
    }
 else     if (name.eq(Q_FORWARD)) {
      forward=ex.getLocalizedMessage();
    }
 else {
      throw ex;
    }
  }
 finally {
    qc.close();
    qc.context.unregister(qc);
    if (redirect != null) {
      http.res.sendRedirect(redirect);
    }
 else     if (forward != null) {
      http.req.getRequestDispatcher(forward).forward(http.req,http.res);
    }
  }
}
