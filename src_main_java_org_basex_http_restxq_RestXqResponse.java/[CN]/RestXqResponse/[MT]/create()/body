{
  final StaticUserFunc uf=function.function;
  final Expr[] args=new Expr[uf.args.length];
  function.bind(http,args);
  final MainModule mod=new MainModule(new BaseFuncCall(null,uf.name,args).init(uf),new VarScope());
  String redirect=null;
  String forward=null;
  try {
    qc.updating=mod.expr.uses(Use.UPD);
    qc.context(http,null);
    qc.context.register(qc);
    final StringList o=qc.dbOptions;
    for (int s=0; s < o.size(); s+=2)     qc.context.prop.set(o.get(s),o.get(s + 1));
    mod.compile(qc);
    Value result=mod.value(qc);
    final Value update=qc.update();
    if (update != null)     result=update;
    final ValueIter iter=result.iter();
    Item item=iter.next();
    ANode resp=null;
    if (item != null && item.type.isNode()) {
      final ANode node=(ANode)item;
      if (RESTXQ_REDIRECT.eq(node)) {
        final ANode ch=node.children().next();
        if (ch == null || ch.type != NodeType.TXT)         function.error(NO_VALUE,node.name());
        redirect=string(trim(ch.string()));
        return;
      }
      if (RESTXQ_FORWARD.eq(node)) {
        final ANode ch=node.children().next();
        if (ch == null || ch.type != NodeType.TXT)         function.error(NO_VALUE,node.name());
        forward=string(trim(ch.string()));
        return;
      }
      if (RESTXQ_RESPONSE.eq(node)) {
        resp=node;
        item=iter.next();
      }
    }
    if (function.methods.size() == 1 && function.methods.contains(HTTPMethod.HEAD)) {
      if (resp == null || item != null)       function.error(HEAD_METHOD);
    }
    final SerializerProp sp=process(resp);
    http.initResponse(sp);
    final Serializer ser=Serializer.get(http.res.getOutputStream(),sp);
    for (; item != null; item=iter.next())     ser.serialize(item);
    ser.close();
  }
  finally {
    qc.close();
    qc.context.unregister(qc);
    if (redirect != null) {
      http.res.sendRedirect(redirect);
    }
 else     if (forward != null) {
      http.req.getRequestDispatcher(forward).forward(http.req,http.res);
    }
  }
}
