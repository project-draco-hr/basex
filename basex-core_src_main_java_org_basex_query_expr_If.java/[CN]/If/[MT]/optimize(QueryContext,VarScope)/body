{
  if (cond.isValue())   return optPre(eval(ctx),ctx);
  if (expr[0].sameAs(expr[1]))   return optPre(expr[0],ctx);
  if (cond.isFunction(Function.NOT)) {
    ctx.compInfo(OPTWRITE,this);
    cond=((Arr)cond).expr[0];
    final Expr tmp=expr[0];
    expr[0]=expr[1];
    expr[1]=tmp;
  }
  if (expr[0].type().eq(SeqType.BLN) && expr[1].type().eq(SeqType.BLN)) {
    final Expr a=cond, b=expr[0], c=expr[1];
    if (b == Bln.TRUE) {
      if (c == Bln.FALSE) {
        ctx.compInfo(OPTPRE,this);
        return compBln(a,info);
      }
      ctx.compInfo(OPTWRITE,this);
      return new Or(info,a,c).optimize(ctx,scp);
    }
    if (c == Bln.TRUE) {
      if (b == Bln.FALSE) {
        ctx.compInfo(OPTPRE,this);
        return Function.NOT.get(null,a).optimize(ctx,scp);
      }
      ctx.compInfo(OPTWRITE,this);
      final Expr notA=Function.NOT.get(null,a).optimize(ctx,scp);
      return new Or(info,notA,b).optimize(ctx,scp);
    }
    if (b == Bln.FALSE) {
      ctx.compInfo(OPTWRITE,this);
      final Expr notA=Function.NOT.get(null,a).optimize(ctx,scp);
      return new And(info,notA,c).optimize(ctx,scp);
    }
    if (c == Bln.FALSE) {
      ctx.compInfo(OPTWRITE,this);
      return new And(info,a,b).optimize(ctx,scp);
    }
  }
  type=expr[0].type().union(expr[1].type());
  return this;
}
