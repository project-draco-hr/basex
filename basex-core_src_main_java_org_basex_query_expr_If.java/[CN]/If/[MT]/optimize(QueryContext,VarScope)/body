{
  cond=cond.optimizeEbv(qc,scp);
  if (cond.isValue())   return optPre(exprs[branch(qc)],qc);
  if (exprs[0].sameAs(exprs[1]))   return optPre(exprs[0],qc);
  if (cond.isFunction(Function.NOT)) {
    qc.compInfo(OPTREWRITE_X,this);
    cond=((Arr)cond).exprs[0];
    final Expr tmp=exprs[0];
    exprs[0]=exprs[1];
    exprs[1]=tmp;
  }
  if (exprs[0].seqType().eq(SeqType.BLN) && exprs[1].seqType().eq(SeqType.BLN)) {
    final Expr a=cond, b=exprs[0], c=exprs[1];
    if (b == Bln.TRUE) {
      if (c == Bln.FALSE) {
        qc.compInfo(OPTPRE_X,this);
        return compBln(a,info,scp.sc);
      }
      qc.compInfo(OPTREWRITE_X,this);
      return new Or(info,a,c).optimize(qc,scp);
    }
    if (c == Bln.TRUE) {
      if (b == Bln.FALSE) {
        qc.compInfo(OPTPRE_X,this);
        return Function.NOT.get(scp.sc,info,a).optimize(qc,scp);
      }
      qc.compInfo(OPTREWRITE_X,this);
      final Expr notA=Function.NOT.get(scp.sc,info,a).optimize(qc,scp);
      return new Or(info,notA,b).optimize(qc,scp);
    }
    if (b == Bln.FALSE) {
      qc.compInfo(OPTREWRITE_X,this);
      final Expr notA=Function.NOT.get(scp.sc,info,a).optimize(qc,scp);
      return new And(info,notA,c).optimize(qc,scp);
    }
    if (c == Bln.FALSE) {
      qc.compInfo(OPTREWRITE_X,this);
      return new And(info,a,b).optimize(qc,scp);
    }
  }
  seqType=exprs[0].seqType().union(exprs[1].seqType());
  return this;
}
