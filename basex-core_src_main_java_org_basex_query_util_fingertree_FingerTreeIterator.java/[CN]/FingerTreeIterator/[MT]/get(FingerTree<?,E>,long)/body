{
  if (tree.isEmpty())   return Collections.emptyListIterator();
  if (tree instanceof Single)   return get(tree.head(),start);
  final Deep<?,E> root=(Deep<?,E>)tree;
  final long n=root.size;
  final long index=Math.max(0,Math.min(start,n));
  @SuppressWarnings("unchecked") Deep<?,E>[] trees=new Deep[8];
  trees[0]=root;
  int tTop=0;
  int deepPos;
  Node<?,E> node;
  long pos=Math.min(index,n - 1);
  for (; ; ) {
    final Deep<?,E> curr=trees[tTop];
    if (pos < curr.leftSize) {
      final Node<?,E>[] left=curr.left;
      int i=0;
      for (; ; i++) {
        node=left[i];
        final long sz=node.size();
        if (pos < sz)         break;
        pos-=sz;
      }
      deepPos=i - left.length;
      break;
    }
    pos-=curr.leftSize;
    final FingerTree<?,E> mid=curr.middle;
    final long midSize=mid.size();
    if (pos >= midSize) {
      pos-=midSize;
      final Node<?,E>[] right=curr.right;
      int i=0;
      for (; ; i++) {
        node=right[i];
        final long sz=node.size();
        if (pos < sz)         break;
        pos-=sz;
      }
      deepPos=i + 1;
      break;
    }
    if (mid instanceof Single) {
      node=mid.head();
      deepPos=0;
      break;
    }
    if (++tTop == trees.length)     trees=Arrays.copyOf(trees,2 * tTop);
    trees[tTop]=(Deep<?,E>)mid;
  }
  return new FingerTreeIterator<>(n,index,trees,tTop,deepPos,node,pos);
}
