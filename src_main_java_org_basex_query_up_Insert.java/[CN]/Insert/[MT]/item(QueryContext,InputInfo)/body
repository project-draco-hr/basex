{
  final Constr c=new Constr(ctx,expr[1]);
  final NodIter cList=c.children;
  final NodIter aList=c.ats;
  if (c.errAtt)   Err.or(input,UPNOATTRPER);
  if (c.duplAtt != null)   Err.or(input,UPATTDUPL,c.duplAtt);
  final Iter t=ctx.iter(expr[0]);
  final Item i=t.next();
  if (i == null)   Err.or(input,UPSEQEMP,Util.name(this));
  if (!(i instanceof Nod) || t.next() != null)   Err.or(input,before || after ? UPTRGTYP2 : UPTRGTYP);
  final Nod n=(Nod)i;
  final Nod par=n.parent();
  if (before || after) {
    if (n.type == Type.ATT || n.type == Type.DOC)     Err.or(input,UPTRGTYP2);
    if (par == null)     Err.or(input,UPPAREMPTY);
  }
 else {
    if (n.type != Type.ELM && n.type != Type.DOC)     Err.or(input,UPTRGTYP);
  }
  UpdatePrimitive up=null;
  if (aList.size() > 0) {
    final Nod targ=before || after ? par : n;
    if (targ.type != Type.ELM)     Err.or(input,before || after ? UPATTELM : UPATTELM2);
    up=new InsertAttribute(input,targ,checkNS(aList,targ,ctx));
    ctx.updates.add(up,ctx);
  }
  if (cList.size() > 0) {
    if (before) {
      up=new InsertBefore(input,n,cList);
    }
 else     if (after) {
      up=new InsertAfter(input,n,cList);
    }
 else     if (first) {
      up=new InsertIntoFirst(input,n,cList);
    }
 else {
      up=new InsertInto(input,n,cList,last);
    }
    ctx.updates.add(up,ctx);
  }
  return null;
}
