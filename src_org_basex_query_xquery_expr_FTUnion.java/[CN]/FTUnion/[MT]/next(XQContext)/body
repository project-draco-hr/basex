{
  boolean b=false;
  if (cp.size > 0) {
    for (int i=0; i < cp.size; i++) {
      mp[pex[cp.list[i]]]=(FTNodeItem)ctx.iter(expr[pex[cp.list[i]]]).next();
      if (!b)       b=mp[i].ftn.size > 0;
    }
    cp.reset();
  }
  if (!b) {
    for (    final FTNodeItem c : mp)     if (c.ftn.size > 0)     break;
  }
  if (minp == -1) {
    minp=0;
    while (minp < mp.length && mp[minp].ftn.size == 0)     minp++;
    if (minp < mp.length)     cp.set(minp,0);
    for (int ip=minp + 1; ip < pex.length; ip++) {
      if (mp[ip].ftn.size > 0) {
        final FTNodeItem n1=mp[pex[ip]];
        final FTNodeItem n2=mp[pex[minp]];
        if (n1.ftn.getPre() < n2.ftn.getPre()) {
          minp=ip;
          cp.set(ip,0);
        }
 else         if (n1.ftn.getPre() == n2.ftn.getPre()) {
          cp.add(ip);
        }
      }
    }
  }
  minp=-1;
  final FTNodeItem m=mp[pex[cp.list[0]]];
  for (int i=1; i < cp.size; i++) {
    m.merge(mp[pex[cp.list[i]]],0);
    m.ftn.not=false;
  }
  if (m.ftn.size == 0)   m.ftn.not=not;
  return m;
}
