{
  final int k=Nod.kind(nd.type);
  final int ms=m.meta.size;
switch (k) {
case Data.DOC:
    m.doc(ms,size(nd,false),nd.base());
  m.insert(ms);
int p=pre + 1;
NodeIter ir=nd.child();
Nod i;
while ((i=ir.next()) != null) p=addNode(null,i,m,p,pre,nsPreserve,nsInherit);
return p;
case Data.ATTR:
QNm q=nd.qname();
byte[] uri=q.uri().atom();
int u=0;
boolean ne=uri.length != 0;
if (ne) {
if (par == 0) m.ns.add(ms,pre - par,q.pref(),uri);
u=m.ns.addURI(uri);
}
final int n=m.atts.index(q.atom(),null,false);
m.attr(ms,pre - par,n,nd.atom(),u,ne);
m.insert(ms);
return pre + 1;
case Data.PI:
case Data.TEXT:
case Data.COMM:
byte[] v=nd.atom();
if (k == Data.PI) v=trim(concat(nd.nname(),SPACE,v));
m.text(ms,pre - par,v,k);
m.insert(ms);
return pre + 1;
default :
q=nd.qname();
m.ns.open();
ne=false;
Atts ns=null;
if (!nsPreserve) {
ns=nd.ns();
final Atts ns2=nd.nsScope();
int uid;
if ((uid=ns2.get(EMPTY)) != -1) ns.add(ns2.key[uid],ns2.val[uid]);
}
 else {
ns=par == 0 ? nd.nsScope() : nd.ns();
}
if (ns != null) {
if (ns.size > 0 && ndPar != null && nsPreserve) {
final Atts nsPar=ndPar.nsScope();
for (int j=0; j < nsPar.size; ++j) {
final byte[] key=nsPar.key[j];
final int ki=ns.get(key);
if (ki > -1 && eq(nsPar.val[j],ns.val[ki])) ns.delete(ki);
}
}
ne=ns.size > 0;
}
for (int a=0; ne && a < ns.size; ++a) {
m.ns.add(ns.key[a],ns.val[a],ms);
}
uri=q.uri().atom();
u=uri.length != 0 ? m.ns.addURI(uri) : 0;
final int tn=m.tags.index(q.atom(),null,false);
m.elem(0,pre - par,tn,size(nd,true),size(nd,false),u,ne);
m.insert(ms);
ir=nd.attr();
p=pre + 1;
while ((i=ir.next()) != null) p=addNode(nd,i,m,p,pre,nsPreserve,nsInherit);
ir=nd.child();
while ((i=ir.next()) != null) p=addNode(nd,i,m,p,pre,nsPreserve,nsInherit);
m.ns.close(ms);
return p;
}
}
