{
  final Constr c=new Constr(ctx,expr[1]);
  final NodIter seq=c.children;
  final NodIter aSeq=c.ats;
  if (c.errAtt)   Err.or(UPNOATTRPER);
  if (c.duplAtt != null)   Err.or(UPATTDUPL,c.duplAtt);
  final Iter t=SeqIter.get(expr[0].iter(ctx));
  Item i=t.next();
  if (i == null)   Err.or(UPSEQEMP,this);
  if (!(i instanceof Nod) || t.size() > 1)   Err.or(before || after ? UPTRGTYP2 : UPTRGTYP,this);
  final Nod n=(Nod)i;
  final Nod par=n.parent();
  if (before || after) {
    if (n.type == Type.ATT || n.type == Type.DOC)     Err.or(UPTRGTYP2,this);
    if (par == null)     Err.or(UPPAREMPTY,this);
  }
 else {
    if (n.type != Type.ELM && n.type != Type.DOC)     Err.or(UPTRGTYP,this);
  }
  UpdatePrimitive up=null;
  if (aSeq.size() > 0) {
    if (before || after) {
      if (par.type != Type.ELM)       Err.or(UPATTDOC,this);
      up=new InsertAttribute(par,aSeq,-1);
    }
 else {
      if (n.type != Type.ELM)       Err.or(UPWRTRGTYP2,this);
      up=new InsertAttribute(n,aSeq,-1);
    }
    ctx.updates.add(up);
  }
  if (seq.size() > 0) {
    if (before) {
      up=new InsertBefore(n,seq,-1);
    }
 else     if (after) {
      up=new InsertAfter(n,seq,-1);
    }
 else {
      if (first)       up=new InsertIntoFirst(n,seq,-1);
 else       if (last)       up=new InsertIntoLast(n,seq,-1);
 else       up=new InsertInto(n,seq,-1);
    }
    ctx.updates.add(up);
  }
  return Iter.EMPTY;
}
