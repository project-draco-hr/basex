{
  int j=pointerEnding;
  int i=pointerNode;
  boolean last=lastFound;
  final byte[] curNodeEntry=getNodeEntry(node);
  final int[] curDataEntry=getDataEntry(node);
  if (ending == null || ending.length == 0) {
    astericsWildCardData=CTArrayX.ftOR(astericsWildCardData,getDataFromDataArray(curNodeEntry,curDataEntry));
    final int[] nextNodes=getNextNodes(curNodeEntry);
    if (nextNodes != null) {
      for (      final int n : nextNodes) {
        astericsWildCardTraversing(n,null,last,0,0);
      }
    }
    return;
  }
  if (curNodeEntry != null) {
    while (!last && i < curNodeEntry[0] + 1 && curNodeEntry[i] != ending[j]) {
      i++;
    }
    while (i + ending.length < curNodeEntry[0] + 1 && curNodeEntry[i + 1] == ending[0]) {
      i++;
    }
    countSkippedChars=countSkippedChars + i - pointerNode - 1;
    while (i < curNodeEntry[0] + 1 && j < ending.length && curNodeEntry[i] == ending[j]) {
      i++;
      j++;
      if (!last) {
        last=true;
      }
    }
  }
 else {
    countSkippedChars=0;
    return;
  }
  if (node == 0 || j == ending.length && i < curNodeEntry[0] + 1) {
    if (curNodeEntry[curNodeEntry[0] + 1] > 0) {
      countSkippedChars=0;
      return;
    }
    final int[] nextNodes=getNextNodes(curNodeEntry);
    for (    final int n : nextNodes) {
      astericsWildCardTraversing(n,ending,false,1,0);
    }
    countSkippedChars=0;
    return;
  }
 else   if (j == ending.length && i == curNodeEntry[0] + 1) {
    final int[][] d=getDataFromDataArray(curNodeEntry,curDataEntry);
    if (d != null) {
      astericsWildCardData=CTArrayX.ftOR(astericsWildCardData,d);
    }
    countSkippedChars=0;
    final int[] nextNodes=getNextNodes(curNodeEntry);
    if (nextNodes != null) {
      for (      final int n : nextNodes) {
        if (j == 1) {
          astericsWildCardTraversing(n,ending,false,0,0);
        }
        astericsWildCardTraversing(n,ending,last,0,j);
      }
    }
    return;
  }
 else   if (j < ending.length && i < curNodeEntry[0] + 1) {
    if (curNodeEntry[curNodeEntry[0] + 1] > 0) {
      countSkippedChars=0;
      return;
    }
    astericsWildCardTraversing(node,ending,false,i + 1,0);
    return;
  }
 else   if (j < ending.length && i == curNodeEntry[0] + 1) {
    if (curNodeEntry[curNodeEntry[0] + 1] > 0) {
      countSkippedChars=0;
      return;
    }
    final int[] nextNodes=getNextNodes(curNodeEntry);
    for (    final int n : nextNodes) {
      if (j == 1) {
        astericsWildCardTraversing(n,ending,last,1,0);
      }
      astericsWildCardTraversing(n,ending,last,1,j);
    }
  }
}
