{
  if (res == null || res[0] == null || res[0].length == 0 || p == null) {
    return new int[][]{};
  }
  final int[][] maxRes=new int[2][res[0].length * 2];
  int c=0;
  int level=0;
  int j=0;
  int lid;
  IntList stack=new IntList();
  boolean f=true;
  boolean h=false;
  int e;
  int s=0;
  int i=0;
  int pold;
  int[] startEndPos=new int[2];
  byte[] dataFromDB;
  while (j < res[0].length) {
    lid=res[0][j];
    s=j;
    pold=p[s + 1];
    while (j < res[0].length && res[0][j] == lid && p[j + 1] == pold) {
      j++;
    }
    e=j;
    i=s;
    while (j < res[0].length && res[0][j] == lid) {
      dataFromDB=dat.text(res[0][i]);
      while (i < e) {
        startEndPos=getSEPositions(dataFromDB,res[1][i],true,FTUnit.WORDS);
        if (ftpos.pos.same) {
          while (j < res[1].length - 1 && res[1][j] < startEndPos[0])           j++;
          if (startEndPos[0] <= res[1][j] && startEndPos[1] >= res[1][j]) {
            h=true;
          }
        }
 else         if (ftpos.pos.different) {
          if (startEndPos[0] > res[1][j] || startEndPos[1] < res[1][j]) {
            h=true;
          }
        }
        if (h) {
          stack.add(i);
          stack.add(j);
          if (f) {
            level++;
            f=false;
          }
          h=false;
          if (j < res[0].length - 1 && pold == p[j + 1])           j++;
        }
        i++;
      }
      if (level == p[0]) {
        for (int k=0; k < stack.size; k++) {
          maxRes[0][c]=res[0][stack.get(k)];
          maxRes[1][c++]=res[1][stack.get(k)];
        }
        j++;
        while ((j < res[0].length && res[0][j] == lid && p[j + 1] == p[stack.get(stack.size - 1) + 1]) && ((ftpos.pos.same && startEndPos[0] <= res[1][j] && startEndPos[1] >= res[1][j]) || (ftpos.pos.different && startEndPos[0] > res[1][j] && startEndPos[1] < res[1][j]))) {
          maxRes[0][c]=res[0][j];
          maxRes[1][c++]=res[1][j++];
        }
        j--;
        level=0;
        stack=new IntList();
        f=true;
      }
      j++;
      if (j >= res[0].length)       break;
      if (p[j] != p[j + 1] && p[j] != p[0]) {
        e=j;
        lid=res[0][s];
        f=true;
      }
    }
    level=0;
    stack=new IntList();
    f=true;
  }
  final int[][] ret=new int[2][c];
  System.arraycopy(maxRes[0],0,ret[0],0,c);
  System.arraycopy(maxRes[1],0,ret[1],0,c);
  return ret;
}
