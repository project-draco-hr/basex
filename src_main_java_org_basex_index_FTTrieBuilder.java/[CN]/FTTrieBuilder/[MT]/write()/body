{
  if (!merge) {
    writeCompleteTrie();
    return;
  }
  writeSortedList(csize++);
  final DataOutput outb=new DataOutput(data.meta.file(DATAFTX + 'b'));
  final DataOutput outt=new DataOutput(data.meta.file(DATAFTX + 't'));
  final IntList root=new IntList();
  final byte[][] tok=new byte[csize][];
  final int[][] prs=new int[csize][];
  final int[][] pos=new int[csize][];
  final FTSortedList[] v=new FTSortedList[csize];
  for (int b=0; b < csize; b++) {
    v[b]=new FTSortedList(data,b);
    tok[b]=v[b].nextTok();
    prs[b]=v[b].nextPreValues();
    pos[b]=v[b].nextPosValues();
  }
  int min;
  final IntList mer=new IntList();
  while (check(tok)) {
    min=0;
    mer.reset();
    mer.add(min);
    for (int i=0; i < csize; i++) {
      if (min == i || tok[i].length == 0)       continue;
      final int d=diff(tok[min],tok[i]);
      if (d > 0 || tok[min].length == 0) {
        min=i;
        mer.reset();
        mer.add(min);
      }
 else       if (d == 0 && tok[i].length > 0) {
        mer.add(i);
      }
    }
    if (root.size() == 0 || root.get(root.size() - 1) != tok[min][0])     root.add(tok[min][0]);
    outt.write(tok[min].length);
    outt.write(tok[min]);
    int s=0;
    final TokenBuilder tbp=new TokenBuilder();
    final TokenBuilder tbo=new TokenBuilder();
    tbp.add(new byte[4]);
    tbo.add(new byte[4]);
    for (int j=0; j < mer.size(); j++) {
      final int m=mer.get(j);
      for (      final int p : prs[m])       tbp.add(Num.num(p));
      for (      final int p : pos[m])       tbo.add(Num.num(p));
      s+=v[m].nextFTDataSize();
      tok[m]=nextToken(v,m);
      prs[m]=tok[m].length > 0 ? v[m].nextPreValues() : new int[0];
      pos[m]=tok[m].length > 0 ? v[m].nextPosValues() : new int[0];
    }
    outt.writeInt(s);
    outt.write5(outb.size());
    final byte[] pr=tbp.finish();
    Num.size(pr,pr.length);
    final byte[] po=tbo.finish();
    Num.size(po,po.length);
    writeFTData(outb,pr,po);
  }
  outt.write(0);
  outt.close();
  outb.close();
  writeSplitTrie(root);
}
