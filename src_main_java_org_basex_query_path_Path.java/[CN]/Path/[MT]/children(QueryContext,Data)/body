{
  for (int s=0; s < steps.length; ++s) {
    final AxisStep prev=s > 0 ? axisStep(s - 1) : null;
    if (prev != null && prev.preds.length != 0)     break;
    final AxisStep curr=axisStep(s);
    if (curr == null || curr.axis != Axis.DESC || curr.uses(Use.POS))     continue;
    ObjList<PathNode> nodes=pathNodes(data,s);
    if (nodes == null)     continue;
    ctx.compInfo(OPTCHILD,steps[s]);
    final TokenList tl=new TokenList();
    while (nodes.get(0).par != null) {
      byte[] tag=data.tagindex.key(nodes.get(0).name);
      for (int j=0; j < nodes.size(); ++j) {
        if (nodes.get(0).name != nodes.get(j).name)         tag=null;
      }
      tl.add(tag);
      nodes=data.pthindex.parent(nodes);
    }
    int ts=tl.size();
    final Expr[] stps=new Expr[ts + steps.length - s - 1];
    for (int t=0; t < ts; ++t) {
      final Expr[] preds=t == ts - 1 ? ((AxisStep)steps[s]).preds : new Expr[0];
      final byte[] n=tl.get(ts - t - 1);
      final NameTest nt=n == null ? new NameTest(false,input) : new NameTest(new QNm(n),Name.NAME,false,input);
      stps[t]=AxisStep.get(input,Axis.CHILD,nt,preds);
    }
    while (++s < steps.length)     stps[ts++]=steps[s];
    return get(input,root,stps);
  }
  return this;
}
