{
  if (!data.meta.pathindex || !data.meta.uptodate || data.nspaces.globalNS() == null)   return this;
  Path path=this;
  for (int s=0; s < steps.length; ++s) {
    final AxisStep prev=s > 0 ? axisStep(s - 1) : null;
    if (prev != null && prev.preds.length != 0)     break;
    final AxisStep curr=axisStep(s);
    if (curr == null || curr.axis != DESC || curr.uses(Use.POS))     continue;
    ObjList<PathNode> pn=pathNodes(data,s);
    if (pn == null)     continue;
    final ObjList<QNm> qnm=new ObjList<QNm>();
    while (pn.get(0).par != null) {
      QNm nm=new QNm(data.tagindex.key(pn.get(0).name));
      if (nm.hasPrefix())       return this;
      for (int j=0; j < pn.size(); ++j) {
        if (pn.get(0).name != pn.get(j).name)         nm=null;
      }
      qnm.add(nm);
      pn=PathSummary.parent(pn);
    }
    ctx.compInfo(OPTCHILD,steps[s]);
    int ts=qnm.size();
    final Expr[] stps=new Expr[ts + steps.length - s - 1];
    for (int t=0; t < ts; ++t) {
      final Expr[] preds=t == ts - 1 ? ((AxisStep)steps[s]).preds : new Expr[0];
      final QNm nm=qnm.get(ts - t - 1);
      final NameTest nt=nm == null ? new NameTest(false) : new NameTest(nm,Name.NAME,false);
      stps[t]=AxisStep.get(input,CHILD,nt,preds);
    }
    while (++s < steps.length)     stps[ts++]=steps[s];
    path=get(input,root,stps);
    break;
  }
  if (data.nspaces.size() == 0) {
    LOOP:     for (int s=0; s < path.steps.length; ++s) {
      final AxisStep st=path.axisStep(s);
      if (st == null || st.axis != CHILD)       break;
      if (st.test.test == Name.ALL || st.test.test == null)       continue;
      if (st.test.test != Name.NAME)       break;
      final int name=data.tagindex.id(st.test.name.local());
      for (      final PathNode pn : data.paths.desc(name,Data.ELEM)) {
        if (pn.level() == s + 1)         continue LOOP;
      }
      ctx.compInfo(OPTPATH,path);
      return Empty.SEQ;
    }
  }
  return path;
}
