{
  boolean opt=false;
  Expr[] step=steps;
  for (int l=1; l < step.length; ++l) {
    if (!(step[l - 1] instanceof AxisStep && step[l] instanceof AxisStep))     continue;
    final AxisStep last=(AxisStep)step[l - 1];
    final AxisStep curr=(AxisStep)step[l];
    if (!last.simple(DESCORSELF,false))     continue;
    if (curr.axis == CHILD && !curr.uses(Use.POS)) {
      Array.move(step,l,-1,step.length - l);
      step=Arrays.copyOf(step,step.length - 1);
      curr.axis=DESC;
      opt=true;
    }
 else     if (curr.axis == ATTR && !curr.uses(Use.POS)) {
      last.test=new NameTest(false,last.input);
      opt=true;
    }
  }
  if (opt)   ctx.compInfo(OPTDESC);
  if (root == null && step.length == 1 && step[0] instanceof AxisPath) {
    final AxisStep curr=(AxisStep)step[0];
    if (curr.axis == ATTR && curr.test.test == Name.STD)     curr.type=SeqType.NOD_ZO;
  }
  return step;
}
