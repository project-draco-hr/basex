{
  final String f=text ? DATATXT : DATAATV;
  final DataOutput outl=new DataOutput(data.meta.file(f + 'l'));
  final DataOutput outr=new DataOutput(data.meta.file(f + 'r'));
  outl.writeInt(0);
  final ValueMerge[] mv=new ValueMerge[cf];
  for (int i=0; i < cf; i++)   mv[i]=new ValueMerge(data,text,i);
  int min;
  int sz=0;
  final IntList merge=new IntList();
  while (check(mv)) {
    sz++;
    outr.write5(outl.size());
    min=0;
    merge.reset();
    for (int i=0; i < cf; i++) {
      if (min == i || mv[i].t.length == 0)       continue;
      final int d=diff(mv[min].t,mv[i].t);
      if (d > 0 || mv[min].t.length == 0) {
        min=i;
        merge.reset();
      }
 else       if (d == 0 && mv[i].t.length > 0) {
        if (merge.size() == 0)         merge.add(min);
        merge.add(i);
      }
    }
    if (merge.size() == 0) {
      writeWithNum(outl,mv[min].p);
      mv[min].next();
    }
 else {
      final TokenBuilder tb=new TokenBuilder();
      tb.add(new byte[4]);
      int npre=0;
      int opre=0;
      for (int j=0; j < merge.size(); j++) {
        final int m=merge.get(j);
        if (j == 0) {
          int l=4;
          while (l < mv[m].p.length) {
            final int diff=Num.read(mv[m].p,l);
            opre+=diff;
            l+=Num.len(diff);
          }
          tb.add(substring(mv[m].p,4));
        }
 else {
          npre=Num.read(mv[m].p,4);
          tb.add(Num.num(npre - opre));
          int l=4 + Num.len(npre);
          tb.add(substring(mv[m].p,l));
          opre=npre;
          while (l < mv[m].p.length) {
            final int diff=Num.read(mv[m].p,l);
            opre+=diff;
            l+=Num.len(diff);
          }
        }
        mv[m].next();
      }
      final byte[] tmp=tb.finish();
      Num.size(tmp,tmp.length);
      writeWithNum(outl,tmp);
    }
  }
  outr.close();
  outl.close();
  return sz;
}
