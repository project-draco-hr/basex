{
  cache(http);
  final ArrayList<RestXqFunction> list=new ArrayList<>();
  for (  final RestXqModule mod : modules.values()) {
    for (    final RestXqFunction rxf : mod.functions()) {
      if (rxf.matches(http,error))       list.add(rxf);
    }
  }
  if (list.isEmpty())   return null;
  Collections.sort(list);
  RestXqFunction best=list.get(0);
  if (list.size() == 1 || best.compareTo(list.get(1)) != 0)   return best;
  final HTTPAccept[] accepts=http.accepts();
  double qf=0;
  for (  final RestXqFunction rxf : list) {
    if (best.compareTo(rxf) != 0)     break;
    for (    final String p : rxf.produces) {
      for (      final HTTPAccept accept : accepts) {
        final double nqf=accept.qf;
        if (MimeTypes.matches(p,accept.type) && nqf > 0) {
          if (qf < nqf) {
            qf=nqf;
            best=rxf;
          }
 else           if (qf == nqf) {
            qf=-1;
            break;
          }
        }
      }
    }
  }
  if (qf > 0)   return best;
  final TokenBuilder tb=new TokenBuilder();
  for (  final RestXqFunction rxf : list) {
    if (best.compareTo(rxf) != 0)     break;
    tb.add(Prop.NL).add(rxf.function.info.toString());
  }
  throw best.path == null ? best.error(ERROR_CONFLICT,error,tb) : best.error(PATH_CONFLICT,best.path,tb);
}
