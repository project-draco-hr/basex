{
  super.compile(ctx,scp);
  func.compile(ctx,scp);
  if (!func.uses(Use.NDT)) {
    final boolean val=func.expr.isValue() && allAreValues();
    if (val || !func.uses(Use.CTX) && !func.selfRecursive()) {
      ctx.compInfo(OPTINLINE,func.name.string());
      if (val) {
        for (int i=0; i < expr.length; i++)         func.args[i].checkType((Value)expr[i],ctx,info);
        final Value v=func.expr.value(ctx);
        return func.cast ? func.type.funcConvert(ctx,info,v) : v;
      }
      final LinkedList<GFLWOR.Clause> cls=expr.length == 0 ? null : new LinkedList<GFLWOR.Clause>();
      final IntMap<Var> vs=new IntMap<Var>();
      for (int i=0; i < func.args.length; i++) {
        final Var old=func.args[i], v=scp.newCopyOf(ctx,old);
        vs.add(old.id,v);
        cls.add(new Let(v,expr[i],false,func.info).optimize(ctx,scp));
      }
      final Expr cpy=func.expr.copy(ctx,scp,vs), rt=!func.cast ? cpy : new TypeCheck(func.info,cpy,func.ret,true).optimize(ctx,scp);
      return cls == null ? rt : new GFLWOR(func.info,cls,rt).optimize(ctx,scp);
    }
  }
  type=func.type();
  return this;
}
