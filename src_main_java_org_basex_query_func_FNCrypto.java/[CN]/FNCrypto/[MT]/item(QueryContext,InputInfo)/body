{
switch (def) {
case CRYPHMAC:
    return new Encryption(ii).hmac(checkStr(expr[0],ctx),checkStr(expr[1],ctx),checkStr(expr[2],ctx),expr.length == 4 ? checkStr(expr[3],ctx) : null);
case CRYPENCRYPT:
  return new Encryption(ii).encryption(checkStr(expr[0],ctx),checkStr(expr[1],ctx),checkStr(expr[2],ctx),checkStr(expr[3],ctx),true);
case CRYPDECRYPT:
return new Encryption(ii).encryption(checkStr(expr[0],ctx),checkStr(expr[1],ctx),checkStr(expr[2],ctx),checkStr(expr[3],ctx),false);
case CRYPGENSIG:
Item arg6=null;
boolean arg6Str=false;
if (expr.length > 6) {
arg6=checkItem(expr[6],ctx);
if (arg6 instanceof Str) arg6Str=true;
 else if (arg6 instanceof ANode) ;
 else Err.type(this,AtomType.STR,arg6);
}
return new DigitalSignature(ii).generateSignature(checkNode(expr[0].item(ctx,ii)),checkStr(expr[1],ctx),checkStr(expr[2],ctx),checkStr(expr[3],ctx),checkStr(expr[4],ctx),checkStr(expr[5],ctx),arg6Str ? arg6.atom(ii) : Token.token(""),expr.length > 7 ? checkNode(expr[7].item(ctx,ii)) : expr.length == 7 && !arg6Str ? checkNode(expr[6].item(ctx,ii)) : null);
case CRYPVALSIG:
return new DigitalSignature(ii).validateSignature(checkNode(expr[0].item(ctx,ii)));
default :
return super.item(ctx,ii);
}
}
