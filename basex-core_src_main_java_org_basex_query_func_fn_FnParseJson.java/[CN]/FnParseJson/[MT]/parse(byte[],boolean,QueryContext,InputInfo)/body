{
  final JsonParserOptions opts=new JsonParserOptions();
  if (exprs.length > 1) {
    final Map options=toMap(exprs[1],qc);
    try {
      new FuncOptions(null,info).acceptUnknown().parse(options,opts);
    }
 catch (    final QueryException ex) {
      throw JSON_OPT_X.get(ii,ex.getLocalizedMessage());
    }
  }
  final boolean esc=opts.get(JsonParserOptions.ESCAPE);
  final FuncItem fb=opts.get(JsonParserOptions.FALLBACK);
  final FItem fallback;
  if (fb == null) {
    fallback=null;
  }
 else {
    try {
      fallback=STRFUNC.cast(fb,qc,sc,ii);
    }
 catch (    final QueryException ex) {
      throw JSON_OPT_X.get(ii,ex.getLocalizedMessage());
    }
  }
  try {
    opts.set(JsonOptions.FORMAT,xml ? JsonFormat.BASIC : JsonFormat.MAP);
    final JsonConverter conv=JsonConverter.get(opts);
    if (!esc && fallback != null)     conv.fallback(new JsonFallback(){
      @Override public String convert(      final String string){
        try {
          return Token.string(fallback.invokeItem(qc,ii,Str.get(string)).string(ii));
        }
 catch (        final QueryException ex) {
          throw new QueryRTException(ex);
        }
      }
    }
);
    return conv.convert(json,null);
  }
 catch (  final QueryRTException ex) {
    final QueryException qe=ex.getCause();
    final QueryError err=qe.error();
    if (err != INVPROMOTE_X_X && err != INVPROMOTE_X_X_X)     throw qe;
    Util.debug(ex);
    throw JSON_OPT_X.get(ii,qe.getLocalizedMessage());
  }
catch (  final QueryIOException ex) {
    Util.debug(ex);
    final QueryException qe=ex.getCause(info);
    final QueryError error=qe.error();
    final String message=ex.getLocalizedMessage();
    if (error == BXJS_PARSE_X_X_X)     throw JSON_PARSE_X.get(ii,message);
    if (error == BXJS_DUPLICATE_X)     throw JSON_DUPLICATE_X.get(ii,message);
    if (error == BXJS_INVALID_X)     throw JSON_OPT_X.get(ii,message);
    throw qe;
  }
}
