{
  final JsonParserOptions opts=new JsonParserOptions();
  if (exprs.length > 1) {
    final Map options=toMap(exprs[1],qc);
    try {
      new FuncOptions(null,info).acceptUnknown().parse(options,opts);
    }
 catch (    final QueryException ex) {
      throw JSON_OPT_X.get(ii,ex.getLocalizedMessage());
    }
  }
  final boolean unesc=opts.get(JsonParserOptions.UNESCAPE);
  final FuncItem fb=opts.get(JsonParserOptions.FALLBACK);
  if (fb != null) {
    final Type type=FuncType.get(SeqType.STR,SeqType.STR);
    if (!fb.type.instanceOf(type))     throw JSON_FUNC_OPT_X_X.get(ii,type,fb.type);
  }
  try {
    opts.set(JsonOptions.FORMAT,JsonFormat.MAP);
    final JsonConverter conv=JsonConverter.get(opts);
    if (unesc && fb != null)     conv.fallback(new JsonFallback(){
      @Override public byte[] convert(      final byte[] string){
        try {
          return fb.invokeItem(qc,ii,Str.get(string)).string(ii);
        }
 catch (        final QueryException ex) {
          throw new QueryRTException(ex);
        }
      }
    }
);
    return conv.convert(json,null);
  }
 catch (  final QueryRTException ex) {
    throw ex.getCause();
  }
catch (  final QueryIOException ex) {
    Util.debug(ex);
    final QueryException qe=ex.getCause(info);
    final QueryError error=qe.error();
    final String message=ex.getLocalizedMessage();
    if (error == BXJS_PARSE_X_X_X)     throw JSON_PARSE_X.get(ii,message);
    if (error == BXJS_DUPLICATE_X)     throw JSON_DUPLICATE_X.get(ii,message);
    throw qe;
  }
}
