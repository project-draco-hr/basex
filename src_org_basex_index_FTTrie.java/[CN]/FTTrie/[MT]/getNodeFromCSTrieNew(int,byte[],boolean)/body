{
  byte[] vsn=sn;
  long ldid;
  final int[] ne=getNodeEntry(cn);
  if (cn != 0) {
    int i=0;
    while (i < vsn.length && i < ne[0] && Token.diff((byte)Token.lc(ne[i + 1]),lc(vsn[i])) == 0) {
      i++;
    }
    if (ne[0] == i) {
      if (vsn.length == i) {
        ldid=did;
        return FTFuzzy.getData(ldid,ne[ne.length - 1],inD,data.meta);
      }
 else {
        final byte[] tmp=new byte[vsn.length - i];
        System.arraycopy(vsn,i,tmp,0,tmp.length);
        vsn=tmp;
        final IntList p=getInsPosLinCSFNew(ne,vsn[0],casesen);
        if (!found) {
          if (Token.diff((byte)Token.lc(ne[p.list[0] + 1]),vsn[0]) != 0)           return IndexArrayIterator.EMP;
 else           return getNodeFromCSTrieNew(ne[p.list[0]],vsn,casesen);
        }
 else {
          IndexArrayIterator d=IndexArrayIterator.EMP;
          for (int z=0; z < p.size; z++) {
            d=IndexArrayIterator.merge(getNodeFromCSTrieNew(ne[p.list[z]],vsn,casesen),d);
          }
          return d;
        }
      }
    }
 else {
      return IndexArrayIterator.EMP;
    }
  }
 else {
    final IntList p=getInsPosLinCSFNew(ne,vsn[0],casesen);
    if (!found) {
      if (Token.diff((byte)Token.lc(ne[p.list[0] + 1]),vsn[0]) != 0)       return IndexArrayIterator.EMP;
 else       return getNodeFromCSTrieNew(ne[p.list[0]],vsn,casesen);
    }
 else {
      IndexArrayIterator d=IndexArrayIterator.EMP;
      for (int z=0; z < p.size; z++) {
        d=IndexArrayIterator.merge(getNodeFromCSTrieNew(ne[p.list[z]],vsn,casesen),d);
      }
      return d;
    }
  }
}
