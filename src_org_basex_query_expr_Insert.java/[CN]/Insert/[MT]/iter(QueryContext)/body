{
  final Iter s=SeqIter.get(expr[1].iter(ctx));
  final SeqIter seq=new SeqIter();
  final SeqIter aSeq=new SeqIter();
  Item i=s.next();
  boolean e=false;
  while (i != null) {
    if (i.type.num || i.type.str)     seq.add(new FTxt(i.str(),null));
 else     if (i instanceof Nod) {
      final Nod tn=(Nod)i;
      final int k=Nod.kind(tn.type);
      if (k == Data.ATTR) {
        if (e)         Err.or(UPNOATTRPER,this);
        aSeq.add(tn);
      }
 else {
        e=true;
        if (Nod.kind(tn.type) == Data.DOC)         seq.add(tn.child());
 else         seq.add(tn);
      }
    }
 else     Err.or(UPDATE,this);
    i=s.next();
  }
  seq.reset();
  final boolean into=!(before || after);
  final Iter t=SeqIter.get(expr[0].iter(ctx));
  i=t.next();
  if (i == null)   Err.or(UPSEQEMP,this);
  if (!(i instanceof Nod) || t.size() > 1)   Err.or(UPTRGTYP,this);
  final Nod n=(Nod)i;
  final int k=Nod.kind(n.type);
  if (into && (!(k == Data.ELEM || k == Data.DOC)))   Err.or(UPTRGTYP,this);
  if (before || after) {
    if (k == Data.ATTR)     Err.or(UPTRGTYP2,this);
    if (n.parent() == null)     Err.or(UPPAREMPTY,this);
  }
  final Nod par=n.parent();
  if (aSeq.size() > 0) {
    if (into) {
      if (k == Data.DOC)       Err.or(UPWRTRGTYP2,this);
      ctx.updates.addPrimitive(new InsertAttribute(n,aSeq,-1));
    }
    if (before || after) {
      if (par == null)       Err.or(UPDATE,this);
      if (Nod.kind(par.type) == Data.DOC)       Err.or(UPWRTRGTYP2,this);
      ctx.updates.addPrimitive(new InsertAttribute(par,aSeq,-1));
    }
  }
  if (seq.size() > 0) {
    UpdatePrimitive up=null;
    if (into)     if (first)     up=new InsertIntoFirstPrimitive(n,seq,-1);
 else     if (last)     up=new InsertIntoLastPrimitive(n,seq,-1);
 else     up=new InsertIntoPrimitive(n,seq,-1);
 else     if (before)     up=new InsertBeforePrimitive(n,seq,-1);
 else     if (after)     up=new InsertAfterPrimitive(n,seq,-1);
    ctx.updates.addPrimitive(up);
  }
  return Iter.EMPTY;
}
