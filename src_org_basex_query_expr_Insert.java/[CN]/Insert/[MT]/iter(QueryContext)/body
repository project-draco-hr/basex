{
  final Iter s=SeqIter.get(expr[1].iter(ctx));
  final SeqIter seq=new SeqIter();
  Item i=s.next();
  boolean e=false;
  boolean a=false;
  while (i != null) {
    if (i.type.num || i.type.str)     seq.add(new FTxt(i.str(),null));
 else     if (i instanceof Nod) {
      final Nod tn=(Nod)i;
      final int k=Nod.kind(tn.type);
      if (k == Data.ATTR) {
        if (e)         Err.or(UPNOATTRPER,this);
        a=true;
      }
      if (k != Data.ATTR)       e=true;
      if (Nod.kind(tn.type) == Data.DOC)       seq.add(tn.child());
 else       seq.add(tn);
    }
 else     Err.or(UPDATE,this);
    i=s.next();
  }
  seq.reset();
  final boolean into=!(before || after);
  final Iter t=SeqIter.get(expr[0].iter(ctx));
  i=t.next();
  if (i == null)   Err.or(UPSEQEMP,this);
  if (!(i instanceof Nod) || t.size() > 1)   Err.or(UPTRGTYP,this);
  final Nod n=(Nod)i;
  final int k=Nod.kind(n.type);
  if (into && (!(k == Data.ELEM || k == Data.DOC)))   Err.or(UPTRGTYP,this);
  if (before || after) {
    if (k == Data.ATTR)     Err.or(UPTRGTYP2,this);
    if (n.parent() == null)     Err.or(UPPAREMPTY,this);
  }
  UpdatePrimitive p=null;
  if (into)   p=first ? new InsertIntoFirstPrimitive(n,seq,a) : last ? new InsertIntoLastPrimitive(n,seq,a) : new InsertIntoPrimitive(n,seq,a);
  if (after)   p=new InsertAfterPrimitive(n,seq,a);
  if (before)   p=new InsertBeforePrimitive(n,seq,a);
  ctx.updates.addPrimitive(p);
  return Iter.EMPTY;
}
