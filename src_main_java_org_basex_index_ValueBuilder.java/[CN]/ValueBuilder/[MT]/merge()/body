{
  final String f=text ? DATATXT : DATAATV;
  final DataOutput outl=new DataOutput(data.meta.file(f + 'l'));
  final DataOutput outr=new DataOutput(data.meta.file(f + 'r'));
  outl.write4(0);
  final ValueMerge[] vm=new ValueMerge[csize];
  for (int i=0; i < csize; ++i)   vm[i]=new ValueMerge(data,text,i);
  int min;
  int sz=0;
  final IntList ml=new IntList();
  while (check(vm)) {
    checkStop();
    ++sz;
    outr.write5(outl.size());
    min=0;
    ml.reset();
    for (int i=0; i < csize; ++i) {
      if (min == i || vm[i].pre.length == 0)       continue;
      final int d=diff(vm[min].token,vm[i].token);
      if (d > 0 || vm[min].pre.length == 0) {
        min=i;
        ml.reset();
      }
 else       if (d == 0 && vm[i].pre.length != 0) {
        if (ml.size() == 0)         ml.add(min);
        ml.add(i);
      }
    }
    final int ms=ml.size();
    if (ms == 0) {
      write(outl,vm[min].pre);
      vm[min].next();
    }
 else {
      final TokenBuilder tb=new TokenBuilder();
      tb.add(new byte[4]);
      int opre=0, npre=0;
      for (int j=0; j < ms; ++j) {
        final int m=ml.get(j);
        if (j == 0) {
          int l=4;
          while (l < vm[m].pre.length) {
            final int diff=Num.read(vm[m].pre,l);
            opre+=diff;
            l+=Num.len(diff);
          }
          tb.add(substring(vm[m].pre,4));
        }
 else {
          npre=Num.read(vm[m].pre,4);
          tb.add(Num.num(npre - opre));
          int l=4 + Num.len(npre);
          tb.add(substring(vm[m].pre,l));
          opre=npre;
          while (l < vm[m].pre.length) {
            final int diff=Num.read(vm[m].pre,l);
            opre+=diff;
            l+=Num.len(diff);
          }
        }
        vm[m].next();
      }
      final byte[] tmp=tb.finish();
      Num.size(tmp,tmp.length);
      write(outl,tmp);
    }
  }
  outr.close();
  outl.close();
  return sz;
}
