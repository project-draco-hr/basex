{
  for (int s=0; s < step.length; s++) {
    if (s > 0 && step[s - 1].pred.length != 0)     break;
    if (step[s].axis != Axis.DESC)     continue;
    ArrayList<PathNode> nodes=pathNodes(data,s);
    if (nodes == null)     continue;
    ctx.compInfo(OPTCHILD,step[s]);
    final TokenList tl=new TokenList();
    while (nodes.get(0).par != null) {
      byte[] tag=data.tags.key(nodes.get(0).name);
      for (int j=0; j < nodes.size(); j++) {
        if (nodes.get(0).name != nodes.get(j).name)         tag=null;
      }
      tl.add(tag);
      nodes=data.path.parent(nodes);
    }
    int ts=tl.size();
    final Step[] steps=new Step[ts + step.length - s - 1];
    for (int t=0; t < ts; t++) {
      final Expr[] preds=t == ts - 1 ? step[s].pred : new Expr[]{};
      final byte[] n=tl.get(ts - t - 1);
      final NameTest nt=n == null ? new NameTest(false) : new NameTest(new QNm(n),Kind.NAME,false);
      steps[t]=Step.get(info,Axis.CHILD,nt,preds);
    }
    while (++s < step.length)     steps[ts++]=step[s];
    return get(info,root,steps).children(ctx,data);
  }
  return this;
}
