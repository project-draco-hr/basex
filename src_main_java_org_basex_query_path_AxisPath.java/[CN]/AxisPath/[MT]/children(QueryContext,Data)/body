{
  for (int s=0; s < step.length; ++s) {
    if (s > 0 && step[s - 1].pred.length != 0)     break;
    if (step[s].axis != Axis.DESC || step[s].uses(Use.POS))     continue;
    ArrayList<PathNode> nodes=pathNodes(data,s);
    if (nodes == null)     continue;
    ctx.compInfo(OPTCHILD,step[s]);
    final TokenList tl=new TokenList();
    while (nodes.get(0).par != null) {
      byte[] tag=data.tags.key(nodes.get(0).name);
      for (int j=0; j < nodes.size(); ++j) {
        if (nodes.get(0).name != nodes.get(j).name)         tag=null;
      }
      tl.add(tag);
      nodes=data.path.parent(nodes);
    }
    int ts=tl.size();
    final AxisStep[] steps=new AxisStep[ts + step.length - s - 1];
    for (int t=0; t < ts; ++t) {
      final Expr[] preds=t == ts - 1 ? step[s].pred : new Expr[0];
      final byte[] n=tl.get(ts - t - 1);
      final NameTest nt=n == null ? new NameTest(false,input) : new NameTest(new QNm(n),Name.NAME,false,input);
      steps[t]=AxisStep.get(input,Axis.CHILD,nt,preds);
    }
    while (++s < step.length)     steps[ts++]=step[s];
    return get(input,root,steps).children(ctx,data);
  }
  return this;
}
