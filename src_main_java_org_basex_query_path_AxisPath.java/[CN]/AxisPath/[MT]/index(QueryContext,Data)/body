{
  IndexContext ics=null;
  int pmin=0;
  int smin=0;
  for (int s=0; s < step.length; ++s) {
    final AxisStep stp=step(s);
    if (!stp.axis.down)     break;
    final boolean d=pathNodes(data,s) == null;
    for (int p=0; p < stp.pred.length; ++p) {
      final IndexContext ic=new IndexContext(ctx,data,stp,d);
      if (!stp.pred[p].indexAccessible(ic))       continue;
      if (ic.costs() == 0) {
        if (ic.not) {
          stp.pred[p]=Bln.TRUE;
          continue;
        }
        ctx.compInfo(OPTNOINDEX,this);
        return Empty.SEQ;
      }
      if (ics == null || ics.costs() > ic.costs()) {
        ics=ic;
        pmin=p;
        smin=s;
      }
    }
  }
  if (ics == null || ics.costs() > data.meta.size) {
    if (ics == null)     return this;
    System.out.println(ics.costs() + "\n" + ctx.query);
    System.out.println();
    System.out.println();
    return this;
  }
  final AxisStep stp=step(smin);
  final Expr ie=stp.pred[pmin].indexEquivalent(ics);
  if (ics.seq) {
    stp.pred[pmin]=ie;
  }
 else {
    AxisStep[] inv={};
    final Expr[] newPreds=new Expr[stp.pred.length - 1];
    int c=0;
    for (int p=0; p != stp.pred.length; ++p) {
      if (p != pmin)       newPreds[c++]=stp.pred[p];
    }
    for (int j=smin; j >= 0; j--) {
      final Axis ax=step(j).axis.invert();
      if (ax == null)       break;
      if (j != 0) {
        final AxisStep prev=step(j - 1);
        inv=Array.add(inv,AxisStep.get(input,ax,prev.test,prev.pred));
      }
 else {
        final Test test=DocTest.get(ctx,data);
        if (test != Test.DOC || ax != Axis.ANC && ax != Axis.ANCORSELF)         inv=Array.add(inv,AxisStep.get(input,ax,test));
      }
    }
    final boolean simple=inv.length == 0 && newPreds.length == 0;
    AxisPath result=null;
    if (ie instanceof AxisPath) {
      result=(AxisPath)ie;
    }
 else     if (smin + 1 < step.length || !simple) {
      result=simple ? new AxisPath(input,ie) : new AxisPath(input,ie,AxisStep.get(input,Axis.SELF,Test.NOD));
    }
 else {
      return ie;
    }
    final int sl=result.step.length - 1;
    if (sl >= 0) {
      result.step[sl]=result.step(sl).addPreds(newPreds);
      if (inv.length != 0)       result.step[sl]=result.step(sl).addPreds(Path.get(input,null,inv));
    }
    for (int s=smin + 1; s < step.length; ++s) {
      result.step=Array.add(result.step,step[s]);
    }
    return result;
  }
  return this;
}
