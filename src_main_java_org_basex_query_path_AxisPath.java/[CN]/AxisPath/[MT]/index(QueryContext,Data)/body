{
  if (root == null || has(Flag.FCS))   return this;
  IndexContext ics=null;
  int pmin=0;
  int smin=0;
  for (int s=0; s < steps.length; ++s) {
    final Step stp=step(s);
    if (!stp.axis.down)     break;
    final boolean i=pathNodes(data,s) != null;
    for (int p=0; p < stp.preds.length; ++p) {
      final IndexContext ic=new IndexContext(ctx,data,stp,i);
      if (!stp.preds[p].indexAccessible(ic))       continue;
      if (ic.costs() == 0) {
        if (ic.not) {
          stp.preds[p]=Bln.TRUE;
          continue;
        }
        ctx.compInfo(OPTNOINDEX,this);
        return Empty.SEQ;
      }
      if (ics == null || ics.costs() > ic.costs()) {
        ics=ic;
        pmin=p;
        smin=s;
      }
    }
  }
  if (ics == null || ics.costs() > data.meta.size)   return this;
  final Step stp=step(smin);
  final Expr ie=stp.preds[pmin].indexEquivalent(ics);
  if (ics.seq) {
    stp.preds[pmin]=ie;
  }
 else {
    Step[] invSteps={};
    final Expr[] newPreds=new Expr[stp.preds.length - 1];
    int c=0;
    for (int p=0; p != stp.preds.length; ++p) {
      if (p != pmin)       newPreds[c++]=stp.preds[p];
    }
    final Test test=InvDocTest.get(ctx,data);
    boolean inv=true;
    if (test == Test.DOC && data.meta.uptodate) {
      int j=0;
      for (; j <= smin; ++j) {
        final Step s=axisStep(j);
        if (s == null || s.test.mode != Mode.NAME || s.axis != Axis.CHILD || j != smin && s.preds.length > 0)         break;
        final int name=data.tagindex.id(s.test.name.local());
        final ArrayList<PathNode> pn=data.paths.desc(name,Data.ELEM);
        if (pn.size() != 1 || pn.get(0).level() != j + 1)         break;
      }
      inv=j <= smin;
    }
    if (inv) {
      for (int j=smin; j >= 0; --j) {
        final Axis ax=step(j).axis.invert();
        if (ax == null)         break;
        if (j != 0) {
          final Step prev=step(j - 1);
          invSteps=Array.add(invSteps,Step.get(info,ax,prev.test,prev.preds));
        }
 else {
          if (test != Test.DOC || ax != Axis.ANC && ax != Axis.ANCORSELF)           invSteps=Array.add(invSteps,Step.get(info,ax,test));
        }
      }
    }
    final AxisPath result;
    final boolean simple=invSteps.length == 0 && newPreds.length == 0;
    if (ie instanceof AxisPath) {
      result=(AxisPath)ie;
    }
 else     if (smin + 1 < steps.length || !simple) {
      result=simple ? new CachedPath(info,ie) : new CachedPath(info,ie,Step.get(info,Axis.SELF,Test.NOD));
    }
 else {
      return ie;
    }
    final int ls=result.steps.length - 1;
    if (ls >= 0) {
      result.steps[ls]=result.step(ls).addPreds(newPreds);
      if (invSteps.length != 0)       result.steps[ls]=result.step(ls).addPreds(Path.get(info,null,invSteps));
    }
    for (int s=smin + 1; s < steps.length; ++s) {
      result.steps=Array.add(result.steps,steps[s]);
    }
    return result;
  }
  return this;
}
