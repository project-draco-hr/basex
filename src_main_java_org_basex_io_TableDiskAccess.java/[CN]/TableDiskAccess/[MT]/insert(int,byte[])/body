{
  if (entries.length == 0)   return;
  final int nr=entries.length >>> IO.NODEPOWER;
  meta.size+=nr;
  dirty=true;
  final int split=cursor(pre - 1) + (1 << IO.NODEPOWER);
  final int nold=npre - fpre << IO.NODEPOWER;
  final int nlast=nold - split;
  if (nold + entries.length <= IO.BLOCKSIZE) {
    System.arraycopy(bf.data,split,bf.data,split + entries.length,nlast);
    System.arraycopy(entries,0,bf.data,split,entries.length);
    bf.dirty=true;
    for (int i=index + 1; i < blocks; ++i)     fpres[i]+=nr;
    npre+=nr;
    return;
  }
  final byte[] all=new byte[entries.length + nlast];
  System.arraycopy(entries,0,all,0,entries.length);
  System.arraycopy(bf.data,split,all,entries.length,nlast);
  int n=bf.data.length - split;
  if (n > 0) {
    System.arraycopy(all,0,bf.data,split,n);
    bf.dirty=true;
  }
  final int neededBlocks=(all.length - n + IO.BLOCKSIZE - 1) / IO.BLOCKSIZE;
  final int newBlocks=neededBlocks - (allBlocks - blocks);
  if (newBlocks > 0) {
    fpres=Arrays.copyOf(fpres,fpres.length + newBlocks);
    pages=Arrays.copyOf(pages,pages.length + newBlocks);
  }
  Array.move(fpres,index + 1,neededBlocks,blocks - index - 1);
  Array.move(pages,index + 1,neededBlocks,blocks - index - 1);
  while (n < all.length) {
    getFreeBlock();
    n+=write(all,n);
    fpres[index + 1]=fpres[index] + ENTRIES;
    pages[++index]=(int)bf.pos;
  }
  for (int i=index + 1; i < blocks; ++i)   fpres[i]+=nr;
  fpre=fpres[index];
  npre=index + 1 >= blocks ? meta.size : fpres[index + 1];
}
