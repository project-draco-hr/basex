{
  dirty=true;
  final int nr=entries.length >>> IO.NODEPOWER;
  meta.size+=nr;
  cursor(pre - 1);
  final int ins=pre - fpre;
  if (nr < ENTRIES - npre + fpre) {
    copy(bf.data,ins,bf.data,ins + nr,npre - pre + 1);
    copy(entries,0,bf.data,ins,nr);
    for (int i=index + 1; i < blocks; ++i)     fpres[i]+=nr;
    npre+=nr;
    return;
  }
  final int move=npre - pre;
  final byte[] rest=new byte[move << IO.NODEPOWER];
  copy(bf.data,ins,rest,0,move);
  int newBlocks=(int)Math.ceil((double)nr / ENTRIES) + 1;
  if (pre == npre)   newBlocks--;
  final int s=allBlocks + newBlocks;
  fpres=Arrays.copyOf(fpres,s);
  pages=Arrays.copyOf(pages,s);
  Array.move(fpres,index + 1,newBlocks,blocks - index - 1);
  Array.move(pages,index + 1,newBlocks,blocks - index - 1);
  int remain=nr;
  int pos=0;
  while (remain > 0) {
    newBlock();
    copy(entries,pos,bf.data,0,Math.min(remain,ENTRIES));
    fpres[++index]=nr - remain + pre;
    pages[index]=(int)bf.pos;
    blocks++;
    remain-=ENTRIES;
    pos+=ENTRIES;
  }
  if (rest.length > 0) {
    newBlock();
    copy(rest,0,bf.data,0,move);
    fpres[++index]=pre + nr;
    pages[index]=(int)bf.pos;
    blocks++;
  }
  for (int i=index + 1; i < blocks; ++i)   fpres[i]+=nr;
  fpre=pre;
  if (rest.length > 0)   fpre+=nr;
  npre=index + 1 >= blocks ? meta.size : fpres[index + 1];
}
