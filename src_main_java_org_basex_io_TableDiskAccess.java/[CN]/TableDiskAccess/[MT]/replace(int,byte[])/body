{
  if (entries.length == 0)   return;
  int blockOffset=cursor(pre - 1) + (1 << IO.NODEPOWER);
  final int numberOfRecords=entries.length >>> IO.NODEPOWER;
  final int rightSiblingPre=pre + numberOfRecords;
  if (rightSiblingPre <= npre) {
    System.arraycopy(entries,0,bf.data,blockOffset,entries.length);
    bf.dirty=true;
    dirty=true;
  }
 else {
    final int lastToOwPre=pre + numberOfRecords - 1;
    int currentSourcePos=0;
    while (lastToOwPre >= npre) {
      final int firstOwPreCurrentBlock=Math.max(fpre,pre);
      final int lastOwPreCurrentBlock=npre > lastToOwPre ? lastToOwPre : npre - 1;
      final int nrOfNodesToOw=lastOwPreCurrentBlock - firstOwPreCurrentBlock + 1;
      final int nrOfEntriesToOw=nrOfNodesToOw << IO.NODEPOWER;
      System.arraycopy(entries,currentSourcePos,bf.data,blockOffset,nrOfEntriesToOw);
      bf.dirty=true;
      dirty=true;
      readBlock(index + 1);
      blockOffset=0;
      currentSourcePos+=nrOfEntriesToOw;
    }
    bf.dirty=true;
    dirty=true;
  }
}
