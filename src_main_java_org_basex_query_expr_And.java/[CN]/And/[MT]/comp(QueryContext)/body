{
  super.comp(ctx);
  for (int e=0; e < expr.length; e++) {
    if (!expr[e].item())     continue;
    if (!((Item)expr[e]).bool(input)) {
      ctx.compInfo(OPTFALSE,expr[e]);
      return Bln.FALSE;
    }
    ctx.compInfo(OPTTRUE,expr[e]);
    expr=Array.delete(expr,e--);
    if (expr.length == 0)     return Bln.TRUE;
  }
  Expr[] ex={};
  Pos ps=null;
  CmpR cr=null;
  for (  final Expr e : expr) {
    Expr tmp=null;
    if (e instanceof Pos) {
      tmp=ps == null ? e : ps.intersect((Pos)e,input);
      if (!(tmp instanceof Pos))       return tmp;
      ps=(Pos)tmp;
    }
 else     if (e instanceof CmpR) {
      tmp=cr == null ? e : cr.intersect((CmpR)e);
      if (tmp instanceof CmpR) {
        cr=(CmpR)tmp;
      }
 else       if (tmp != null) {
        return tmp;
      }
    }
    if (tmp == null)     ex=Array.add(ex,e);
  }
  expr=ex;
  if (ps != null)   expr=Array.add(expr,ps);
  if (cr != null)   expr=Array.add(expr,cr);
  if (expr.length == 1) {
    final SeqType ret=expr[0].returned(ctx);
    if (ret.type == Type.BLN && ret.one())     return expr[0];
  }
  return this;
}
