{
  return new FTNodeIter(){
    /** 
 * Flag is set, if ith expression has any result. 
 */
    final FTNode[] mp=new FTNode[pex.length];
    /** 
 * Cache for one of the nodes. 
 */
    final IntList cp=new IntList(pex);
    /** 
 * Pointer on the positive expression with the lowest pre-values.
 */
    int minp=-1;
    @Override public FTNode next() throws QueryException {
      for (int i=0; i < cp.size; i++) {
        final int p=pex[cp.list[i]];
        mp[p]=expr[p].iter(ctx).next();
      }
      cp.reset();
      if (minp == -1) {
        minp=0;
        while (minp < mp.length && mp[minp].empty())         minp++;
        if (minp < mp.length)         cp.set(minp,0);
        for (int ip=minp + 1; ip < pex.length; ip++) {
          if (!mp[ip].empty()) {
            final FTNode n1=mp[pex[ip]];
            final FTNode n2=mp[pex[minp]];
            final int d=n1.fte.pre() - n2.fte.pre();
            if (d < 0) {
              minp=ip;
              cp.set(ip,0);
            }
 else             if (d == 0) {
              cp.add(ip);
            }
          }
        }
      }
      minp=-1;
      final FTNode m=mp[pex[cp.list[0]]];
      for (int i=1; i < cp.size; i++) {
        m.union(ctx,mp[pex[cp.list[i]]],0);
        m.fte.not=false;
      }
      if (m.empty())       m.fte.not=not;
      return m;
    }
  }
;
}
