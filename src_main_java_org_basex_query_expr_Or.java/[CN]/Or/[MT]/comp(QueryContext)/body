{
  super.comp(ctx);
  for (int e=0; e < expr.length; e++) {
    if (!expr[e].item())     continue;
    if (((Item)expr[e]).bool(input)) {
      ctx.compInfo(OPTTRUE,expr[e]);
      return Bln.TRUE;
    }
    ctx.compInfo(OPTFALSE,expr[e]);
    expr=Array.delete(expr,e--);
    if (expr.length == 0)     return Bln.FALSE;
  }
  if (expr.length == 2 && expr[0] instanceof Pos && expr[1] instanceof Pos)   return ((Pos)expr[0]).union((Pos)expr[1],input);
  if (expr.length == 1) {
    final SeqType ret=expr[0].returned(ctx);
    if (ret.type == Type.BLN && ret.one())     return expr[0];
  }
  for (  final Expr e : expr)   if (!(e instanceof CmpG))   return this;
  final CmpG e1=(CmpG)expr[0];
  final SeqIter cmp=new SeqIter();
  for (  final Expr e : expr) {
    final CmpG e2=(CmpG)e;
    if (!e2.exprAndItem(false) || e1.cmp != e2.cmp || !e1.expr[0].sameAs(e2.expr[0]))     return this;
    cmp.add((Item)e2.expr[1]);
  }
  ctx.compInfo(OPTWRITE,this);
  return new CmpG(input,e1.expr[0],cmp.finish(),e1.cmp);
}
