{
  root=ctx.comp(root);
  Expr e=root;
  if (expr[0] instanceof Step) {
    final Step s=(Step)expr[0];
    if (e instanceof DNode && (s.axis == ATTR || s.axis == PARENT || s.axis == SELF && s.test != NODE) || e instanceof CAttr && s.axis == CHILD)     Err.or(COMPSELF,s);
  }
  for (int i=0; i != expr.length; i++) {
    expr[i]=ctx.comp(expr[i]);
    steps&=expr[i] instanceof Step;
  }
  if (steps) {
    mergeDesc(ctx);
    checkEmpty();
    cache=!root.uses(Using.VAR);
    boolean noPreds=true;
    for (    final Expr step : expr) {
      if (((Step)step).expr.length != 0) {
        noPreds=false;
        if (step.uses(Using.VAR)) {
          cache=false;
          break;
        }
      }
    }
    final Axis axis=((Step)expr[0]).axis;
    if (cache && noPreds && expr.length == 1 && (axis == Axis.DESC || axis == Axis.DESCORSELF || axis == Axis.CHILD)) {
      return new SimpleIterPath(root,expr);
    }
    if (expr.length == 1 && checkAxes() && isAbsPath()) {
      for (int i=0; i < expr.length; i++) {
        final Step s=(Step)expr[i];
        FTIndexAcsbl iacs=null;
        int minp=0;
        int min=Integer.MAX_VALUE;
        for (int j=0; j < s.expr.length; j++) {
          FTIndexAcsbl ia=new FTIndexAcsbl();
          s.expr[j].indexAccessible(ctx,ia);
          if (ia.io && ia.iu) {
            if (min >= ia.indexSize) {
              min=ia.indexSize;
              iacs=ia;
              minp=j;
            }
          }
        }
        if (iacs != null && iacs.io && iacs.iu) {
          final FTIndexEq ieq=new FTIndexEq(s,iacs.seq);
          Expr ie=s.expr[minp].indexEquivalent(ctx,ieq);
          if (iacs.indexSize == 0) {
            if (iacs.ftnot) {
              s.expr[0]=((FTContains)s.expr[minp]).expr[0];
              return this;
            }
 else {
              return Seq.EMPTY;
            }
          }
          if (iacs.seq) {
            s.expr[0]=ie;
          }
 else {
            Path result=(Path)ie;
            final Expr[] newPreds=new Expr[s.expr.length - 1];
            int c=0;
            for (int p=0; p != s.expr.length; p++)             if (p != minp)             newPreds[c++]=s.expr[p];
            for (int j=i; j > 0; j--) {
              final Step curr=(Step)expr[j];
              final Axis a=invertAxis(curr.axis);
              if (a == null)               break;
              if (j == 0) {
                if (this.isAbsPath() || a == Axis.PARENT) {
                  result.addStep(new Step(a,Test.NODE,new Expr[]{}));
                }
              }
 else {
                final Step prev=(Step)expr[j - 1];
                if (prev.expr.length != 0)                 break;
                final Step step=(Step)result.expr[result.expr.length - 1];
                final Expr[] tmp=new Expr[step.expr.length + 1];
                System.arraycopy(step.expr,0,tmp,0,tmp.length - 1);
                tmp[tmp.length - 1]=new Step(a,prev.test,new Expr[]{});
                step.expr=tmp;
              }
            }
            if (newPreds.length > 0 && ieq.addFilter)             ie=new Filter(result,newPreds).comp(ctx);
 else             ie=result;
            return ie;
          }
        }
      }
    }
  }
  return this;
}
