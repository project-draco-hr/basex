{
  root=ctx.comp(root);
  Expr e=root;
  if (expr[0] instanceof Step) {
    final Step s=(Step)expr[0];
    if (e instanceof DNode && (s.axis == ATTR || s.axis == PARENT || s.axis == SELF && s.test != NODE) || e instanceof CAttr && s.axis == CHILD)     Err.or(COMPSELF,s);
  }
  for (int i=0; i != expr.length; i++) {
    expr[i]=ctx.comp(expr[i]);
    steps&=expr[i] instanceof Step;
  }
  if (steps) {
    mergeDesc(ctx);
    checkEmpty();
    cache=!root.uses(Using.VAR);
    boolean noPreds=true;
    for (    final Expr step : expr) {
      if (((Step)step).expr.length != 0) {
        noPreds=false;
        if (step.uses(Using.VAR)) {
          cache=false;
          break;
        }
      }
    }
    final Axis axis=((Step)expr[0]).axis;
    if (cache && noPreds && expr.length == 1 && (axis == Axis.DESC || axis == Axis.DESCORSELF || axis == Axis.CHILD)) {
      return new SimpleIterPath(root,expr);
    }
  }
  return this;
}
