{
  root=ctx.comp(root);
  Expr e=root;
  if (expr[0] instanceof Step) {
    final Step s=(Step)expr[0];
    if (e instanceof DNode && (s.axis == ATTR || s.axis == PARENT || s.axis == SELF && s.test != NODE) || e instanceof CAttr && s.axis == CHILD)     Err.or(COMPSELF,s);
  }
  for (int i=0; i != expr.length; i++) {
    expr[i]=ctx.comp(expr[i]);
    steps&=expr[i] instanceof Step;
  }
  if (steps) {
    mergeDesc(ctx);
    checkEmpty();
    cache=!root.uses(Using.VAR);
    boolean noPreds=true;
    for (    final Expr step : expr) {
      if (((Step)step).expr.length != 0) {
        noPreds=false;
        if (step.uses(Using.VAR)) {
          cache=false;
          break;
        }
      }
    }
    final Axis axis=((Step)expr[0]).axis;
    if (cache && noPreds && expr.length == 1 && (axis == Axis.DESC || axis == Axis.DESCORSELF || axis == Axis.CHILD)) {
      return new SimpleIterPath(root,expr);
    }
    if (expr.length == 1 && checkAxes() && isAbsPath()) {
      for (int i=0; i < expr.length; i++) {
        final Step s=(Step)expr[i];
        FTIndexAcsbl iacs=null;
        int minp=0;
        int min=Integer.MAX_VALUE;
        for (int j=0; j < s.expr.length; j++) {
          FTIndexAcsbl ia=new FTIndexAcsbl();
          s.expr[j].indexAccessible(ctx,ia);
          if (ia.io && ia.iu) {
            if (min > ia.indexSize) {
              min=ia.indexSize;
              iacs=ia;
              minp=j;
            }
          }
        }
        if (iacs != null && iacs.io && iacs.iu) {
          final FTIndexEq ieq=new FTIndexEq(s,iacs.seq);
          Expr ie=s.expr[minp].indexEquivalent(ctx,ieq);
          if (iacs.indexSize == 0) {
            if (iacs.ftnot) {
              s.expr[0]=((FTContains)s.expr[minp]).expr[0];
              return this;
            }
 else {
              return Seq.EMPTY;
            }
          }
          if (iacs.seq) {
            s.expr[0]=ie;
          }
 else {
            Expr result=ie;
            final Expr[] newPreds=new Expr[s.expr.length - 1];
            int c=0;
            for (int p=0; p != s.expr.length; p++)             if (p != minp)             newPreds[c++]=s.expr[p];
            if (newPreds.length > 0 && ieq.addFilter)             result=new Filter(ie,newPreds).comp(ctx);
            return result;
          }
        }
      }
    }
  }
  return this;
}
