{
  root=ctx.comp(root);
  Expr e=root;
  if (expr[0] instanceof Step) {
    final Step s=(Step)expr[0];
    if (e instanceof DNode && (s.axis == ATTR || s.axis == PARENT || s.axis == SELF && s.test != NODE) || e instanceof CAttr && s.axis == CHILD)     Err.or(COMPSELF,s);
  }
  for (int i=0; i != expr.length; i++) {
    expr[i]=ctx.comp(expr[i]);
    steps&=expr[i] instanceof Step;
  }
  if (steps) {
    mergeDesc(ctx);
    checkEmpty();
    cache=!root.uses(Using.VAR);
    boolean noPreds=true;
    for (    final Expr step : expr) {
      if (((Step)step).expr.length != 0) {
        noPreds=false;
        if (step.uses(Using.VAR)) {
          cache=false;
          break;
        }
      }
    }
    final Axis axis=((Step)expr[0]).axis;
    if (cache && noPreds && expr.length == 1 && (axis == Axis.DESC || axis == Axis.DESCORSELF || axis == Axis.CHILD)) {
      return new SimpleIterPath(root,expr);
    }
    final Step s=(Step)expr[0];
    if (s.expr != null && s.expr.length == 1 && s.expr[0] instanceof FTContains) {
      final FTContains ftc=(FTContains)s.expr[0];
      FTIndexAcsbl ia=new FTIndexAcsbl();
      ftc.indexAccessible(ctx,ia);
      if (ia.io && ia.iu) {
        final FTIndexEq ieq=new FTIndexEq(s,ia.seq);
        final Expr ie=ftc.indexEquivalent(ctx,ieq);
        if (ia.indexSize == 0) {
          if (ia.ftnot) {
            s.expr[0]=ftc.expr[0];
            return this;
          }
 else {
            return Seq.EMPTY;
          }
        }
        if (ia.seq) {
          s.expr[0]=ie;
        }
 else {
          return ie;
        }
      }
    }
  }
  return this;
}
