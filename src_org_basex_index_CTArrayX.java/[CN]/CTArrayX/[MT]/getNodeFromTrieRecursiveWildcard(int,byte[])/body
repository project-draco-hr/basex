{
  byte[] valueSearchNode=searchNode;
  if (currentCompressedTrieNode != 0) {
    counter[1]+=nodes[currentCompressedTrieNode][0];
    int i=0;
    while (i < valueSearchNode.length && i < nodes[currentCompressedTrieNode][0] && nodes[currentCompressedTrieNode][i + 1] == valueSearchNode[i]) {
      i++;
    }
    if (nodes[currentCompressedTrieNode][0] == i) {
      if (valueSearchNode.length == i) {
        counter[0]=i;
        return currentCompressedTrieNode;
      }
 else {
        final byte[] tmp=new byte[valueSearchNode.length - i];
        for (int j=0; j < tmp.length; j++) {
          tmp[j]=valueSearchNode[i + j];
        }
        valueSearchNode=tmp;
        final int position=getInsertingPositionLinear(currentCompressedTrieNode,valueSearchNode[0]);
        if (!found) {
          counter[0]=i;
          counter[1]=counter[1] - nodes[currentCompressedTrieNode][0] + i;
          return currentCompressedTrieNode;
        }
 else {
          final int id=getIdOnDataArray(currentCompressedTrieNode);
          return getNodeFromTrieRecursiveWildcard(data[id][position],valueSearchNode);
        }
      }
    }
 else {
      counter[0]=i;
      counter[1]=counter[1] - nodes[currentCompressedTrieNode][0] + i;
      return currentCompressedTrieNode;
    }
  }
 else {
    final int position=getInsertingPositionLinear(currentCompressedTrieNode,valueSearchNode[0]);
    if (!found) {
      counter[0]=-1;
      counter[1]=-1;
      return -1;
    }
 else {
      final int id=getIdOnDataArray(currentCompressedTrieNode);
      return getNodeFromTrieRecursiveWildcard(data[id][position],valueSearchNode);
    }
  }
}
