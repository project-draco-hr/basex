{
  if (ctx.item == null)   throw new QueryException(NODATA);
  if (ctx.leaf && steps.size() == 1 && steps.get(0).simple(Axis.SELF)) {
    steps.set(0,Axis.create(Axis.CHILD,TestNode.TEXT));
    ctx.compInfo(OPTTEXT);
  }
  if (!steps.compile(ctx) || steps.emptyPath(ctx))   return new Nod(ctx);
  steps.mergeSelf(ctx);
  steps.mergeDescendant(ctx);
  if (this instanceof LocPathRel)   return this;
  for (int i=0; i < steps.size(); i++) {
    final Preds preds=steps.get(i).preds;
    for (int p=0; p < preds.size(); p++) {
      if (preds.get(p) instanceof PredPos)       return this;
    }
  }
  Expr result=this;
  MAIN:   for (int i=0; i < steps.size(); i++) {
    final Step step=steps.get(i);
    final Preds preds=step.preds;
    if (step.axis.invert() == null)     continue;
    boolean pos=false;
    int min=Integer.MAX_VALUE;
    int minP=-1;
    for (int p=0; p < preds.size(); p++) {
      final Pred pred=preds.get(p);
      final int nrIDs=pred.indexSizes(ctx,step,min);
      if (nrIDs == 0) {
        ctx.compInfo(OPTLOC);
        return new Nod(ctx);
      }
      if (min > nrIDs) {
        if (pos)         continue MAIN;
        min=nrIDs;
        minP=p;
      }
      pos|=pred.usesPos() || pred.usesSize();
    }
    final boolean seq=min == Integer.MAX_VALUE;
    final IntList oldPreds=new IntList();
    Expr indexArg=null;
    for (int p=0; p < preds.size(); p++) {
      final Pred pred=preds.get(p);
      if (seq || p == minP && indexArg == null) {
        oldPreds.add(p);
        indexArg=pred.indexEquivalent(ctx,step,seq);
      }
    }
    if (seq)     continue;
    final LocPath oldPath=new LocPathRel();
    for (final int j=i + 1; j < steps.size(); ) {
      final Step oldStep=steps.get(j);
      steps.remove(j);
      oldPath.steps.add(oldStep);
    }
    final LocPath invPath=new LocPathRel();
    boolean indexMatch=true;
    for (int j=i; j >= 0; j--) {
      final Step curr=steps.get(j);
      final Axis axis=curr.axis.invert();
      if (axis == null)       break;
      if (j == 0) {
        if (this instanceof LocPathRel || axis == Axis.PARENT) {
          invPath.steps.add(Axis.create(axis,TestNode.NODE));
        }
 else {
          indexMatch=false;
        }
      }
 else {
        final Step prev=steps.get(j - 1);
        if (prev.preds.size() != 0)         break;
        invPath.steps.add(Axis.create(axis,prev.test));
      }
      steps.remove(j);
    }
    int predlength=preds.size() - oldPreds.size;
    if (indexMatch || invPath.steps.size() != 0)     predlength+=1;
    final Preds newPreds=new Preds();
    if (!indexMatch && invPath.steps.size() != 0)     newPreds.add(invPath);
    for (int p=0; p != step.preds.size(); p++) {
      if (!oldPreds.contains(p)) {
        final Pred pred=step.preds.get(p);
        if (pred instanceof PredSimple) {
          final Expr e=((PredSimple)pred).expr;
          if (e instanceof FTContains) {
            ((PredSimple)pred).expr=e.indexEquivalent(ctx,null,true);
          }
        }
        newPreds.add(pred);
      }
    }
    result=new InterSect(indexArg).comp(ctx);
    if (newPreds.size() != 0)     result=new Filter(result,newPreds).comp(ctx);
    if (indexMatch)     result=new IndexMatch(this,result,invPath);
    if (oldPath.steps.size() != 0)     result=new Path(result,oldPath);
  }
  return result;
}
