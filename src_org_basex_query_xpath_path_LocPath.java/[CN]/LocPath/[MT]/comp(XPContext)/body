{
  if (ctx.item == null)   throw new QueryException(NODATA);
  if (ctx.leaf && steps.size() == 1 && steps.get(0).simple(Axis.SELF)) {
    steps.set(0,Axis.create(Axis.CHILD,TestNode.TEXT));
    ctx.compInfo(OPTTEXT);
  }
  if (!steps.compile(ctx) || steps.emptyPath(ctx))   return new Nod(ctx);
  steps.mergeSelf(ctx);
  steps.mergeDescendant(ctx);
  if (this instanceof LocPathRel)   return this;
  for (  final Step s : steps) {
    final Preds preds=s.preds;
    for (    final Pred p : preds) {
      if (p instanceof PredPos)       return this;
    }
  }
  Expr result=this;
  MAIN:   for (int i=0; i < steps.size(); i++) {
    final Step step=steps.get(i);
    final Preds preds=step.preds;
    boolean pos=false;
    int min=Integer.MAX_VALUE;
    int minP=-1;
    for (int p=0; p < preds.size(); p++) {
      final Pred pred=preds.get(p);
      final int nrIDs=pred.indexSizes(ctx,step,min);
      if (nrIDs == 0) {
        ctx.compInfo(OPTLOC);
        return new Nod(ctx);
      }
      if (min > nrIDs) {
        if (pos)         continue MAIN;
        min=nrIDs;
        minP=p;
      }
      pos|=pred.usesPos() || pred.usesSize();
    }
    final boolean seq=min == Integer.MAX_VALUE;
    final IntList oldPreds=new IntList();
    Expr indexArg=null;
    for (int p=0; p < preds.size(); p++) {
      if (seq || p == minP && indexArg == null) {
        oldPreds.add(p);
        indexArg=preds.get(p).indexEquivalent(ctx,step,seq);
      }
    }
    if (seq)     continue;
    final LocPath oldPath=new LocPathRel();
    for (final int j=i + 1; j < steps.size(); ) {
      oldPath.steps.add(steps.remove(j));
    }
    final LocPath inv=new LocPathRel();
    for (int j=i; j >= 0; j--) {
      final Axis a=steps.get(j).axis.invert();
      if (a == null)       break;
      if (j == 0) {
        if (a == Axis.PARENT)         inv.steps.add(Axis.create(a,TestNode.DOC));
      }
 else {
        final Step prev=steps.get(j - 1);
        if (prev.preds.size() != 0)         break;
        inv.steps.add(Axis.create(a,prev.test));
      }
      steps.remove(j);
    }
    final Preds newPreds=new Preds();
    if (inv.steps.size() != 0)     newPreds.add(inv);
    for (int p=0; p != step.preds.size(); p++) {
      if (!oldPreds.contains(p)) {
        final Pred pred=step.preds.get(p);
        if (pred instanceof PredSimple) {
          final Expr e=((PredSimple)pred).expr;
          if (e instanceof FTContains) {
            ((PredSimple)pred).expr=e.indexEquivalent(ctx,null,true);
          }
        }
        newPreds.add(pred);
      }
    }
    result=new InterSect(indexArg).comp(ctx);
    if (newPreds.size() != 0)     result=new Filter(result,newPreds).comp(ctx);
    if (oldPath.steps.size() != 0)     result=new Path(result,oldPath);
  }
  return result;
}
