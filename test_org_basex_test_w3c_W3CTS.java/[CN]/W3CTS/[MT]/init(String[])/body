{
  for (  final String arg : args) {
    if (arg.equals("-r")) {
      reporting=true;
      currTime=true;
    }
 else     if (arg.startsWith("-p")) {
      path=arg.substring(2);
    }
 else     if (arg.equals("-t")) {
      currTime=true;
    }
 else     if (arg.equals("-v")) {
      verbose=true;
    }
 else     if (!arg.startsWith("-")) {
      single=arg;
      maxout*=10;
    }
 else {
      BaseX.outln("\nBaseX vs. XQuery Test Suite\n" + " [pat] perform only tests with the specified pattern\n" + " -h show this help\n"+ " -p change path\n"+ " -r create report\n"+ " -v verbose output");
      return;
    }
  }
  queries=path + "Queries/XQuery/";
  expected=path + "ExpectedTestResults/";
  results=path + "ReportingResults/Results/";
  report=path + "ReportingResults/";
  sources=path + "TestSources/";
  final SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
  final String dat=sdf.format(Calendar.getInstance().getTime());
  final Performance perf=new Performance();
  final Context context=new Context();
  new Check(path + input).execute(context,null);
  data=context.data();
  final Nodes root=new Nodes(0,data);
  BaseX.outln("\nBaseX vs. XQuery Test Suite " + text("/*:test-suite/@version",root));
  BaseX.outln("\nCaching Sources...");
  for (  final int s : nodes("//*:source",root).nodes) {
    final Nodes srcRoot=new Nodes(s,data);
    final String val=(path + text("@FileName",srcRoot)).replace('\\','/');
    srcs.put(text("@ID",srcRoot),val);
  }
  BaseX.outln("Caching Modules...");
  for (  final int s : nodes("//*:module",root).nodes) {
    final Nodes srcRoot=new Nodes(s,data);
    final String val=(path + text("@FileName",srcRoot)).replace('\\','/');
    mods.put(text("@ID",srcRoot),val);
  }
  BaseX.outln("Caching Collections...");
  for (  final int c : nodes("//*:collection",root).nodes) {
    final Nodes nodes=new Nodes(c,data);
    final String cname=text("@ID",nodes);
    final TokenList dl=new TokenList();
    final Nodes doc=nodes("*:input-document",nodes);
    for (int d=0; d < doc.size(); d++) {
      dl.add(token(sources + string(data.atom(doc.nodes[d])) + IO.XMLSUFFIX));
    }
    colls.put(cname,dl.finish());
  }
  BaseX.outln("Caching Stopwords...");
  for (  final int s : nodes("//*:stopwords",root).nodes) {
    final Nodes srcRoot=new Nodes(s,data);
    final String val=(path + text("@FileName",srcRoot)).replace('\\','/');
    stop.put(text("@uri",srcRoot),val);
  }
  if (reporting) {
    BaseX.outln("Delete old results...");
    delete(new File[]{new File(results)});
  }
  BaseX.out("Parsing Queries");
  final Nodes nodes=nodes("//*:test-case",root);
  for (int t=0; t < nodes.size(); t++) {
    if (!parse(new Nodes(nodes.nodes[t],data)))     break;
    if (t % 1000 == 0)     BaseX.out(".");
  }
  BaseX.outln();
  final String time=perf.getTimer();
  final int total=ok + ok2 + err+ err2;
  BaseX.outln("Writing log file...\n");
  BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(pathlog),UTF8));
  bw.write("TEST RESULTS ==================================================");
  bw.write(Prop.NL + Prop.NL + "Total #Queries: "+ total+ Prop.NL);
  bw.write("Correct / Empty Results: " + ok + " / "+ ok2+ Prop.NL);
  bw.write("Conformance (w/Empty Results): ");
  bw.write(pc(ok,total) + " / " + pc(ok + ok2,total)+ Prop.NL);
  bw.write("Wrong Results / Errors: " + err + " / "+ err2+ Prop.NL);
  bw.write("WRONG =========================================================");
  bw.write(Prop.NL + Prop.NL + logErr+ Prop.NL);
  bw.write("WRONG (ERRORS) ================================================");
  bw.write(Prop.NL + Prop.NL + logErr2+ Prop.NL);
  bw.write("CORRECT? (EMPTY) ==============================================");
  bw.write(Prop.NL + Prop.NL + logOK2+ Prop.NL);
  bw.write("CORRECT =======================================================");
  bw.write(Prop.NL + Prop.NL + logOK+ Prop.NL);
  bw.write("===============================================================");
  bw.close();
  bw=new BufferedWriter(new FileWriter(pathhis,true));
  bw.write(dat + "\t" + ok+ "\t"+ ok2+ "\t"+ err+ "\t"+ err2+ Prop.NL);
  bw.close();
  if (reporting) {
    bw=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(report + NAME + IO.XMLSUFFIX),UTF8));
    write(bw,report + NAME + "Pre"+ IO.XMLSUFFIX);
    bw.write(logFile.toString());
    write(bw,report + NAME + "Pos"+ IO.XMLSUFFIX);
    bw.close();
  }
  BaseX.outln("Total #Queries: " + total);
  BaseX.outln("Correct / Empty results: " + ok + " / "+ ok2);
  BaseX.out("Conformance (w/empty results): ");
  BaseX.outln(pc(ok,total) + " / " + pc(ok + ok2,total));
  BaseX.outln("Total Time: " + time);
}
