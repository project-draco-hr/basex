{
  final String pth=text("@FilePath",root);
  final String outname=text("@name",root);
  if (single != null && !outname.startsWith(single))   return true;
  if (verbose)   Main.outln("- " + outname);
  boolean inspect=false;
  boolean correct=true;
  final Nodes nodes=states(root);
  for (int n=0; n < nodes.size(); n++) {
    final Nodes state=new Nodes(nodes.nodes[n],nodes.data);
    final String inname=text("*:query/@name",state);
    Prop.xquery=IO.get(queries + pth + inname+ ".xq");
    final String in=read(Prop.xquery);
    String error=null;
    SeqIter iter=null;
    boolean doc=true;
    final TokenBuilder files=new TokenBuilder();
    final CachedOutput out=new CachedOutput();
    final Nodes cont=nodes("*:contextItem",state);
    Nodes curr=null;
    if (cont.size() != 0) {
      final Data d=Open.check(context,srcs.get(string(data.atom(cont.nodes[0]))));
      curr=new Nodes(d.doc(),d,true);
    }
    final QueryProcessor xq=new QueryProcessor(in,curr,context);
    final QueryContext qctx=xq.ctx;
    try {
      files.add(file(nodes("*:input-file",state),nodes("*:input-file/@variable",state),qctx,n == 0));
      files.add(file(nodes("*:input-URI",state),nodes("*:input-URI/@variable",state),qctx,n == 0));
      files.add(file(nodes("*:defaultCollection",state),null,qctx,n == 0));
      var(nodes("*:input-query/@name",state),nodes("*:input-query/@variable",state),pth,qctx);
      parse(qctx,state);
      for (      final int p : nodes("*:module",root).nodes) {
        final String ns=text("@namespace",new Nodes(p,data));
        final String f=mods.get(string(data.atom(p))) + ".xq";
        xq.module(ns,f);
      }
      final XMLSerializer xml=new XMLSerializer(out,false,context.prop.is(Prop.XQFORMAT));
      iter=SeqIter.get(xq.iter());
      Item it;
      while ((it=iter.next()) != null) {
        doc&=it.type == Type.DOC;
        it.serialize(xml);
      }
      xml.close();
    }
 catch (    final QueryException ex) {
      error=ex.getMessage();
      if (error.startsWith("Stopped at")) {
        error=error.substring(error.indexOf('\n') + 1);
      }
      if (error.startsWith("[")) {
        final int i=error.indexOf("]");
        error=error.substring(1).substring(0,i - 1) + error.substring(i + 1);
      }
    }
catch (    final Exception ex) {
      final ByteArrayOutputStream bw=new ByteArrayOutputStream();
      ex.printStackTrace(new PrintStream(bw));
      error=bw.toString();
    }
catch (    final Error ex) {
      final ByteArrayOutputStream bw=new ByteArrayOutputStream();
      ex.printStackTrace(new PrintStream(bw));
      error=bw.toString();
    }
    final Nodes outFiles=nodes("*:output-file/text()",state);
    final Nodes cmpFiles=nodes("*:output-file/@compare",state);
    boolean xml=false;
    boolean frag=false;
    final StringList result=new StringList();
    for (int o=0; o < outFiles.size(); o++) {
      final String resFile=string(data.atom(outFiles.nodes[o]));
      final IO exp=IO.get(expected + pth + resFile);
      result.add(read(exp));
      final byte[] type=data.atom(cmpFiles.nodes[o]);
      xml|=eq(type,XML);
      frag|=eq(type,FRAGMENT);
    }
    String expError=text("*:expected-error/text()",state);
    final StringBuilder log=new StringBuilder(pth + inname + ".xq");
    if (files.size() != 0) {
      log.append(" [");
      log.append(files);
      log.append("]");
    }
    log.append(NL);
    log.append(norm(in));
    log.append(NL);
    final String logStr=log.toString();
    final boolean print=currTime || !logStr.contains("current-");
    boolean correctError=false;
    if (error != null && (outFiles.size() == 0 || expError.length() != 0)) {
      expError=error(pth + outname,expError);
      final String code=error.substring(0,Math.min(8,error.length()));
      for (      final String er : SLASH.split(expError)) {
        if (code.equals(er)) {
          correctError=true;
          break;
        }
      }
    }
    if (correctError) {
      if (print) {
        logOK.append(logStr);
        logOK.append("[Right] ");
        logOK.append(norm(error));
        logOK.append(NL);
        logOK.append(NL);
        addLog(pth,outname + ".log",error);
      }
      ok++;
    }
 else     if (error == null) {
      int s=-1;
      final int rs=result.size();
      while (++s < rs) {
        inspect|=s < cmpFiles.nodes.length && eq(data.atom(cmpFiles.nodes[s]),INSPECT);
        if (result.get(s).equals(out.toString()))         break;
        if (xml || frag) {
          iter.reset();
          String rin=result.get(s).trim();
          if (!doc || frag) {
            if (rin.startsWith("<?xml"))             rin=rin.replaceAll("^<.*?>","");
            rin="<X>" + rin + "</X>";
          }
          final Data rdata=CreateDB.xml(IO.get(rin),context.prop);
          final SeqIter si=new SeqIter();
          int pre=doc ? 0 : 2;
          final int size=rdata.meta.size;
          while (pre < size) {
            final int k=rdata.kind(pre);
            if (k != Data.TEXT || !ws(rdata.atom(pre))) {
              si.add(new DBNode(rdata,pre));
            }
            pre+=rdata.size(pre,k);
          }
          final boolean eq=FNSeq.deep(iter,si);
          rdata.close();
          if (eq)           break;
        }
      }
      if ((rs > 0 || expError.length() != 0) && s == rs && !inspect) {
        if (print) {
          if (outFiles.size() == 0)           result.add(error(pth + outname,expError));
          logErr.append(logStr);
          logErr.append("[" + testid + " ] ");
          logErr.append(norm(result.get(0)));
          logErr.append(NL);
          logErr.append("[Wrong] ");
          logErr.append(norm(out.toString()));
          logErr.append(NL);
          logErr.append(NL);
          addLog(pth,outname + (xml ? ".xml" : ".txt"),out.toString());
        }
        correct=false;
        err++;
      }
 else {
        if (print) {
          logOK.append(logStr);
          logOK.append("[Right] ");
          logOK.append(norm(out.toString()));
          logOK.append(NL);
          logOK.append(NL);
          addLog(pth,outname + (xml ? ".xml" : ".txt"),out.toString());
        }
        ok++;
      }
    }
 else {
      if (outFiles.size() == 0 || expError.length() != 0) {
        if (print) {
          logOK2.append(logStr);
          logOK2.append("[" + testid + " ] ");
          logOK2.append(norm(expError));
          logOK2.append(NL);
          logOK2.append("[Rght?] ");
          logOK2.append(norm(error));
          logOK2.append(NL);
          logOK2.append(NL);
          addLog(pth,outname + ".log",error);
        }
        ok2++;
      }
 else {
        if (print) {
          logErr2.append(logStr);
          logErr2.append("[" + testid + " ] ");
          logErr2.append(norm(result.get(0)));
          logErr2.append(NL);
          logErr2.append("[Wrong] ");
          logErr2.append(norm(error));
          logErr2.append(NL);
          logErr2.append(NL);
          addLog(pth,outname + ".log",error);
        }
        correct=false;
        err2++;
      }
    }
    if (curr != null)     Close.close(context,curr.data);
    xq.close();
  }
  if (reporting) {
    logReport.append("    <test-case name=\"");
    logReport.append(outname);
    logReport.append("\" result='");
    logReport.append(correct ? "pass" : "fail");
    if (inspect)     logReport.append("' todo='inspect");
    logReport.append("'/>");
    logReport.append(NL);
  }
  return single == null || !outname.equals(single);
}
