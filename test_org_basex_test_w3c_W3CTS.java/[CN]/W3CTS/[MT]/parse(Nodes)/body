{
  final String pth=text("@FilePath",root);
  final String outname=text("@name",root);
  String inname=text("*:query/@name",root);
  if (inname == null)   inname=outname;
  if (single != null && !outname.startsWith(single))   return true;
  if (verbose)   BaseX.outln("- " + inname);
  final IO file=IO.get(queries + pth + inname+ ".xq");
  if (!file.exists())   throw new FileNotFoundException(file.toString());
  final String in=read(file);
  String error=null;
  Item item=null;
  final TokenBuilder files=new TokenBuilder();
  final CachedOutput out=new CachedOutput();
  try {
    final Context context=new Context();
    Nodes cont=nodes("*:contextItem",root);
    if (cont.size() != 0)     new Check(sources + string(data.atom(cont.nodes[0])) + IO.XMLSUFFIX).execute(context,out);
    final QueryProcessor xq=new QueryProcessor(in,context.current());
    final QueryContext ctx=xq.ctx;
    ctx.stop=stop;
    files.add(file(nodes("*:input-file",root),nodes("*:input-file/@variable",root),ctx));
    files.add(file(nodes("*:input-URI",root),nodes("*:input-URI/@variable",root),ctx));
    files.add(file(nodes("*:defaultCollection",root),null,ctx));
    var(nodes("*:input-query/@name",root),nodes("*:input-query/@variable",root),pth,ctx);
    String fn=stop2.get(text("*:aux-URI[@role = 'stopwords']",root));
    if (fn != null)     ctx.ftopt.stopwords(IO.get(fn),false,false);
    fn=stem.get(text("*:aux-URI[@role = 'stemming-dictionary']",root));
    if (fn != null)     ctx.ftopt.stemming(IO.get(fn));
    for (    final int p : nodes("*:module",root).nodes) {
      final String ns=text("@namespace",new Nodes(p,data));
      final String f=mods.get(string(data.atom(p))) + ".xq";
      xq.module(ns,f);
    }
    item=xq.eval();
    item.serialize(new XMLSerializer(out));
    xq.close();
  }
 catch (  final QueryException ex) {
    error=ex.getMessage();
    if (error.startsWith("Stopped at")) {
      error=error.substring(error.indexOf('\n') + 1);
    }
    if (error.startsWith("[")) {
      final int i=error.indexOf("]");
      error=error.substring(1).substring(0,i - 1) + error.substring(i + 1);
    }
  }
catch (  final Exception ex) {
    final ByteArrayOutputStream bw=new ByteArrayOutputStream();
    ex.printStackTrace(new PrintStream(bw));
    error=bw.toString();
  }
catch (  final Error ex) {
    final ByteArrayOutputStream bw=new ByteArrayOutputStream();
    ex.printStackTrace(new PrintStream(bw));
    error=bw.toString();
  }
  final Nodes outFiles=nodes("*:output-file/text()",root);
  final Nodes cmpFiles=nodes("*:output-file/@compare",root);
  boolean xml=false;
  StringList result=new StringList();
  for (int o=0; o < outFiles.size(); o++) {
    final String resFile=string(data.atom(outFiles.nodes[o]));
    final IO exp=IO.get(expected + pth + resFile);
    if (!exp.exists())     throw new FileNotFoundException(exp.toString());
    result.add(read(exp));
    final byte[] type=data.atom(cmpFiles.nodes[o]);
    xml|=eq(type,XML) || eq(type,FRAGMENT);
  }
  String expError=text("*:expected-error/text()",root);
  final StringBuilder log=new StringBuilder(pth + inname + ".xq");
  if (files.size != 0) {
    log.append(" [");
    log.append(files);
    log.append("]");
  }
  log.append(Prop.NL);
  log.append(norm(in));
  log.append(Prop.NL);
  final String logStr=log.toString();
  final boolean print=currTime || !logStr.contains("current-") && !logStr.contains("implicit-timezone");
  if (reporting) {
    logFile.append("    <test-case name=\"");
    logFile.append(outname);
    logFile.append("\" result='");
  }
  boolean rightCode=false;
  if (error != null && (outFiles.size() == 0 || expError.length() != 0)) {
    expError=error(pth + outname,expError);
    final String code=error.substring(0,Math.min(8,error.length()));
    for (    final String er : SLASH.split(expError)) {
      if (code.equals(er)) {
        rightCode=true;
        break;
      }
    }
  }
  if (rightCode) {
    if (print) {
      logOK.append(logStr);
      logOK.append("[Right] ");
      logOK.append(norm(error));
      logOK.append(Prop.NL);
      logOK.append(Prop.NL);
      addLog(pth,outname + ".log",error);
    }
    if (reporting)     logFile.append("pass");
    ok++;
  }
 else   if (error == null) {
    boolean inspect=false;
    int s=-1;
    while (++s < result.size) {
      inspect|=s < cmpFiles.nodes.length && eq(data.atom(cmpFiles.nodes[s]),INSPECT);
      xml&=item instanceof Nod;
      if (xml) {
        try {
          final boolean doc=item.type == Type.DOC;
          String rin=result.list[s].trim();
          if (!doc)           rin="<root>" + rin + "</root>";
          final Data rdata=CreateDB.xml(IO.get(rin),null);
          final Item ritem=new DBNode(rdata,doc ? 0 : 2);
          final boolean test=FNSeq.deep(item.iter(),ritem.iter());
          rdata.close();
          if (test)           break;
        }
 catch (        final IOException ex) {
          xml=false;
        }
      }
      if (!xml && result.list[s].equals(out.toString()))       break;
    }
    if (s == result.size && !inspect) {
      if (print) {
        if (outFiles.size() == 0)         result.add(error(pth + outname,expError));
        logErr.append(logStr);
        logErr.append("[" + testid + " ] ");
        logErr.append(norm(result.list[0]));
        logErr.append(Prop.NL);
        logErr.append("[Wrong] ");
        logErr.append(norm(out.toString()));
        logErr.append(Prop.NL);
        logErr.append(Prop.NL);
        final boolean nodes=item instanceof Nod && item.type != Type.TXT;
        addLog(pth,outname + (nodes ? ".xml" : ".txt"),out.toString());
      }
      if (reporting)       logFile.append("fail");
      err++;
    }
 else {
      if (print) {
        logOK.append(logStr);
        logOK.append("[Right] ");
        logOK.append(norm(out.toString()));
        logOK.append(Prop.NL);
        logOK.append(Prop.NL);
        final boolean nodes=item instanceof Nod && item.type != Type.TXT;
        addLog(pth,outname + (nodes ? ".xml" : ".txt"),out.toString());
      }
      if (reporting) {
        logFile.append("pass");
        if (inspect)         logFile.append("' todo='inspect");
      }
      ok++;
    }
  }
 else {
    if (outFiles.size() == 0 || expError.length() != 0) {
      if (print) {
        logOK2.append(logStr);
        logOK2.append("[" + testid + " ] ");
        logOK2.append(norm(expError));
        logOK2.append(Prop.NL);
        logOK2.append("[Rght?] ");
        logOK2.append(norm(error));
        logOK2.append(Prop.NL);
        logOK2.append(Prop.NL);
        addLog(pth,outname + ".log",error);
      }
      if (reporting)       logFile.append("pass");
      ok2++;
    }
 else {
      if (print) {
        logErr2.append(logStr);
        logErr2.append("[" + testid + " ] ");
        logErr2.append(norm(result.list[0]));
        logErr2.append(Prop.NL);
        logErr2.append("[Wrong] ");
        logErr2.append(norm(error));
        logErr2.append(Prop.NL);
        logErr2.append(Prop.NL);
        addLog(pth,outname + ".log",error);
      }
      if (reporting)       logFile.append("fail");
      err2++;
    }
  }
  if (reporting) {
    logFile.append("'/>");
    logFile.append(Prop.NL);
  }
  return single == null || !outname.equals(single);
}
