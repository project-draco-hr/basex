{
  return new Eval(){
    /** 
 * Sorted output tuples. 
 */
    private Value[][] tpls;
    /** 
 * Permutation of the values. 
 */
    private Integer[] perm;
    /** 
 * Current position. 
 */
    int pos;
    @Override public boolean next(    final QueryContext qc) throws QueryException {
      if (tpls == null)       sort(qc);
      if (pos == tpls.length)       return false;
      final int p=perm[pos++];
      final Value[] tuple=tpls[p];
      tpls[p]=null;
      for (int i=0; i < refs.length; i++)       qc.set(refs[i].var,tuple[i],info);
      return true;
    }
    /** 
 * Caches and sorts all incoming tuples.
 * @param qc query context
 * @throws QueryException evaluation exception
 */
    private void sort(    final QueryContext qc) throws QueryException {
      List<Value[]> tuples=new ArrayList<>();
      while (sub.next(qc)) {
        final Item[] key=new Item[keys.length];
        for (int i=0; i < keys.length; i++)         key[i]=keys[i].expr.item(qc,keys[i].info);
        tuples.add(key);
        final Value[] vals=new Value[refs.length];
        for (int i=0; i < refs.length; i++)         vals[i]=refs[i].value(qc);
        tuples.add(vals);
      }
      final int len=tuples.size() >>> 1;
      final Item[][] ks=new Item[len][];
      perm=new Integer[len];
      tpls=new Value[len][];
      for (int i=0; i < len; i++) {
        perm[i]=i;
        tpls[i]=tuples.get(i << 1 | 1);
        ks[i]=(Item[])tuples.get(i << 1);
      }
      tuples=null;
      try {
        Arrays.sort(perm,new Comparator<Integer>(){
          @Override public int compare(          final Integer x,          final Integer y){
            try {
              final Item[] a=ks[x], b=ks[y];
              for (int k=0; k < keys.length; k++) {
                final Key or=keys[k];
                Item m=a[k], n=b[k];
                if (m == Dbl.NAN || m == Flt.NAN)                 m=null;
                if (n == Dbl.NAN || n == Flt.NAN)                 n=null;
                if (m != null && n != null && !m.comparable(n))                 throw Err.castError(or.info,n,m.type);
                final int c=m == null ? n == null ? 0 : or.least ? -1 : 1 : n == null ? or.least ? 1 : -1 : m.diff(n,or.coll,or.info);
                if (c != 0)                 return or.desc ? -c : c;
              }
              return 0;
            }
 catch (            final QueryException ex) {
              throw new QueryRTException(ex);
            }
          }
        }
);
      }
 catch (      final QueryRTException ex) {
        throw ex.getCause();
      }
    }
  }
;
}
