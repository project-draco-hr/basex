{
  final Item it=(expr.length != 0 ? expr[0] : checkCtx(ctx)).atomic(ctx);
  final boolean empty=it == null;
switch (func) {
case NODENAME:
    if (empty)     return null;
  QNm qname=checkNode(it).qname();
return qname != null && qname.atom().length != 0 ? qname : null;
case DOCURI:
if (empty) return null;
final byte[] uri=checkNode(it).base();
return uri.length == 0 ? null : Uri.uri(uri);
case NILLED:
if (empty) return null;
checkNode(it);
return it.type != Type.ELM ? null : Bln.FALSE;
case BASEURI:
if (empty) return null;
Nod n=checkNode(it);
if (n.type != Type.ELM && n.type != Type.DOC && n.parent() == null) return null;
Uri base=Uri.EMPTY;
while (!base.absolute()) {
if (n == null) {
base=ctx.baseURI.resolve(base);
break;
}
base=Uri.uri(n.base()).resolve(base);
n=n.parent();
}
return base;
case NAME:
if (empty) return Str.ZERO;
qname=checkNode(it).qname();
return qname != null ? Str.get(qname.atom()) : Str.ZERO;
case LOCNAME:
if (empty) return Str.ZERO;
qname=checkNode(it).qname();
return qname != null ? Str.get(qname.ln()) : Str.ZERO;
case NSURI:
if (empty || it.type == Type.PI) return Uri.EMPTY;
Nod node=checkNode(it);
while (node != null) {
qname=node.qname();
if (qname == null) break;
if (qname.uri != Uri.EMPTY) return qname.uri;
node=node.parent();
}
return Uri.uri(ctx.nsElem);
case ROOT:
if (empty) return null;
n=checkNode(it);
while (n.parent() != null) n=n.parent();
return n;
case GENID:
return empty ? Str.ZERO : Str.get(new TokenBuilder(QueryTokens.ID).add(checkNode(it).id()).finish());
default :
return super.atomic(ctx);
}
}
