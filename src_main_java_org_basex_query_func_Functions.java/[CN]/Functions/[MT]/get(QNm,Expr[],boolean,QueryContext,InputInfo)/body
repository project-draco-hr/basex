{
  if (eq(name.uri(),XSURI)) {
    final byte[] ln=name.local();
    Type type=ListType.find(name);
    if (type == null)     type=AtomType.find(name,false);
    if (type == null) {
      final Levenshtein ls=new Levenshtein();
      for (      final AtomType t : AtomType.values()) {
        if (t.par != null && t != AtomType.NOT && t != AtomType.AAT && t != AtomType.BIN && ls.similar(lc(ln),lc(t.string()),0))         FUNSIMILAR.thrw(ii,name.string(),t.string());
      }
    }
    if (type == null || type == AtomType.NOT || type == AtomType.AAT) {
      FUNCUNKNOWN.thrw(ii,name.string());
    }
    if (args.length != 1)     FUNCTYPE.thrw(ii,name.string());
    final SeqType to=SeqType.get(type,Occ.ZERO_ONE);
    return TypedFunc.constr(new Cast(ii,args[0],to),to);
  }
  final StandardFunc fun=Functions.get().get(name,args,ii);
  if (fun != null) {
    if (!ctx.sc.xquery3() && fun.xquery3())     FEATURE30.thrw(ii);
    for (    final Function f : Function.UPDATING) {
      if (fun.sig == f) {
        ctx.updating(true);
        break;
      }
    }
    return new TypedFunc(fun,new Ann(),fun.sig.type(args.length));
  }
  final TypedFunc tf=ctx.funcs.getRef(name,args,ctx.sc,ii);
  if (tf != null)   return tf;
  final JavaMapping jf=JavaMapping.get(name,args,ctx,ii);
  if (jf != null)   return TypedFunc.java(jf);
  if (!dyn && FuncType.find(name) == null) {
    return ctx.funcs.getFuncRef(name,args,ctx.sc,ii);
  }
  return null;
}
