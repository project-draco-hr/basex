{
  if (eq(name.uri(),XS_URI)) {
    final Type type=getCast(name,arity,ii);
    final VarScope scp=new VarScope(sc);
    final Var[] args={scp.newLocal(qc,new QNm(ITEMM,""),SeqType.AAT_ZO,true)};
    final Expr e=new Cast(sc,ii,new VarRef(ii,args[0]),type.seqType());
    final FuncType tp=FuncType.get(e.seqType(),SeqType.AAT_ZO);
    return new FuncItem(sc,new Ann(),name,args,tp,e,scp.stackSize());
  }
  final Function fn=get().getBuiltIn(name,arity,ii);
  if (fn != null) {
    final Ann ann=new Ann();
    final VarScope scp=new VarScope(sc);
    final FuncType ft=fn.type(arity,ann);
    final QNm[] argNames=fn.argNames(arity);
    final Var[] args=new Var[arity];
    final Expr[] calls=new Expr[arity];
    for (int i=0; i < arity; i++) {
      args[i]=scp.newLocal(qc,argNames[i],ft.argTypes[i],true);
      calls[i]=new VarRef(ii,args[i]);
    }
    final StandardFunc sf=fn.get(sc,ii,calls);
    if (sf.has(Flag.UPD)) {
      qc.updating();
      ann.add(Ann.Q_UPDATING,Empty.SEQ,ii);
    }
    if (!sf.has(Flag.CTX) && !sf.has(Flag.FCS))     return new FuncItem(sc,ann,name,args,ft,sf,scp.stackSize());
    return new FuncLit(ann,name,args,sf,ft,scp,sc,ii);
  }
  final StaticFunc sf=qc.funcs.get(name,arity,ii,true);
  if (sf != null) {
    final FuncItem fi=getUser(sf,qc,sc,ii);
    if (fi.annotations().contains(Ann.Q_UPDATING))     qc.updating();
    return fi;
  }
  final VarScope scp=new VarScope(sc);
  final FuncType jt=FuncType.arity(arity);
  final Var[] vs=new Var[arity];
  final Expr[] refs=new Expr[vs.length];
  for (int i=0; i < vs.length; i++) {
    vs[i]=scp.newLocal(qc,new QNm(ARG + (i + 1),""),SeqType.ITEM_ZM,true);
    refs[i]=new VarRef(ii,vs[i]);
  }
  final Expr jm=JavaMapping.get(name,refs,qc,sc,ii);
  return jm == null ? null : new FuncLit(new Ann(),name,vs,jm,jt,scp,sc,ii);
}
