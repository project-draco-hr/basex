{
  final TokenSet instVers=new TokenSet();
  for (  final byte[] nextPkg : context.repo.pkgDict().keys())   if (nextPkg != null && startsWith(nextPkg,dep.pkg))   instVers.add(getVersion(nextPkg));
  if (instVers.size() == 0)   return null;
  if (dep.versions != null) {
    final TokenSet versList=new TokenSet();
    for (    final byte[] v : split(dep.versions,' '))     versList.add(v);
    for (    final byte[] v : versList)     if (instVers.id(v) != 0)     return dep.getName(v);
  }
 else   if (dep.semver != null) {
    final PkgVersion semVer=new PkgVersion(dep.semver);
    for (    final byte[] v : instVers)     if (new PkgVersion(v).isCompatible(semVer))     return dep.getName(v);
  }
 else   if (dep.semverMin != null && dep.semverMax != null) {
    final PkgVersion min=new PkgVersion(dep.semverMin);
    final PkgVersion max=new PkgVersion(dep.semverMax);
    for (    final byte[] nextVer : instVers) {
      final PkgVersion v=new PkgVersion(nextVer);
      if (v.compareTo(min) >= 0 && v.compareTo(max) < 0)       return dep.getName(nextVer);
    }
  }
 else   if (dep.semverMin != null) {
    final PkgVersion semVer=new PkgVersion(dep.semverMin);
    for (    final byte[] nextVer : instVers) {
      final PkgVersion v=new PkgVersion(nextVer);
      if (v.isCompatible(semVer) || v.compareTo(semVer) >= 0)       return dep.getName(nextVer);
    }
  }
 else   if (dep.semverMax != null) {
    final PkgVersion semVer=new PkgVersion(dep.semverMax);
    for (    final byte[] nextVer : instVers) {
      final PkgVersion v=new PkgVersion(nextVer);
      if (v.isCompatible(semVer) || v.compareTo(semVer) <= 0)       return dep.getName(nextVer);
    }
  }
 else {
    return dep.getName(instVers.keys()[0]);
  }
  return null;
}
