{
  if (exprs.length != 2)   return this;
  final Expr ks=exprs[0], fs=exprs[1];
  if (ks.isValue() && (fs instanceof Map || fs instanceof Array)) {
    return optPre(value(qc),qc);
  }
  final Type tp=fs.seqType().type;
  if (!(tp instanceof ArrayType || tp instanceof MapType))   return this;
  if (ks != Str.WC) {
    if (fs.size() == 1 || fs.seqType().one()) {
      final Expr opt=ks.size() == 1 || ks.seqType().one() ? new DynFuncCall(info,sc,fs,ks) : Function.FOR_EACH.get(sc,info,exprs);
      return optPre(opt,qc).optimize(qc,scp);
    }
    if (ks.isValue()) {
      final LinkedList<Clause> clauses=new LinkedList<>();
      final Var f=scp.newLocal(qc,new QNm("f"),null,false);
      clauses.add(new For(f,null,null,fs,false,info));
      final Var k=scp.newLocal(qc,new QNm("k"),null,false);
      clauses.add(new For(k,null,null,ks,false,info));
      final VarRef rf=new VarRef(info,f), rk=new VarRef(info,k);
      final DynFuncCall ret=new DynFuncCall(info,sc,rf,rk);
      return optPre(new GFLWOR(info,clauses,ret),qc).optimize(qc,scp);
    }
  }
  return this;
}
