{
  final Expr e=expr[0];
switch (def) {
case CODESTR:
    return cp2str(ctx.iter(e));
case COMPARE:
  if (expr.length == 3)   checkColl(expr[2],ctx);
Item it1=e.item(ctx,input);
Item it2=expr[1].item(ctx,input);
if (it1 == null || it2 == null) return null;
final int d=diff(checkEStr(it1),checkEStr(it2));
return Itr.get(Math.max(-1,Math.min(1,d)));
case CODEPNT:
it1=e.item(ctx,input);
it2=expr[1].item(ctx,input);
if (it1 == null || it2 == null) return null;
return Bln.get(eq(checkEStr(it1),checkEStr(it2)));
case STRJOIN:
return strjoin(ctx);
case SUBSTR:
return substr(ctx);
case NORMUNI:
return normuni(ctx);
case UPPER:
return Str.get(uc(checkEStr(e,ctx)));
case LOWER:
return Str.get(lc(checkEStr(e,ctx)));
case TRANS:
return trans(ctx);
case ENCURI:
return Str.get(uri(checkEStr(e,ctx),false));
case IRIURI:
return Str.get(uri(checkEStr(e,ctx),true));
case ESCURI:
return Str.get(escape(checkEStr(e,ctx)));
case CONCAT:
return concat(ctx);
case CONTAINS:
if (expr.length == 3) checkColl(expr[2],ctx);
Item it=expr[1].item(ctx,input);
if (it == null) return Bln.TRUE;
return Bln.get(contains(checkEStr(e,ctx),checkEStr(it)));
case STARTS:
if (expr.length == 3) checkColl(expr[2],ctx);
it=expr[1].item(ctx,input);
if (it == null) return Bln.TRUE;
return Bln.get(startsWith(checkEStr(e,ctx),checkEStr(it)));
case ENDS:
if (expr.length == 3) checkColl(expr[2],ctx);
it=expr[1].item(ctx,input);
if (it == null) return Bln.TRUE;
return Bln.get(endsWith(checkEStr(e,ctx),checkEStr(it)));
case SUBAFTER:
if (expr.length == 3) checkColl(expr[2],ctx);
final byte[] str=checkEStr(e,ctx);
final byte[] sa=checkEStr(expr[1],ctx);
final int pa=indexOf(str,sa);
return pa != -1 ? Str.get(substring(str,pa + sa.length)) : Str.ZERO;
case SUBBEFORE:
if (expr.length == 3) checkColl(expr[2],ctx);
final byte[] sb=checkEStr(e,ctx);
final int pb=indexOf(sb,checkEStr(expr[1],ctx));
return pb > 0 ? Str.get(substring(sb,0,pb)) : Str.ZERO;
default :
return super.item(ctx,ii);
}
}
