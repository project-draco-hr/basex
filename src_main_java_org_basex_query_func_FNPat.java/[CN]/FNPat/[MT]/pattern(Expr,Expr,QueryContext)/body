{
  byte[] pt=checkStr(pattern,ctx);
  int m=Pattern.UNIX_LINES;
  if (mod != null) {
    for (    final byte b : checkStr(mod,ctx)) {
      if (b == 'i')       m|=Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
 else       if (b == 'm')       m|=Pattern.MULTILINE;
 else       if (b == 's')       m|=Pattern.DOTALL;
 else       if (b == 'q' && ctx.xquery3)       m|=Pattern.LITERAL;
 else       if (b == 'x') {
        boolean cc=false;
        final ByteList bl=new ByteList();
        for (        final byte p : pt) {
          if (cc || p < 0 || p > ' ')           bl.add(p);
          cc|=p == '[';
          cc&=p != ']';
        }
        pt=bl.toArray();
      }
 else {
        REGMOD.thrw(input,(char)b);
      }
    }
  }
  final ByteList bl=new ByteList();
  for (int i=0; i < pt.length; ++i) {
    final byte b=pt[i];
    bl.add(b);
    if (b == '\\' && i + 1 != pt.length && pt[i + 1] == ' ')     bl.add(b);
  }
  String str=bl.toString();
  if ((m & Pattern.LITERAL) == 0 && str.indexOf('[') != -1 && str.indexOf('-') != -1) {
    while (true) {
      final Matcher mt=CLASSES.matcher(str);
      if (!mt.matches())       break;
      final char c1=mt.group(1).charAt(0);
      final char c2=mt.group(2).charAt(0);
      final TokenBuilder tb2=new TokenBuilder("[");
      for (char c=c1; c <= c2; ++c)       tb2.add(c);
      str=str.replaceAll("\\[" + c1 + "-"+ c2,tb2.toString());
    }
    while (true) {
      final Matcher mt=EXCLASSES.matcher(str);
      if (!mt.matches())       break;
      final String in=mt.group(1);
      final String ex=mt.group(2);
      String out=in;
      for (int e=0; e < ex.length(); ++e) {
        out=out.replaceAll(ex.substring(e,e + 1),"");
      }
      str=str.replaceAll("\\[" + in + "-\\[.*?\\]","[" + out);
    }
  }
  try {
    return Pattern.compile(str,m);
  }
 catch (  final Exception ex) {
    throw REGINV.thrw(input,pt);
  }
}
