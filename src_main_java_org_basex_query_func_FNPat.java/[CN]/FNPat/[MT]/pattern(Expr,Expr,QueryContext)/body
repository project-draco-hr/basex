{
  byte[] pt=checkStr(pattern,ctx);
  int m=Pattern.UNIX_LINES;
  if (mod != null) {
    for (    final byte b : checkStr(mod,ctx)) {
      if (b == 'i')       m|=Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
 else       if (b == 'm')       m|=Pattern.MULTILINE;
 else       if (b == 's')       m|=Pattern.DOTALL;
 else       if (b == 'q')       m|=Pattern.LITERAL;
 else       if (b == 'x') {
        boolean cc=false;
        final TokenBuilder tb=new TokenBuilder();
        for (        final byte p : pt) {
          if (cc || p < 0 || p > ' ')           tb.add(p);
          cc|=p == '[';
          cc&=p != ']';
        }
        pt=tb.finish();
      }
 else {
        Err.or(input,REGMOD,(char)b);
      }
    }
  }
  final TokenBuilder tb=new TokenBuilder();
  for (int i=0; i < pt.length; i++) {
    final byte b=pt[i];
    tb.add(b);
    if (b == '\\' && i + 1 != pt.length && pt[i + 1] == ' ')     tb.add(b);
  }
  String str=tb.toString();
  if (str.indexOf('[') != -1 && str.indexOf('-') != -1) {
    while (true) {
      final Matcher mt=CLASSES.matcher(str);
      if (!mt.matches())       break;
      final char c1=mt.group(1).charAt(0);
      final char c2=mt.group(2).charAt(0);
      if (c1 < c2) {
        final TokenBuilder sb=new TokenBuilder("[");
        for (char c=c1; c <= c2; c++)         sb.add(c);
        str=str.replaceAll("\\[" + c1 + "-"+ c2,sb.toString());
      }
    }
    while (true) {
      final Matcher mt=EXCLASSES.matcher(str);
      if (!mt.matches())       break;
      final String in=mt.group(1);
      final String ex=mt.group(2);
      String out=in;
      for (int e=0; e < ex.length(); e++) {
        out=out.replaceAll(ex.substring(e,e + 1),"");
      }
      str=str.replaceAll("\\[" + in + "-\\[.*?\\]","[" + out);
    }
  }
  try {
    return Pattern.compile(str,m);
  }
 catch (  final Exception ex) {
    Err.or(input,REGINV,pt);
    return null;
  }
}
