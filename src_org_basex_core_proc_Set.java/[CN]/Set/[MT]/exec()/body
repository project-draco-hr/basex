{
  final String option=cmd.arg(0).toLowerCase();
  final String ext=cmd.arg(1);
  if (option.equals(CHOP)) {
    Prop.chop=toggle(Prop.chop,INFOCHOP,ext);
  }
 else   if (option.equals(DEBUG)) {
    Prop.debug=toggle(Prop.debug,INFODEBUG,ext);
  }
 else   if (option.equals(ENTITY)) {
    Prop.entity=toggle(Prop.entity,INFOENTITIES,ext);
  }
 else   if (option.equals(FTINDEX)) {
    Prop.ftindex=toggle(Prop.ftindex,INFOFTINDEX,ext);
  }
 else   if (option.equals(TXTINDEX)) {
    Prop.textindex=toggle(Prop.textindex,INFOTXTINDEX,ext);
  }
 else   if (option.equals(ATTRINDEX)) {
    Prop.attrindex=toggle(Prop.attrindex,INFOATVINDEX,ext);
  }
 else   if (option.equals(FCOMPRESS)) {
    Prop.fcompress=toggle(Prop.fcompress,INFOFTCOMPRESS,ext);
  }
 else   if (option.equals(MAINMEM)) {
    Prop.mainmem=toggle(Prop.mainmem,INFOMM,ext);
  }
 else   if (option.equals(RUNS)) {
    Prop.runs=Math.max(1,Token.toInt(ext));
    info(INFORUNS + " " + Prop.runs);
  }
 else   if (option.equals(SERIALIZE)) {
    Prop.serialize=toggle(Prop.serialize,INFOSERIALIZE,ext);
  }
 else   if (option.equals(INFO)) {
    Prop.allInfo=ext.equalsIgnoreCase(ALL);
    if (Prop.allInfo)     info(INFOINFO + " " + INFOON+ " ("+ INFOALL+ ")");
    Prop.info=Prop.allInfo ? true : toggle(Prop.info,INFOINFO,ext);
  }
 else   if (option.equals(XMLOUTPUT)) {
    Prop.xmloutput=toggle(Prop.xmloutput,INFOXMLOUTPUT,ext);
  }
 else   if (option.equals(DBPATH)) {
    if (!new IO(ext).exists())     return error(INFOPATHERR + ext);
    Prop.dbpath=ext;
    info(INFONEWPATH + " " + ext);
  }
 else {
    try {
      final Field f=Prop.class.getField(option);
      final Object o=f.get(null);
      if (o instanceof Boolean) {
        f.setBoolean(null,toggle(((Boolean)o).booleanValue(),option,ext));
      }
 else       if (o instanceof String) {
        f.set(null,ext);
        info(option + ": " + ext);
      }
 else       if (o instanceof Integer) {
        f.setInt(null,Integer.parseInt(ext));
        info(option + ": " + ext);
      }
 else {
        throw new Exception();
      }
    }
 catch (    final Exception ex) {
      throw new IllegalArgumentException();
    }
  }
  return true;
}
