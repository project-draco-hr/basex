{
  final Picture[] pics=new Picture[patterns.length];
  for (int s=0; s < patterns.length; ++s) {
    final byte[] pt=patterns[s];
    final Picture pic=new Picture();
    int p=0;
    boolean act=false;
    int exp=-1;
    final int[] opt=new int[2];
    final int pl=pt.length;
    for (int i=0, cl; i < pl; i+=cl) {
      final int ch=ch(pt,i);
      cl=cl(pt,i);
      boolean active=contains(actives,ch);
      if (ch == decimal) {
        ++p;
        act=false;
      }
 else       if (ch == optional) {
        opt[p]++;
      }
 else       if (ch == exponent) {
        boolean e=true;
        for (int c=i + cl; c < pl && e; c+=cl(pt,c))         e=contains(digits,ch(pt,c));
        if (e && i + cl < pl) {
          exp=0;
        }
 else {
          pic.xyzfix[p == 0 && act ? p + 1 : p].add(ch);
          active=false;
        }
      }
 else       if (ch == grouping) {
        if (p == 0)         pic.group[p]=Array.add(pic.group[p],pic.min[p] + opt[p]);
      }
 else       if (contains(digits,ch)) {
        if (exp == -1)         pic.min[p]++;
 else         exp++;
      }
 else {
        pic.pc|=ch == percent;
        pic.pm|=ch == permille;
        pic.xyzfix[p == 0 && act ? p + 1 : p].add(ch);
      }
      act|=active;
    }
    final int[] igp=pic.group[0];
    final int igl=igp.length;
    for (int g=0; g < igl; ++g)     igp[g]=pic.min[0] + opt[0] - igp[g];
    if (igl > 1) {
      boolean reg=true;
      final int i=igp[igl - 1];
      for (int g=igl - 2; g >= 0; --g)       reg&=i * igl == igp[g];
      if (reg)       pic.group[0]=new int[]{i};
    }
    pic.maxFrac=pic.min[1] + opt[1];
    pic.minExp=Math.max(0,exp);
    pics[s]=pic;
  }
  return pics;
}
