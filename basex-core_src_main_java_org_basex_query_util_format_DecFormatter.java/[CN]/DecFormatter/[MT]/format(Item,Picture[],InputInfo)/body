{
  final double d=it.dbl(ii);
  if (Double.isNaN(d))   return nan;
  final boolean neg=d < 0 || d == 0 && Double.doubleToLongBits(d) == Long.MIN_VALUE;
  final Picture pic=pics[neg && pics.length == 2 ? 1 : 0];
  final TokenBuilder res=new TokenBuilder();
  final TokenBuilder intgr=new TokenBuilder();
  final TokenBuilder fract=new TokenBuilder();
  if (d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
    intgr.add(inf);
  }
 else {
    Item num=it;
    if (pic.pc)     num=Calc.MULT.ev(ii,num,Int.get(100));
    if (pic.pm)     num=Calc.MULT.ev(ii,num,Int.get(1000));
    num=FNNum.abs(FNNum.round(num,num.dbl(ii),pic.maxFrac,true,ii),ii);
    final String s=(num instanceof Dbl || num instanceof Flt ? Dec.get(num.dbl(ii)) : num).toString();
    final int sep=s.indexOf('.');
    final int sl=s.length();
    final int il=sep == -1 ? sl : sep;
    for (int i=il; i < pic.min[0]; ++i)     intgr.add(zero);
    for (int i=0; i < il; i++)     intgr.add(zero + s.charAt(i) - '0');
    if (pic.group[0].length == 1) {
      final int pos=pic.group[0][0];
      for (int p=intgr.size() - (neg ? 2 : 1); p > 0; --p) {
        if (p % pos == 0)         intgr.insert(intgr.size() - p,grouping);
      }
    }
 else {
      for (int i=0; i < pic.group[0].length; ++i) {
        final int pos=intgr.size() - pic.group[0][i];
        if (pos > 0)         intgr.insert(pos,grouping);
      }
    }
    final int fl=sep == -1 ? 0 : sl - il - 1;
    if (fl != 0)     for (int i=sep + 1; i < sl; i++)     fract.add(zero + s.charAt(i) - '0');
    for (int i=fl; i < pic.min[1]; ++i)     fract.add(zero);
    final int ul=fract.size();
    for (int p=pic.group[1].length - 1; p >= 0; p--) {
      final int pos=pic.group[1][p];
      if (pos < ul)       fract.insert(pos,grouping);
    }
  }
  if (neg && pics.length != 2)   res.add(minus);
  res.add(pic.fix[0].toArray()).add(intgr.finish());
  if (!fract.isEmpty())   res.add(decimal).add(fract.finish());
  return res.add(pic.fix[1].toArray()).finish();
}
