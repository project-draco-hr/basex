{
  final int s=consume('/') ? consume('/') ? 2 : 1 : 0;
  final Expr ex=step(false,false,false);
  if (ex == null) {
    if (s == 1)     absPath(true,false,true,null,null);
    if (s == 2)     absPath(true,true,true,null,null);
    if (s > 1)     error(PATHMISS);
    return s == 0 ? null : new Root();
  }
  final boolean slash=consume('/');
  final boolean step=ex instanceof Step;
  if (!slash && s == 0 && !step)   return ex;
  Expr[] list={};
  if (s == 2)   list=add(list,descOrSelf());
  final Expr root=s > 0 ? new Root() : !step ? ex : null;
  if (root != ex)   list=add(list,ex);
  if (slash) {
    do {
      boolean desc=false;
      if (consume('/')) {
        list=add(list,descOrSelf());
        desc=true;
      }
      final Expr st=check(step(false,desc,true),PATHMISS);
      if (!(st instanceof Context))       list=add(list,st);
    }
 while (consume('/'));
  }
  if (list.length == 0)   return new MixedPath(root,new Context());
  boolean axes=true;
  final Step[] tmp=new Step[list.length];
  for (int l=0; l < list.length; l++) {
    axes&=list[l] instanceof Step;
    if (axes)     tmp[l]=(Step)list[l];
  }
  return axes ? AxisPath.get(root,tmp) : new MixedPath(root,list);
}
