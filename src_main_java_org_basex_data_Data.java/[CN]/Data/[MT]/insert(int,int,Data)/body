{
  meta.update();
  docindex.insert(ipre,data);
  final boolean dummy=empty() && data.kind(0) == DOC;
  final int dsize=data.meta.size;
  final int buf=Math.min(dsize,IO.BLOCKSIZE >> IO.NODEPOWER);
  buffer(buf);
  final TokenMap nsScope=new TokenMap();
  NSNode n=ns.current;
  do {
    for (int i=0; i < n.vals.length; i+=2)     nsScope.add(ns.pref(n.vals[i]),ns.uri(n.vals[i + 1]));
    final int pos=n.fnd(ipar);
    if (pos < 0)     break;
    n=n.ch[pos];
  }
 while (n.pre <= ipar && ipar < n.pre + size(n.pre,ELEM));
  final IntList preStack=new IntList();
  int dpre=-1;
  final NSNode t=ns.current;
  final Set<NSNode> newNodes=new HashSet<NSNode>();
  final IntList flagPres=new IntList();
  while (++dpre != dsize) {
    if (dpre != 0 && dpre % buf == 0)     insert(ipre + dpre - buf);
    final int pre=ipre + dpre;
    final int dkind=data.kind(dpre);
    final int dpar=data.parent(dpre,dkind);
    final int dis=dpar >= 0 ? dpre - dpar : pre - ipar;
    final int par=pre - dis;
    if (dpre == 0) {
      final List<NSNode> cand=new LinkedList<NSNode>();
      NSNode cn=ns.root;
      cand.add(cn);
      for (int cI; (cI=cn.fnd(par)) > -1; ) {
        cn=cn.ch[cI];
        cand.add(0,cn);
      }
      cn=ns.root;
      if (cand.size() > 1) {
        int ancPre=par;
        NSNode curr=cand.remove(0);
        while (ancPre > -1 && cn == ns.root) {
          if (curr.pre == ancPre)           cn=curr;
 else           if (curr.pre < ancPre) {
            while ((ancPre=parent(ancPre,kind(ancPre))) > curr.pre)             ;
            if (curr.pre == ancPre)             cn=curr;
          }
          if (cand.size() > 0)           curr=cand.remove(0);
        }
      }
      ns.setNearestRoot(cn,par);
    }
    while (preStack.size() != 0 && preStack.peek() > par)     ns.close(preStack.pop());
switch (dkind) {
case DOC:
      final int s=data.size(dpre,dkind);
    doc(pre,s,data.text(dpre,true));
  meta.ndocs++;
ns.open();
preStack.push(pre);
break;
case ELEM:
boolean ne=false;
if (data.nsFlag(dpre)) {
final Atts at=data.ns(dpre);
for (int a=0; a < at.size; ++a) {
final byte[] old=nsScope.get(at.key[a]);
if (old == null || !eq(old,at.val[a])) {
newNodes.add(ns.add(at.key[a],at.val[a],pre));
ne=true;
}
}
}
ns.open();
byte[] nm=data.name(dpre,dkind);
elem(dis,tagindex.index(nm,null,false),data.attSize(dpre,dkind),data.size(dpre,dkind),ns.uri(nm,true),ne);
preStack.push(pre);
break;
case TEXT:
case COMM:
case PI:
text(pre,dis,data.text(dpre,true),dkind);
break;
case ATTR:
nm=data.name(dpre,dkind);
final byte[] attPref=pref(nm);
if (data.nsFlag(dpre) && (nsScope.get(attPref) == null)) {
ns.add(par,preStack.size() == 0 ? -1 : preStack.peek(),attPref,data.ns.uri(data.uri(dpre,dkind)));
flagPres.add(par);
}
attr(pre,dis,atnindex.index(nm,null,false),data.text(dpre,false),ns.uri(nm,false),false);
break;
}
}
while (preStack.size() != 0) ns.close(preStack.pop());
ns.setRoot(t);
if (bp != 0) insert(ipre + dpre - 1 - (dpre - 1) % buf);
buffer(1);
for (final int toFlag : flagPres.toArray()) table.write2(toFlag,1,name(toFlag) | 1 << 15);
int p=ipar;
while (p >= 0) {
final int k=kind(p);
size(p,k,size(p,k) + dsize);
p=parent(p,k);
}
updateDist(ipre + dsize,dsize);
ns.update(ipre,dsize,true,newNodes);
if (dummy) delete(0);
}
