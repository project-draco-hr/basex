{
  boolean txtindex=data.meta.txtindex;
  boolean atvindex=data.meta.atvindex;
  boolean ftxindex=data.meta.ftxindex;
  data.noIndex();
  data.tags.stats=true;
  data.atts.stats=true;
  final int[] parStack=new int[256];
  final int[] tagStack=new int[256];
  int h=0;
  int l=0;
  size=data.size;
  for (pre=0; pre < size; pre++) {
    final byte kind=(byte)data.kind(pre);
    final int par=data.parent(pre,kind);
    while (l > 0 && parStack[l - 1] > par)     --l;
    if (kind == Data.ELEM) {
      final int id=data.tagID(pre);
      data.tags.index(data.tags.key(id),null);
      tagStack[l]=id;
      parStack[l]=pre;
      if (h < ++l)       h=l;
      data.skel.add(id,l,Data.ELEM);
    }
 else     if (kind == Data.ATTR) {
      final int id=data.attNameID(pre);
      data.atts.index(data.atts.key(id),data.attValue(pre));
      data.skel.add(id,l + 1,Data.ATTR);
    }
 else     if (kind == Data.TEXT || kind == Data.DOC) {
      if (l > 0)       data.tags.index(tagStack[l - 1],data.text(pre));
      data.skel.add(0,l,kind);
    }
  }
  data.meta.height=h;
  data.meta.newindex=false;
  data.meta.txtindex=txtindex;
  data.meta.atvindex=atvindex;
  data.meta.ftxindex=ftxindex;
  data.tags.stats=true;
  data.atts.stats=true;
  try {
    index(data);
  }
 catch (  final IOException e) {
    BaseX.debug(e);
  }
  data.flush();
  return true;
}
