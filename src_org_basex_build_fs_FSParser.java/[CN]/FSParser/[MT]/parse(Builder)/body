{
  builder=build;
  builder.encoding(Prop.ENCODING);
  builder.meta.backing=backingpath;
  builder.meta.mount=mountpoint;
  final boolean fuse=prop.is(Prop.FUSE);
  if (fuse && !singlemode) {
    final File bs=new File(backingpath);
    if (!bs.mkdirs() && bs.exists())     throw new IOException(BACKINGEXISTS + backingpath);
  }
  builder.startDoc(token(io.name()));
  if (singlemode) {
    file(new File(io.path()).getCanonicalFile());
  }
 else {
    final byte[] mnt=fuse ? token(mountpoint) : NOTMOUNTED;
    final byte[] bck=fuse ? token(backingpath) : token(fsimportpath);
    atts.reset();
    atts.add(MOUNTPOINT,mnt);
    atts.add(SIZE,Token.EMPTY);
    atts.add(BACKINGSTORE,bck);
    builder.startNS(FSPREF,FSURL);
    if (prop.is(Prop.FSMETA)) {
      builder.startNS(FSMETAPREF,FSMETAURL);
    }
    builder.startElem(DEEPFS,atts);
    for (    final File f : root ? File.listRoots() : new File[]{new File(fsimportpath).getCanonicalFile()}) {
      importRootLength=f.getAbsolutePath().length();
      sizeStack[0]=0;
      parse(f);
      builder.setAttValue(preStack[0] + SIZEOFFSET,token(sizeStack[0]));
    }
    builder.endElem(DEEPFS);
  }
  builder.endDoc();
}
