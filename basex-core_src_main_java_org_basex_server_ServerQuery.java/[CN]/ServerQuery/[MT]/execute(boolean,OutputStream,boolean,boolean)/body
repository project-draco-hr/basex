{
  try {
    ctx.register(parse());
    qp.compile();
    final QueryInfo qi=qp.qc.info;
    qi.compiling=perf.time();
    final Iter ir=qp.iter();
    qi.evaluating=perf.time();
    parameters();
    final PrintOutput po=PrintOutput.get(encode ? new EncodingOutput(out) : out);
    final Serializer ser=Serializer.get(po,full ? null : parameters);
    int c=0;
    for (Item it; (it=ir.next()) != null; ) {
      if (iter) {
        po.write(full ? it.xdmInfo() : it.typeId().bytes());
        ser.reset();
        ser.serialize(it,full,true);
        po.flush();
        out.write(0);
      }
 else {
        ser.serialize(it,full,false);
      }
      c++;
    }
    ser.close();
    qi.serializing=perf.time();
    info=qi.toString(qp,po.size(),c,ctx.options.get(MainOptions.QUERYINFO));
  }
 catch (  final QueryException ex) {
    throw new BaseXException(ex);
  }
catch (  final StackOverflowError ex) {
    Util.debug(ex);
    throw new BaseXException(BASX_STACKOVERFLOW.desc);
  }
catch (  final ProcException ex) {
    throw new BaseXException(TIMEOUT_EXCEEDED);
  }
 finally {
    if (qp != null) {
      qp.close();
      if (parsed) {
        ctx.unregister(qp);
        parsed=false;
      }
      qp=null;
    }
  }
}
