{
  if (!hist.active() || control(e) || DELNEXT.is(e)|| DELPREV.is(e)|| ESCAPE.is(e))   return;
  final byte[] txt=text.text();
  final int pc=text.getCaret();
  text.pos(pc);
  String ch=String.valueOf(e.getKeyChar());
  boolean indent=false;
  if (TAB.is(e)) {
    if (text.selected()) {
      final int s=Math.min(text.pos(),text.start());
      final int l=Math.max(text.pos(),text.start()) - 1;
      int p=s;
      for (; p <= l && p < txt.length; p++)       indent|=txt[p] != '\n';
      indent|=p == txt.length;
      if (indent) {
        text.indent(s,l,e.isShiftDown());
        ch=null;
      }
    }
 else {
      boolean c=true;
      for (int p=text.pos() - 1; p >= 0 && c; p--) {
        final byte b=txt[p];
        c=ws(b);
        if (b == '\n')         break;
      }
      if (c)       ch="  ";
    }
  }
  if (text.selected() && !indent)   text.delete();
  if (ENTER.is(e)) {
    final StringBuilder sb=new StringBuilder(1).append(e.getKeyChar());
    int s=0;
    for (int p=text.pos() - 1; p >= 0; p--) {
      final byte b=txt[p];
      if (b == '\n')       break;
      if (b == '\t') {
        s+=2;
      }
 else       if (b == ' ') {
        s++;
      }
 else {
        s=0;
      }
    }
    for (int p=0; p < s; p++)     sb.append(' ');
    ch=sb.toString();
  }
  if (ch != null)   text.add(ch);
  text.setCaret();
  hist.store(text.text(),pc,text.getCaret());
  calcCode.invokeLater(true);
  e.consume();
}
