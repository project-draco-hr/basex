{
  if (gui.updating || opened == null)   return;
  super.keyPressed(e);
  int focus=focusedPos == -1 ? 0 : focusedPos;
  if (gui.context.focused == -1)   gui.context.focused=0;
  final int focusPre=gui.context.focused;
  final Data data=gui.context.data;
  int kind=data.kind(focusPre);
  final boolean fs=data.fs != null;
  final boolean right=NEXT.is(e);
  boolean down=NEXTLINE.is(e);
  boolean up=PREVLINE.is(e);
  if (right || PREV.is(e)) {
    if (e.isShiftDown()) {
      opened[focusPre]=right;
      final int s=data.meta.size;
      for (int pre=focusPre + (fs ? data.attSize(focusPre,kind) : 1); pre != s && data.parent(pre,data.kind(pre)) >= focusPre; pre+=fs ? data.attSize(pre,kind) : 1) {
        opened[pre]=right;
        kind=data.kind(pre);
      }
      refreshHeight();
      repaint();
      return;
    }
    if (right ^ opened[focusPre] && (!ViewData.isLeaf(gui.prop,data,focusPre) || data.attSize(focusPre,kind) > 1)) {
      opened[focusPre]=right;
      refreshHeight();
      repaint();
    }
 else     if (right) {
      down=true;
    }
 else {
      up=true;
    }
  }
  if (down) {
    focus=Math.min(data.meta.size - 1,focus + 1);
  }
 else   if (up) {
    focus=Math.max(0,focus - 1);
  }
 else   if (NEXTPAGE.is(e)) {
    focus=Math.min(data.meta.size - 1,focus + getHeight() / lineH);
  }
 else   if (PREVPAGE.is(e)) {
    focus=Math.max(0,focus - getHeight() / lineH);
  }
 else   if (TEXTSTART.is(e)) {
    focus=0;
  }
 else   if (TEXTEND.is(e)) {
    focus=data.meta.size - 1;
  }
  if (focus == focusedPos)   return;
  gui.context.focused=-1;
  final Nodes curr=gui.context.current;
  int pre=curr.nodes[0];
  final FolderIterator it=new FolderIterator(this);
  while (it.more() && focus-- != 0)   pre=it.pre;
  if (pre == curr.nodes[0] && down)   ++pre;
  gui.notify.focus(pre,this);
  jumpTo(pre,false);
  repaint();
}
