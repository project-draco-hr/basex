{
  byte[] b=c;
  if (b.length == 0)   b=DEFC;
  b=CANONICALIZATIONS.get(lc(b));
  if (b == null)   CRYPTOCANINV.thrw(input,c);
  final String canonicalization=string(b);
  b=d;
  if (b.length == 0)   b=DEFD;
  b=DIGESTS.get(lc(b));
  if (b == null)   CRYPTODIGINV.thrw(input,d);
  final String digest=string(b);
  b=sig;
  if (b.length == 0)   b=DEFS;
  final byte[] tsig=b;
  b=SIGNATURES.get(lc(b));
  if (b == null)   CRYPTOSIGINV.thrw(input,sig);
  final String signature=string(b);
  final String keytype=string(tsig).substring(0,3);
  b=t;
  if (b.length == 0)   b=DEFT;
  final int ti=TYPES.id(lc(b));
  if (ti == 0)   CRYPTOSIGTYPINV.thrw(input,t);
  final byte[] type=b;
  ANode signedNode=null;
  try {
    final XMLSignatureFactory fac=XMLSignatureFactory.getInstance("DOM");
    PrivateKey pk;
    PublicKey puk;
    KeyInfo ki;
    if (ce != null) {
      String ksTY=null;
      String ksPW=null;
      String kAlias=null;
      String pkPW=null;
      String ksURI=null;
      final Document ceDOM=toDOMNode(ce);
      if (!ceDOM.getDocumentElement().getNodeName().equals("digital-certificate"))       CRYPTOINVNM.thrw(input,ceDOM);
      final NodeList ceChildren=ceDOM.getDocumentElement().getChildNodes();
      final int s=ceChildren.getLength();
      int ci=0;
      while (ci < s) {
        final Node cn=ceChildren.item(ci++);
        final String name=cn.getNodeName();
        if (name.equals("keystore-type"))         ksTY=cn.getTextContent();
 else         if (name.equals("keystore-password"))         ksPW=cn.getTextContent();
 else         if (name.equals("key-alias"))         kAlias=cn.getTextContent();
 else         if (name.equals("private-key-password"))         pkPW=cn.getTextContent();
 else         if (name.equals("keystore-uri"))         ksURI=cn.getTextContent();
      }
      final KeyStore ks=KeyStore.getInstance(ksTY);
      if (ks == null)       CRYPTOKSNULL.thrw(input,ks);
      ks.load(new FileInputStream(ksURI),ksPW.toCharArray());
      pk=(PrivateKey)ks.getKey(kAlias,pkPW.toCharArray());
      final X509Certificate x509ce=(X509Certificate)ks.getCertificate(kAlias);
      if (x509ce == null)       CRYPTOALINV.thrw(input,kAlias);
      puk=x509ce.getPublicKey();
      final KeyInfoFactory kifactory=fac.getKeyInfoFactory();
      final KeyValue keyValue=kifactory.newKeyValue(puk);
      final Vector<XMLStructure> kiCont=new Vector<XMLStructure>();
      kiCont.add(keyValue);
      final List<Object> x509Content=new ArrayList<Object>();
      final X509IssuerSerial issuer=kifactory.newX509IssuerSerial(x509ce.getIssuerX500Principal().getName(),x509ce.getSerialNumber());
      x509Content.add(x509ce.getSubjectX500Principal().getName());
      x509Content.add(issuer);
      x509Content.add(x509ce);
      final X509Data x509Data=kifactory.newX509Data(x509Content);
      kiCont.add(x509Data);
      ki=kifactory.newKeyInfo(kiCont);
    }
 else {
      final KeyPairGenerator gen=KeyPairGenerator.getInstance(keytype);
      gen.initialize(512);
      final KeyPair kp=gen.generateKeyPair();
      final KeyInfoFactory kif=fac.getKeyInfoFactory();
      final KeyValue kv=kif.newKeyValue(kp.getPublic());
      ki=kif.newKeyInfo(Collections.singletonList(kv));
      pk=kp.getPrivate();
    }
    final Document inputNode=toDOMNode(node);
    List<Transform> tfList;
    if (expr.length > 0) {
      final XPathFactory xpf=XPathFactory.newInstance();
      final XPathExpression xExpr=xpf.newXPath().compile(string(expr));
      final NodeList xRes=(NodeList)xExpr.evaluate(inputNode,XPathConstants.NODESET);
      if (xRes.getLength() < 1)       CRYPTOXPINV.thrw(input,expr);
      tfList=new ArrayList<Transform>(2);
      tfList.add(fac.newTransform(Transform.XPATH,new XPathFilterParameterSpec(string(expr))));
      tfList.add(fac.newTransform(Transform.ENVELOPED,(TransformParameterSpec)null));
    }
 else {
      tfList=Collections.singletonList(fac.newTransform(Transform.ENVELOPED,(TransformParameterSpec)null));
    }
    final Reference ref=fac.newReference("",fac.newDigestMethod(digest,null),tfList,null,null);
    final SignedInfo si=fac.newSignedInfo(fac.newCanonicalizationMethod(canonicalization,(C14NMethodParameterSpec)null),fac.newSignatureMethod(signature,null),Collections.singletonList(ref));
    DOMSignContext signContext;
    XMLSignature xmlSig;
    if (eq(type,DEFT)) {
      signContext=new DOMSignContext(pk,inputNode.getDocumentElement());
      xmlSig=fac.newXMLSignature(si,ki);
    }
 else {
      final DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
      dbf.setNamespaceAware(true);
      final XMLStructure cont=new DOMStructure(inputNode.getDocumentElement());
      final XMLObject obj=fac.newXMLObject(Collections.singletonList(cont),"",null,null);
      xmlSig=fac.newXMLSignature(si,ki,Collections.singletonList(obj),null,null);
      signContext=new DOMSignContext(pk,inputNode);
    }
    if (ns.length > 0)     signContext.setDefaultNamespacePrefix(new String(ns));
    xmlSig.sign(signContext);
    signedNode=toDBNode(inputNode);
  }
 catch (  final XPathExpressionException e) {
    CRYPTOXPINV.thrw(input,e);
  }
catch (  final SAXException e) {
    CRYPTOIOEXC.thrw(input,e);
  }
catch (  final IOException e) {
    CRYPTOIOEXC.thrw(input,e);
  }
catch (  final ParserConfigurationException e) {
    CRYPTOIOEXC.thrw(input,e);
  }
catch (  final KeyStoreException e) {
    CRYPTOKSEXC.thrw(input,e);
  }
catch (  final MarshalException e) {
    CRYPTOSIGEXC.thrw(input,e);
  }
catch (  final XMLSignatureException e) {
    CRYPTOSIGEXC.thrw(input,e);
  }
catch (  final NoSuchAlgorithmException e) {
    CRYPTOALGEXC.thrw(input,e);
  }
catch (  final CertificateException e) {
    CRYPTOALGEXC.thrw(input,e);
  }
catch (  final UnrecoverableKeyException e) {
    CRYPTONOKEY.thrw(input,e);
  }
catch (  final KeyException e) {
    CRYPTONOKEY.thrw(input,e);
  }
catch (  final InvalidAlgorithmParameterException e) {
    CRYPTOALGEXC.thrw(input,e);
  }
  return signedNode;
}
