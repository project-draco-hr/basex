{
  final String pth=text("@FilePath",root);
  final String outname=text("@name",root);
  if (single != null && !outname.startsWith(single))   return true;
  final Performance perf=new Performance();
  if (verbose)   Util.out("- " + outname);
  boolean inspect=false;
  boolean correct=true;
  final Nodes nodes=states(root);
  for (int n=0; n < nodes.size(); ++n) {
    final Nodes state=new Nodes(nodes.list[n],nodes.data);
    final String inname=text("*:query/@name",state);
    final IOFile query=new IOFile(queries + pth + inname+ IO.XQSUFFIX);
    context.prop.set(Prop.QUERYPATH,query.path());
    final String in=read(query);
    String er=null;
    ItemCache iter=null;
    final Nodes cont=nodes("*:contextItem",state);
    Nodes curr=null;
    if (cont.size() != 0) {
      final Data d=Check.check(context,srcs.get(string(data.atom(cont.list[0]))));
      curr=new Nodes(d.resources.docs().toArray(),d);
      curr.root=true;
    }
    context.prop.set(Prop.QUERYINFO,compile);
    final QueryProcessor xq=new QueryProcessor(in,context).context(curr);
    context.prop.set(Prop.QUERYINFO,false);
    final ArrayOutput ao=new ArrayOutput();
    final TokenBuilder files=new TokenBuilder();
    try {
      files.add(file(nodes("*:input-file",state),nodes("*:input-file/@variable",state),xq,n == 0));
      files.add(file(nodes("*:defaultCollection",state),null,xq,n == 0));
      var(nodes("*:input-URI",state),nodes("*:input-URI/@variable",state),xq);
      eval(nodes("*:input-query/@name",state),nodes("*:input-query/@variable",state),pth,xq);
      parse(xq,state);
      for (      final int p : nodes("*:module",root).list) {
        final String uri=text("@namespace",new Nodes(p,data));
        final String file=IO.get(mods.get(string(data.atom(p))) + IO.XQSUFFIX).path();
        xq.module(uri,file);
      }
      iter=xq.value().cache();
      final SerializerProp sp=new SerializerProp();
      sp.set(SerializerProp.S_INDENT,NO);
      final Serializer ser=Serializer.get(ao,sp);
      for (Item it; (it=iter.next()) != null; )       it.serialize(ser);
      ser.close();
    }
 catch (    final Exception ex) {
      if (!(ex instanceof QueryException || ex instanceof IOException)) {
        Util.errln("\n*** " + outname + " ***");
        Util.errln(in + '\n');
        Util.stack(ex);
      }
      er=ex.getMessage();
      if (er.startsWith(STOPPED_AT))       er=er.substring(er.indexOf('\n') + 1);
      if (!er.isEmpty() && er.charAt(0) == '[')       er=er.replaceAll("\\[(.*?)\\] (.*)","$1 $2");
    }
    if (compile) {
      Util.errln("---------------------------------------------------------");
      Util.err(xq.info());
      Util.errln(in);
    }
    final Nodes expOut=nodes("*:output-file/text()",state);
    final TokenList result=new TokenList();
    for (int o=0; o < expOut.size(); ++o) {
      final String resFile=string(data.atom(expOut.list[o]));
      final IOFile exp=new IOFile(expected + pth + resFile);
      result.add(read(exp).replaceAll("\r\n|\r|\n",Prop.NL));
    }
    final Nodes cmpFiles=nodes("*:output-file/@compare",state);
    boolean xml=false;
    boolean frag=false;
    boolean ignore=false;
    for (int o=0; o < cmpFiles.size(); ++o) {
      final byte[] type=data.atom(cmpFiles.list[o]);
      xml|=eq(type,XML);
      frag|=eq(type,FRAGMENT);
      ignore|=eq(type,IGNORE);
    }
    String expError=text("*:expected-error/text()",state);
    final StringBuilder log=new StringBuilder(pth + inname + IO.XQSUFFIX);
    if (!files.isEmpty())     log.append(" [").append(files).append(']');
    log.append(NL);
    log.append(norm(in)).append(NL);
    final String logStr=log.toString();
    final boolean print=currTime || !logStr.contains("current-");
    boolean correctError=false;
    if (er != null && (expOut.size() == 0 || !expError.isEmpty())) {
      expError=error(pth + outname,expError);
      final String code=er.substring(0,Math.min(8,er.length()));
      for (      final String e : SLASH.split(expError)) {
        if (code.equals(e)) {
          correctError=true;
          break;
        }
      }
    }
    if (correctError) {
      if (print) {
        logOK.append(logStr);
        logOK.append("[Right] ");
        logOK.append(norm(er));
        logOK.append(NL);
        logOK.append(NL);
        addLog(pth,outname + ".log",er);
      }
      ++ok;
    }
 else     if (er == null) {
      int s=-1;
      final int rs=result.size();
      while (!ignore && ++s < rs) {
        inspect|=s < cmpFiles.list.length && eq(data.atom(cmpFiles.list[s]),INSPECT);
        final String expect=string(result.get(s));
        final String actual=ao.toString();
        if (expect.equals(actual))         break;
        if (xml || frag) {
          iter.reset();
          try {
            final ItemCache ic=toIter(expect.replaceAll("^<\\?xml.*?\\?>","").trim(),frag);
            if (Compare.deep(iter,ic,null))             break;
            ic.reset();
            final ItemCache ia=toIter(actual,frag);
            if (Compare.deep(ia,ic,null))             break;
          }
 catch (          final Throwable ex) {
            Util.errln('\n' + outname + ':');
            Util.stack(ex);
          }
        }
      }
      if ((rs > 0 || !expError.isEmpty()) && s == rs && !inspect) {
        if (print) {
          if (expOut.size() == 0)           result.add(error(pth + outname,expError));
          logErr.append(logStr);
          logErr.append('[' + testid + " ] ");
          logErr.append(norm(string(result.get(0))));
          logErr.append(NL);
          logErr.append("[Wrong] ");
          logErr.append(norm(ao.toString()));
          logErr.append(NL);
          logErr.append(NL);
          addLog(pth,outname + (xml ? IO.XMLSUFFIX : ".txt"),ao.toString());
        }
        correct=false;
        ++err;
      }
 else {
        if (print) {
          logOK.append(logStr);
          logOK.append("[Right] ");
          logOK.append(norm(ao.toString()));
          logOK.append(NL);
          logOK.append(NL);
          addLog(pth,outname + (xml ? IO.XMLSUFFIX : ".txt"),ao.toString());
        }
        ++ok;
      }
    }
 else {
      if (expOut.size() == 0 || !expError.isEmpty()) {
        if (print) {
          logOK2.append(logStr);
          logOK2.append('[' + testid + " ] ");
          logOK2.append(norm(expError));
          logOK2.append(NL);
          logOK2.append("[Rght?] ");
          logOK2.append(norm(er));
          logOK2.append(NL);
          logOK2.append(NL);
          addLog(pth,outname + ".log",er);
        }
        ++ok2;
      }
 else {
        if (print) {
          logErr2.append(logStr);
          logErr2.append('[' + testid + " ] ");
          logErr2.append(norm(string(result.get(0))));
          logErr2.append(NL);
          logErr2.append("[Wrong] ");
          logErr2.append(norm(er));
          logErr2.append(NL);
          logErr2.append(NL);
          addLog(pth,outname + ".log",er);
        }
        correct=false;
        ++err2;
      }
    }
    if (curr != null)     Close.close(curr.data,context);
    xq.close();
  }
  if (reporting) {
    logReport.append("    <test-case name=\"");
    logReport.append(outname);
    logReport.append("\" result='");
    logReport.append(correct ? "pass" : "fail");
    if (inspect)     logReport.append("' todo='inspect");
    logReport.append("'/>");
    logReport.append(NL);
  }
  final long nano=perf.time();
  final boolean slow=nano / 1000000 > timer;
  if (verbose) {
    if (slow)     Util.out(": " + Performance.getTime(nano,1));
    Util.outln();
  }
 else   if (slow) {
    Util.out(NL + "- " + outname+ ": "+ Performance.getTime(nano,1));
  }
  return single == null || !outname.equals(single);
}
