{
  builder.startDoc(token(filename));
  final Stack<NodeIterator> stack=new Stack<NodeIterator>();
  stack.push(new NodeIterator(root));
  while (!stack.empty()) {
    final NodeIterator ni=stack.peek();
    if (ni.more()) {
      final Node n=ni.curr();
      if (n instanceof Element) {
        stack.push(new NodeIterator(n));
        atts.reset();
        final NamedNodeMap at=n.getAttributes();
        for (int a=0, as=at.getLength(); a < as; ++a) {
          final Attr att=(Attr)at.item(a);
          final byte[] k=token(att.getName()), v=token(att.getValue());
          if (eq(k,XMLNS)) {
            builder.startNS(EMPTY,v);
          }
 else           if (startsWith(k,XMLNSC)) {
            builder.startNS(ln(k),v);
          }
 else {
            atts.add(k,v);
          }
        }
        builder.startElem(token(n.getNodeName()),atts);
      }
 else       if (n instanceof Text) {
        builder.text(new TokenBuilder(n.getNodeValue()));
      }
 else       if (n instanceof Comment) {
        builder.comment(new TokenBuilder(n.getNodeValue()));
      }
 else       if (n instanceof ProcessingInstruction) {
        builder.pi(new TokenBuilder(n.getNodeName() + ' ' + n.getNodeValue()));
      }
      ++nodes;
    }
 else {
      stack.pop();
      if (stack.empty())       break;
      builder.endElem(token(stack.peek().curr().getNodeName()));
    }
  }
  builder.endDoc();
}
