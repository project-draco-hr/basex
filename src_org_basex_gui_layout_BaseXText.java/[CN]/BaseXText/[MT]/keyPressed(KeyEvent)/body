{
  if (modifier(e))   return;
  if (pressed(PREVTAB,e)) {
    transferFocusBackward();
    return;
  }
  if (pressed(NEXTTAB,e)) {
    transferFocus();
    return;
  }
  if (pressed(FIND,e)) {
    if (find != null)     find.requestFocusInWindow();
    return;
  }
  cursor(true);
  final int fh=rend.fontH();
  if (pressed(SCROLLDOWN,e)) {
    scroll.pos(scroll.pos() + fh);
    return;
  }
  if (pressed(SCROLLUP,e)) {
    scroll.pos(scroll.pos() - fh);
    return;
  }
  if (pressed(COPY,e)) {
    copy();
    return;
  }
  text.pos(text.cursor());
  if (!pressed(UP,e) && !pressed(DOWN,e))   lastCol=-1;
  if (pressed(FINDNEXT,e) || pressed(FINDPREV,e)) {
    find(rend.find(pressed(FINDPREV,e),true));
    return;
  }
  if (pressed(SELECTALL,e)) {
    selectAll();
    text.setCaret();
    return;
  }
  final boolean marking=e.isShiftDown();
  final boolean nomark=text.start() == -1;
  if (marking && nomark)   text.startMark();
  boolean down=true;
  boolean consumed=true;
  if (pressed(WORDRIGHT,e)) {
    final boolean ch=ftChar(text.next(marking));
    while (text.pos() < text.size() && ch == ftChar(text.curr()))     text.next(marking);
  }
 else   if (pressed(WORDLEFT,e)) {
    final boolean ch=ftChar(text.prev(marking));
    while (text.pos() > 0 && ch == ftChar(text.prev(marking)))     ;
    if (text.pos() != 0)     text.next(marking);
    down=false;
  }
 else   if (pressed(BOT,e)) {
    if (!marking)     text.noMark();
    text.pos(0);
    down=false;
  }
 else   if (pressed(EOT,e)) {
    if (!marking)     text.noMark();
    text.pos(text.size());
  }
 else   if (pressed(BOL,e)) {
    text.bol(marking);
    down=false;
  }
 else   if (pressed(EOL,e)) {
    text.forward(Integer.MAX_VALUE,marking);
  }
 else   if (pressed(PAGEDOWN,e)) {
    down(getHeight() / fh,marking);
  }
 else   if (pressed(PAGEUP,e)) {
    up(getHeight() / fh,marking);
    down=false;
  }
 else   if (pressed(RIGHT,e)) {
    text.next(marking);
  }
 else   if (pressed(LEFT,e)) {
    text.prev(marking);
    down=false;
  }
 else   if (pressed(UP,e)) {
    up(1,marking);
    down=false;
  }
 else   if (pressed(DOWN,e)) {
    down(1,marking);
  }
 else {
    consumed=false;
  }
  final byte[] txt=text.text;
  if (marking) {
    text.endMark();
  }
 else   if (undo != null) {
    if (pressed(CUT,e)) {
      cut();
    }
 else     if (pressed(PASTE,e)) {
      paste();
    }
 else     if (pressed(UNDO,e)) {
      undo();
    }
 else     if (pressed(REDO,e)) {
      redo();
    }
 else     if (pressed(DELWORD,e) || pressed(DEL,e)) {
      if (nomark && text.pos() == text.size())       return;
      final boolean ld=ftChar(text.curr());
      text.delete();
      if (nomark && pressed(DELWORD,e)) {
        while (text.pos() < text.size() && ld == ftChar(text.curr()))         text.delete();
      }
    }
 else     if (pressed(DELWORDLEFT,e) || pressed(DELBACK,e)) {
      if (nomark) {
        if (text.pos() == 0)         return;
        text.prev();
      }
      final boolean ld=ftChar(text.curr());
      text.delete();
      if (nomark && pressed(DELWORDLEFT,e)) {
        while (text.pos() > 0 && ld == ftChar(text.prev()))         text.delete();
        if (text.pos() != 0)         text.next();
      }
      down=false;
    }
 else {
      consumed=false;
    }
  }
  if (consumed)   e.consume();
  text.setCaret();
  if (txt != text.text)   rend.calc();
  showCursor(down ? 2 : 0);
}
