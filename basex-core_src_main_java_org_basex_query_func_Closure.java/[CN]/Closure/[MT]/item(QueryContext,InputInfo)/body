{
  final FuncType ft=(FuncType)seqType().type;
  final Expr body;
  if (!nonLocal.isEmpty()) {
    final LinkedList<GFLWOR.Clause> cls=new LinkedList<>();
    for (    final Entry<Var,Expr> e : nonLocal.entrySet())     cls.add(new Let(e.getKey(),e.getValue().value(qc),false,ii));
    body=new GFLWOR(ii,cls,expr);
  }
 else {
    body=expr;
  }
  final SeqType argType=body.seqType();
  final Expr checked;
  if (ret == null || argType.instanceOf(ret)) {
    checked=body;
  }
 else   if (body instanceof FuncItem && ret.type instanceof FuncType) {
    if (!ret.occ.check(1))     throw INVTREAT_X_X.get(info,argType,ret);
    final FuncItem fi=(FuncItem)body;
    checked=fi.coerceTo((FuncType)ret.type,qc,info,true);
  }
 else   if (body.isValue()) {
    checked=seqType.promote(qc,sc,info,(Value)body,false);
  }
 else {
    if (argType.type.instanceOf(ret.type) && !body.has(Flag.NDT) && !body.has(Flag.UPD)) {
      final SeqType.Occ occ=argType.occ.intersect(ret.occ);
      if (occ == null)       throw INVTREAT_X_X.get(info,argType,ret);
    }
    checked=new TypeCheck(sc,info,body,ret,true);
  }
  return new FuncItem(sc,ann,null,args,ft,checked,scope.stackSize());
}
