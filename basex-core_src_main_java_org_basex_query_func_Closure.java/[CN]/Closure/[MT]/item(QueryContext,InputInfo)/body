{
  final Type type=seqType().type;
  if (!(type instanceof FuncType))   throw Util.notExpected("Closure was not compiled: %",this);
  final FuncType ft=(FuncType)type;
  final Expr body;
  if (!nonLocal.isEmpty()) {
    final LinkedList<GFLWOR.Clause> cls=new LinkedList<>();
    for (    final Entry<Var,Expr> e : nonLocal.entrySet())     cls.add(new Let(e.getKey(),e.getValue().value(qc),false,ii));
    body=new GFLWOR(ii,cls,expr);
  }
 else {
    body=expr;
  }
  final SeqType argType=body.seqType();
  final Expr checked;
  if (ret == null || argType.instanceOf(ret)) {
    checked=body;
  }
 else   if (body instanceof FuncItem && ret.type instanceof FuncType) {
    if (!ret.occ.check(1))     throw INVTREAT_X_X.get(info,argType,ret);
    final FuncItem fi=(FuncItem)body;
    checked=fi.coerceTo((FuncType)ret.type,qc,info,true);
  }
 else   if (body.isValue()) {
    final Value val=(Value)body;
    checked=ret.instance(val) ? val : ret.promote(qc,sc,info,val,false);
  }
 else {
    if (argType.type.instanceOf(ret.type) && !body.has(Flag.NDT) && !body.has(Flag.UPD)) {
      final SeqType.Occ occ=argType.occ.intersect(ret.occ);
      if (occ == null)       throw INVTREAT_X_X.get(info,argType,ret);
    }
    checked=new TypeCheck(sc,info,body,ret,true);
  }
  return new FuncItem(sc,anns,name,args,ft,checked,scope.stackSize());
}
