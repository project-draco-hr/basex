{
  final int h=getHeight();
  final int w=getWidth();
  g.setColor(GUIConstants.back);
  final int novalue=noValueSize();
  final int pWidth=plotWidth - novalue;
  final int pHeight=plotHeight - novalue;
  final PlotAxis axis=drawX ? plotData.xAxis : plotData.yAxis;
  if (drawX) {
    g.drawLine(MARGIN[1],h - MARGIN[2],w - MARGIN[3],h - MARGIN[2]);
    if (plotChanged)     axis.calcCaption(pWidth);
  }
 else {
    g.drawLine(MARGIN[1],MARGIN[0],MARGIN[1],getHeight() - MARGIN[2]);
    if (plotChanged)     axis.calcCaption(pHeight);
  }
  final Kind type=axis.type;
  final int nrCaptions=axis.nrCaptions;
  final double step=axis.actlCaptionStep;
  final double capRange=1.0d / (nrCaptions - 1);
  g.setFont(GUIConstants.font);
  if (type == Kind.TEXT) {
    final int nrCats=axis.nrCats;
    final double[] coSorted=Array.finish(axis.co,axis.co.length);
    drawCaptionAndGrid(g,drawX,nrCats > 1 ? string(axis.firstCat) : "",0);
    drawCaptionAndGrid(g,drawX,nrCats > 1 ? string(axis.lastCat) : "",1);
    if (nrCaptions == 0)     return;
    Arrays.sort(coSorted);
    double op=capRange;
    final int cl=coSorted.length;
    int i=0;
    while (i < cl && coSorted[i] == 0)     i++;
    while (i < cl && op < 1.0d - 0.4d * capRange) {
      if (coSorted[i] > op) {
        final double distL=Math.abs(coSorted[i - 1] - op);
        final double distG=Math.abs(coSorted[i] - op);
        op=distL < distG ? coSorted[i - 1] : coSorted[i];
        int j=0;
        while (j < axis.co.length && axis.co[j] != op)         j++;
        drawCaptionAndGrid(g,drawX,string(axis.getValue(plotData.pres[j])),op);
        op+=capRange;
      }
      i++;
    }
    if (nrCats == 1) {
      op=.5d;
      int j=0;
      while (j < axis.co.length && axis.co[j] != op)       j++;
      drawCaptionAndGrid(g,drawX,string(axis.getValue(plotData.pres[j])),op);
    }
  }
 else {
    final boolean noRange=axis.max - axis.min == 0;
    drawCaptionAndGrid(g,drawX,noRange ? "" : "",0);
    drawCaptionAndGrid(g,drawX,noRange ? "" : "",1);
    if (nrCaptions == 0)     return;
    if (noRange) {
      drawCaptionAndGrid(g,drawX,formatString(axis.min,drawX),.5d);
      return;
    }
    double d=axis.calcPosition(axis.firstLabel);
    double f=axis.firstLabel;
    int c=0;
    while (d < 1.0d - .25d / nrCaptions) {
      c++;
      drawCaptionAndGrid(g,drawX,formatString(f,drawX),d);
      d=axis.calcPosition(f + step);
      f=f + step;
    }
    if (c < 2) {
      drawCaptionAndGrid(g,drawX,formatString(axis.min,drawX),0.0);
      drawCaptionAndGrid(g,drawX,formatString(axis.max,drawX),1.0);
    }
  }
}
