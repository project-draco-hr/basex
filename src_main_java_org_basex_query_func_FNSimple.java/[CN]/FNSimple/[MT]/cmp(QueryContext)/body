{
  final Expr e=expr[0];
switch (def) {
case BOOLEAN:
    expr[0]=e.compEbv(ctx);
  return expr[0].type().eq(SeqType.BLN) ? e : this;
case NOT:
if (e instanceof Fun) {
  final Fun f=e instanceof Fun ? (Fun)e : null;
  if (f.def == FunDef.EMPTY) {
    ctx.compInfo(QueryText.OPTWRITE,this);
    expr=f.expr;
    def=FunDef.EXISTS;
  }
 else   if (f.def == FunDef.EXISTS) {
    ctx.compInfo(QueryText.OPTWRITE,this);
    expr=f.expr;
    def=FunDef.EMPTY;
  }
 else {
    expr[0]=e.compEbv(ctx);
  }
}
return this;
case ZEROORONE:
type=SeqType.get(e.type().type,SeqType.Occ.ZO);
return e.type().zeroOrOne() ? e : this;
case EXACTLYONE:
type=SeqType.get(e.type().type,SeqType.Occ.O);
return e.type().one() ? e : this;
case ONEORMORE:
type=SeqType.get(e.type().type,SeqType.Occ.OM);
return !e.type().mayBeZero() ? e : this;
case UNORDER:
return e;
default :
return this;
}
}
