{
  final Expr e=expr[0];
switch (def) {
case EMPTY:
case EXISTS:
    return e.size() == -1 || e.uses(Use.CTX) ? this : Bln.get(def == Function.EMPTY ^ e.size() != 0);
case BOOLEAN:
  return e.type().eq(SeqType.BLN) ? e : this;
case NOT:
if (e.isFun(Function.EMPTY)) {
  ctx.compInfo(QueryText.OPTWRITE,this);
  expr=((FuncCall)e).expr;
  def=Function.EXISTS;
}
 else if (e.isFun(Function.EXISTS)) {
  ctx.compInfo(QueryText.OPTWRITE,this);
  expr=((FuncCall)e).expr;
  def=Function.EMPTY;
}
 else if (e instanceof CmpV || e instanceof CmpG) {
  final Cmp c=((Cmp)e).invert();
  return c == e ? this : c;
}
 else if (e.isFun(Function.NOT)) {
  return compBln(((FuncCall)e).expr[0]);
}
 else {
  expr[0]=e.compEbv(ctx);
}
return this;
case ZEROORONE:
type=SeqType.get(e.type().type,SeqType.Occ.ZO);
return e.type().zeroOrOne() ? e : this;
case EXACTLYONE:
type=SeqType.get(e.type().type,SeqType.Occ.O);
return e.type().one() ? e : this;
case ONEORMORE:
type=SeqType.get(e.type().type,SeqType.Occ.OM);
return !e.type().mayBeZero() ? e : this;
case UNORDER:
return e;
default :
return this;
}
}
