{
  final Expr e=expr[0];
switch (def) {
case EMPTY:
    return e.size() != -1 && !e.uses(Use.CTX) ? Bln.get(e.size() == 0) : this;
case EXISTS:
  return e.size() != -1 && !e.uses(Use.CTX) ? Bln.get(e.size() != 0) : this;
case BOOLEAN:
if (expr[0].type().eq(SeqType.BLN)) return e;
expr[0]=e.compEbv(ctx);
return this;
case NOT:
if (e.isFun(Function.EMPTY)) {
ctx.compInfo(QueryText.OPTWRITE,this);
expr=((FuncCall)e).expr;
def=Function.EXISTS;
}
 else if (e.isFun(Function.EXISTS)) {
ctx.compInfo(QueryText.OPTWRITE,this);
expr=((FuncCall)e).expr;
def=Function.EMPTY;
}
 else if (e instanceof CmpV || e instanceof CmpG) {
final Cmp c=((Cmp)e).invert();
return c == e ? this : c;
}
 else {
expr[0]=e.compEbv(ctx);
}
return this;
case ZEROORONE:
type=SeqType.get(e.type().type,SeqType.Occ.ZO);
return e.type().zeroOrOne() ? e : this;
case EXACTLYONE:
type=SeqType.get(e.type().type,SeqType.Occ.O);
return e.type().one() ? e : this;
case ONEORMORE:
type=SeqType.get(e.type().type,SeqType.Occ.OM);
return !e.type().mayBeZero() ? e : this;
case UNORDER:
return e;
default :
return this;
}
}
