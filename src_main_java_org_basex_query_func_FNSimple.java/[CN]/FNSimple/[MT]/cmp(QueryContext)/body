{
  final Expr e=expr[0];
switch (sig) {
case EMPTY:
case EXISTS:
    return e.size() == -1 || e.uses(Use.NDT) || e.uses(Use.CNS) ? this : Bln.get(sig == Function.EMPTY ^ !e.isEmpty());
case BOOLEAN:
  return e.type().eq(SeqType.BLN) ? e : this;
case NOT:
if (e.isFunction(Function.EMPTY)) {
  ctx.compInfo(QueryText.OPTWRITE,this);
  expr=((StandardFunc)e).expr;
  sig=Function.EXISTS;
}
 else if (e.isFunction(Function.EXISTS)) {
  ctx.compInfo(QueryText.OPTWRITE,this);
  expr=((StandardFunc)e).expr;
  sig=Function.EMPTY;
}
 else if (e instanceof CmpV || e instanceof CmpG) {
  final Cmp c=((Cmp)e).invert();
  return c == e ? this : c;
}
 else if (e.isFunction(Function.NOT)) {
  return compBln(((StandardFunc)e).expr[0]);
}
 else {
  expr[0]=e.compEbv(ctx);
}
return this;
case ZERO_OR_ONE:
type=SeqType.get(e.type().type,Occ.ZO);
return e.type().zeroOrOne() ? e : this;
case EXACTLY_ONE:
type=SeqType.get(e.type().type,Occ.O);
return e.type().one() ? e : this;
case ONE_OR_MORE:
type=SeqType.get(e.type().type,Occ.OM);
return !e.type().mayBeZero() ? e : this;
case UNORDERED:
return e;
default :
return this;
}
}
