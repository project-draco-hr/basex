{
  final int s=ctx.vars.size();
  final ForLet[] fl=forLet();
  if (fl == null)   return null;
  Expr where=null;
  if (wsConsumeWs(WHERE)) {
    ap=qp;
    where=check(single(),NOWHERE);
    alter=NOWHERE;
  }
  Group group=null;
  if (ctx.xquery3 && wsConsumeWs(GROUP)) {
    wsCheck(BY);
    ap=qp;
    Group.Spec[] grp=null;
    do     grp=groupSpec(fl,grp);
 while (wsConsume(COMMA));
    final ArrayList<Var> ng=new ArrayList<Var>();
    final TokenSet set=new TokenSet();
    for (    final Group.Spec spec : grp)     set.add(spec.grp.name.eqname());
    for (int i=fl.length; --i >= 0; ) {
      for (      final Var v : fl[i].vars()) {
        final byte[] eqn=v.name.eqname();
        if (!set.contains(eqn)) {
          ng.add(v);
          set.add(eqn);
        }
      }
    }
    final Var[] ngrp=new Var[ng.size()];
    for (int i=ng.size(); --i >= 0; ) {
      final Var v=ng.get(i);
      ngrp[i]=Var.create(ctx,input(),v.name,v.type != null && v.type.one() ? SeqType.get(v.type.type,Occ.ONE_MORE) : null,null);
      ctx.vars.add(ngrp[i]);
    }
    group=new Group(grp[0].input,grp,new Var[][]{ng.toArray(new Var[ng.size()]),ngrp});
    alter=GRPBY;
  }
  Order order=null;
  final boolean stable=wsConsumeWs(STABLE);
  if (stable)   wsCheck(ORDER);
  if (stable || wsConsumeWs(ORDER)) {
    wsCheck(BY);
    ap=qp;
    OrderBy[] ob=null;
    do     ob=orderSpec(ob);
 while (wsConsume(COMMA));
    if (ob != null) {
      ob=Array.add(ob,new OrderByStable(input()));
      order=new Order(ob[0].input,ob);
    }
    alter=ORDERBY;
  }
  if (!wsConsumeWs(RETURN)) {
    if (alter != null)     error();
    error(where == null ? FLWORWHERE : order == null ? FLWORORD : FLWORRET);
  }
  final Expr ret=check(single(),NORETURN);
  ctx.vars.size(s);
  return GFLWOR.get(fl,where,order,group,ret,input());
}
