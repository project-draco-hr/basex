{
  skipWS();
  final QNm name=new QNm(qName(FUNCNAME));
  name.uri(name.ns() ? ctx.ns.uri(name.pref(),false,input()) : ctx.nsFunc);
  if (module != null && !name.uri().eq(module.uri()))   error(MODNS,name);
  wsCheck(PAR1);
  skipWS();
  Var[] args={};
  final int s=ctx.vars.size();
  while (true) {
    if (curr() != '$') {
      if (args.length == 0)       break;
      error(WRONGCHAR,'$',found());
    }
    final QNm arg=varName();
    final SeqType argType=wsConsumeWs(AS) ? sequenceType() : null;
    final Var var=new Var(input(),arg,argType);
    ctx.vars.add(var);
    for (    final Var v : args)     if (v.name.eq(arg))     error(FUNCDUPL,arg.atom());
    args=Array.add(args,var);
    if (!consume(','))     break;
    skipWS();
  }
  wsCheck(PAR2);
  final SeqType type=wsConsumeWs(AS) ? sequenceType() : null;
  final Func func=new Func(input(),new Var(input(),name,type),args,true);
  func.updating=up;
  ctx.funcs.add(func,this);
  if (!wsConsumeWs(EXTERNAL))   func.expr=enclosed(NOFUNBODY);
  ctx.vars.reset(s);
}
