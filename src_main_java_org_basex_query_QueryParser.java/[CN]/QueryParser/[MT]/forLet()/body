{
  ForLet[] fl=null;
  boolean comma=false;
  while (true) {
    final boolean fr=wsConsumeWs(FOR,DOLLAR,NOFOR);
    boolean score=!fr && wsConsumeWs(LET,SCORE,NOLET);
    if (score)     wsCheck(SCORE);
 else     if (!fr && !wsConsumeWs(LET,DOLLAR,NOLET))     return fl;
    do {
      if (comma && !fr)       score=wsConsumeWs(SCORE);
      final QNm name=varName();
      final SeqType type=score ? SeqType.DBL : optAsType();
      final Var var=Var.create(ctx,input(),name,type,null);
      final Var ps=fr && wsConsumeWs(AT) ? Var.create(ctx,input(),varName(),SeqType.ITR,null) : null;
      final Var sc=fr && wsConsumeWs(SCORE) ? Var.create(ctx,input(),varName(),SeqType.DBL,null) : null;
      wsCheck(fr ? IN : ASSIGN);
      final Expr e=check(single(),NOVARDECL);
      ctx.vars.add(var);
      if (ps != null) {
        if (name.eq(ps.name))         error(DUPLVAR,var);
        ctx.vars.add(ps);
      }
      if (sc != null) {
        if (name.eq(sc.name))         error(DUPLVAR,var);
        if (ps != null && ps.name.eq(sc.name))         error(DUPLVAR,ps);
        ctx.vars.add(sc);
      }
      fl=fl == null ? new ForLet[1] : Arrays.copyOf(fl,fl.length + 1);
      fl[fl.length - 1]=fr ? new For(input(),e,var,ps,sc) : new Let(input(),e,var,score);
      score=false;
      comma=true;
    }
 while (wsConsume(COMMA));
    comma=false;
  }
}
