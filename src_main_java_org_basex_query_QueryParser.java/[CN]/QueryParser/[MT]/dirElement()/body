{
  final int s=ctx.sc.ns.size();
  final byte[] nse=ctx.sc.nsElem;
  final int npos=names.size();
  final QNm tag=new QNm(qName(TAGNAME));
  names.add(new QNmCheck(tag));
  consumeWS();
  final Atts ns=new Atts();
  Expr[] cont={};
  boolean xmlDecl=false;
  while (true) {
    final byte[] atn=qName(null);
    if (atn.length == 0)     break;
    Expr[] attv={};
    consumeWS();
    check('=');
    consumeWS();
    final char delim=consume();
    if (!quote(delim))     error(NOQUOTE,found());
    final TokenBuilder tb=new TokenBuilder();
    boolean simple=true;
    do {
      while (!consume(delim)) {
        final char ch=curr();
        if (ch == '{') {
          if (next() == '{') {
            tb.add(consume());
            consume();
          }
 else {
            final byte[] text=tb.finish();
            if (text.length != 0) {
              attv=add(attv,Str.get(text));
            }
 else {
              attv=add(attv,enclosed(NOENCLEXPR));
              simple=false;
            }
            tb.reset();
          }
        }
 else         if (ch == '}') {
          consume();
          check('}');
          tb.add('}');
        }
 else         if (ch == '<' || ch == 0) {
          error(NOQUOTE,found());
        }
 else         if (ch == '\n' || ch == '\t') {
          tb.add(' ');
          consume();
        }
 else         if (ch == '\r') {
          if (next() != '\n')           tb.add(' ');
          consume();
        }
 else {
          entity(tb);
        }
      }
      if (!consume(delim))       break;
      tb.add(delim);
    }
 while (true);
    if (tb.size() != 0)     attv=add(attv,Str.get(tb.finish()));
    final boolean pr=startsWith(atn,XMLNSC);
    if (pr || eq(atn,XMLNS)) {
      if (!simple)       error(NSCONS);
      final byte[] pref=pr ? local(atn) : EMPTY;
      final byte[] uri=attv.length == 0 ? EMPTY : ((Str)attv[0]).string();
      if (eq(pref,XML) && eq(uri,XMLURI)) {
        if (xmlDecl)         error(DUPLNSDEF,XML);
        xmlDecl=true;
      }
 else {
        if (pr) {
          if (uri.length == 0)           error(NSEMPTYURI);
          if (eq(pref,XML) || eq(pref,XMLNS))           error(BINDXML,pref);
          if (eq(XMLURI,uri))           error(BINDXMLURI,uri,XML);
          if (eq(XMLNSURI,uri))           error(BINDXMLURI,uri,XMLNS);
          ctx.sc.ns.add(pref,uri);
        }
 else {
          ctx.sc.nsElem=uri;
        }
        if (ns.get(pref) != -1)         error(DUPLNSDEF,pref);
        ns.add(pref,uri);
      }
    }
 else {
      final QNm attn=new QNm(atn);
      names.add(new QNmCheck(attn,false));
      cont=add(cont,new CAttr(input(),false,attn,attv));
    }
    if (!consumeWS())     break;
  }
  if (consume('/')) {
    check('>');
  }
 else {
    check('>');
    while (curr() != '<' || next() != '/') {
      final Expr e=dirElemContent(tag.string());
      if (e == null)       continue;
      cont=add(cont,e);
    }
    qp+=2;
    final byte[] close=qName(TAGNAME);
    consumeWS();
    check('>');
    if (!eq(tag.string(),close))     error(TAGWRONG,tag.string(),close);
  }
  assignURI(npos);
  ctx.sc.ns.size(s);
  ctx.sc.nsElem=nse;
  return new CElem(input(),tag,ns,cont);
}
