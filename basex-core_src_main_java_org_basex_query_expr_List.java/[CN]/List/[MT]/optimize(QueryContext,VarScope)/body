{
  size=0;
  boolean ne=false;
  for (  final Expr e : expr) {
    final long c=e.size();
    ne|=c > 0 || e.type().occ.min == 1;
    if (c == -1) {
      size=-1;
      break;
    }
 else     if (size >= 0) {
      size+=c;
    }
  }
  if (size >= 0) {
    if (size == 0 && !has(Flag.NDT) && !has(Flag.UPD))     return optPre(null,ctx);
    if (allAreValues() && size <= MAX_MAT_SIZE) {
      Type all=null;
      final Value[] vs=new Value[expr.length];
      int c=0;
      for (      final Expr e : expr) {
        final Value v=e.value(ctx);
        if (c == 0)         all=v.type;
 else         if (all != v.type)         all=null;
        vs[c++]=v;
      }
      final Value val;
      final int s=(int)size;
      if (all == AtomType.STR)       val=StrSeq.get(vs,s);
 else       if (all == AtomType.BLN)       val=BlnSeq.get(vs,s);
 else       if (all == AtomType.FLT)       val=FltSeq.get(vs,s);
 else       if (all == AtomType.DBL)       val=DblSeq.get(vs,s);
 else       if (all == AtomType.DEC)       val=DecSeq.get(vs,s);
 else       if (all == AtomType.BYT)       val=BytSeq.get(vs,s);
 else       if (all != null && all.instanceOf(AtomType.ITR)) {
        val=IntSeq.get(vs,s,all);
      }
 else {
        final ValueBuilder vb=new ValueBuilder(s);
        for (int i=0; i < c; i++)         vb.add(vs[i]);
        val=vb.value();
      }
      return optPre(val,ctx);
    }
  }
  if (size == 0) {
    type=SeqType.EMP;
  }
 else {
    final Occ o=size == 1 ? Occ.ONE : size < 0 && !ne ? Occ.ZERO_MORE : Occ.ONE_MORE;
    SeqType t=null;
    for (    final Expr e : expr) {
      final SeqType st=e.type();
      if (e.size() != 0 && st.occ != Occ.ZERO)       t=t == null ? st : t.union(st);
    }
    type=SeqType.get(t == null ? AtomType.ITEM : t.type,o);
  }
  return this;
}
