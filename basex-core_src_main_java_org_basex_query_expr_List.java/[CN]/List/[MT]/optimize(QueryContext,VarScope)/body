{
  size=0;
  boolean ne=false;
  for (  final Expr e : exprs) {
    final long c=e.size();
    ne|=c > 0 || e.seqType().occ.min == 1;
    if (c == -1) {
      size=-1;
      break;
    }
 else     if (size >= 0) {
      size+=c;
    }
  }
  if (size >= 0) {
    if (size == 0 && !has(Flag.NDT) && !has(Flag.UPD))     return optPre(null,qc);
    if (allAreValues() && size <= MAX_MAT_SIZE) {
      Type all=null;
      final Value[] vs=new Value[exprs.length];
      int c=0;
      for (      final Expr e : exprs) {
        final Value v=e.value(qc);
        if (c == 0)         all=v.type;
 else         if (all != v.type)         all=null;
        vs[c++]=v;
      }
      final Value val;
      final int s=(int)size;
      if (all == AtomType.STR)       val=StrSeq.get(vs,s);
 else       if (all == AtomType.BLN)       val=BlnSeq.get(vs,s);
 else       if (all == AtomType.FLT)       val=FltSeq.get(vs,s);
 else       if (all == AtomType.DBL)       val=DblSeq.get(vs,s);
 else       if (all == AtomType.DEC)       val=DecSeq.get(vs,s);
 else       if (all == AtomType.BYT)       val=BytSeq.get(vs,s);
 else       if (all != null && all.instanceOf(AtomType.ITR)) {
        val=IntSeq.get(vs,s,all);
      }
 else {
        final ValueBuilder vb=new ValueBuilder(s);
        for (int i=0; i < c; i++)         vb.add(vs[i]);
        val=vb.value();
      }
      return optPre(val,qc);
    }
  }
  if (size == 0) {
    seqType=SeqType.EMP;
  }
 else {
    final Occ o=size == 1 ? Occ.ONE : size < 0 && !ne ? Occ.ZERO_MORE : Occ.ONE_MORE;
    SeqType st=null;
    for (    final Expr e : exprs) {
      final SeqType et=e.seqType();
      if (!e.isEmpty() && et.occ != Occ.ZERO)       st=st == null ? et : st.union(et);
    }
    seqType=SeqType.get(st == null ? AtomType.ITEM : st.type,o);
  }
  return this;
}
