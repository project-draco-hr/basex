{
  final FTOpt to=lex.ftOpt();
  to.set(ST,opt.is(ST));
  to.set(DC,opt.is(DC));
  to.set(CS,opt.is(CS));
  to.ln=opt.ln;
  to.th=opt.th;
  to.sd=opt.sd;
  ArrayList<byte[][]> quTokens=cache.get(query);
  if (quTokens == null) {
    quTokens=new ArrayList<byte[][]>(1);
    cache.add(query,quTokens);
    final FTIterator quLex=new FTLexer(opt).init(query);
    final TokenList quList=new TokenList();
    while (quLex.hasNext())     quList.add(quLex.nextToken());
    quTokens.add(quList.toArray());
    if (opt.th != null) {
      for (      final byte[] ext : opt.th.find(words.input,query)) {
        final TokenList tl=new TokenList();
        quLex.init(ext);
        while (quLex.hasNext())         tl.add(quLex.nextToken());
        quTokens.add(tl.toArray());
      }
    }
  }
  final FTLexer ftl=new FTLexer(to).init(lex.text());
  final FTBitapSearch bs=new FTBitapSearch(ftl,quTokens,cmp);
  int c=0;
  while (bs.hasNext()) {
    final int pos=bs.next();
    ++c;
    if (words.add(pos,pos + quTokens.get(0).length - 1))     break;
  }
  words.all.sTokenNum++;
  words.first=false;
  return c;
}
