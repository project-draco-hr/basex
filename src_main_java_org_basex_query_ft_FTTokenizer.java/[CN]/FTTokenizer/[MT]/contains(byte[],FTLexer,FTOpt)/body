{
  final FTLexer quLex=new FTLexer(q,prop,fto);
  final TokenList quList=new TokenList();
  while (quLex.hasNext())   quList.add(quLex.nextToken());
  final byte[][] quTokens=quList.toArray();
  final FTOpt to=lex.ftOpt();
  to.set(ST,fto.is(ST));
  to.set(DC,fto.is(DC));
  to.set(CS,fto.is(CS));
  to.ln=fto.ln;
  to.th=fto.th;
  to.sd=fto.sd;
  final TokenComparator cmp=new TokenComparator(){
    @Override public boolean equal(    final byte[] in,    final byte[] qu) throws QueryException {
      return fto.sw != null && fto.sw.id(qu) != 0 ? true : fto.is(FZ) ? ls.similar(in,qu,lserr) : fto.is(WC) ? wc(words.input,in,qu,0,0) : eq(in,qu);
    }
  }
;
  final ArrayList<byte[][]> extendedQuTokenList=new ArrayList<byte[][]>(1);
  extendedQuTokenList.add(quTokens);
  if (fto.th != null) {
    final byte[][] extensionTokens=fto.th.find(words.input,quLex.text());
    for (int i=0; i < extensionTokens.length; i++) {
      final TokenList tokens=new TokenList();
      quLex.init(extensionTokens[i]);
      while (quLex.hasNext())       tokens.add(quLex.nextToken());
      extendedQuTokenList.add(tokens.toArray());
    }
  }
  final FTLexer ftl=new FTLexer(lex.text(),prop,to);
  final FTBitapSearch bs=new FTBitapSearch(ftl,extendedQuTokenList,cmp);
  int c=0;
  while (bs.hasNext()) {
    final int pos=bs.next();
    ++c;
    if (words.add(pos,pos + quTokens.length - 1))     break;
  }
  words.all.sTokenNum++;
  words.first=false;
  return c;
}
