{
  final Item it=expr[0].item(ctx,input);
  final Item it2=expr.length == 2 ? expr[1].item(ctx,input) : null;
switch (def) {
case RESQNAME:
    return it == null ? null : resolve(ctx,it,checkEmpty(it2));
case QNAME:
  final byte[] uri=it == null ? EMPTY : checkType(it,Type.STR).atom();
final Item it3=it2 == null ? Str.ZERO : checkType(it2,Type.STR);
final byte[] atm=it3.atom();
final byte[] str=!contains(atm,':') && eq(uri,XMLURI) ? concat(XMLC,atm) : atm;
if (!XMLToken.isQName(str)) Err.value(input,Type.QNM,it3);
QNm nm=new QNm(str,uri);
if (nm.ns() && uri.length == 0) Err.value(input,Type.URI,nm.uri());
return nm;
case LOCNAMEQNAME:
if (it == null) return null;
return new NCN(((QNm)checkType(it,Type.QNM)).ln(),input);
case PREQNAME:
if (it == null) return null;
nm=(QNm)checkType(it,Type.QNM);
return !nm.ns() ? null : new NCN(nm.pref(),input);
case NSURIPRE:
final byte[] pre=checkEStr(it);
final Nod nod=(Nod)checkType(it2,Type.ELM);
final Atts at=nod.nsScope(copiedNod(nod,ctx) ? ctx.nsInherit : true);
final int i=at != null ? at.get(pre) : -1;
return i != -1 ? Uri.uri(at.val[i]) : null;
case RESURI:
if (it == null) return null;
final Uri rel=Uri.uri(checkEStr(it));
if (!rel.valid()) URIINV.thrw(input,it);
final Uri base=it2 == null ? ctx.resource.baseURI : Uri.uri(checkEStr(it2));
if (!base.valid()) URIINV.thrw(input,base);
return base.resolve(rel);
default :
return super.item(ctx,ii);
}
}
