{
  final String pth=text("@FilePath",root);
  final String outname=text("@name",root);
  if (single != null && !outname.startsWith(single))   return true;
  final Performance perf=new Performance();
  if (verbose)   Util.out("- " + outname);
  boolean inspect=false;
  boolean correct=true;
  final Nodes nodes=states(root);
  for (int n=0; n < nodes.size(); ++n) {
    final Nodes state=new Nodes(nodes.list[n],nodes.data);
    final String inname=text("*:query/@name",state);
    context.query=IO.get(queries + pth + inname+ IO.XQSUFFIX);
    final String in=read(context.query);
    String er=null;
    ItemCache iter=null;
    boolean doc=true;
    final Nodes cont=nodes("*:contextItem",state);
    Nodes curr=null;
    if (cont.size() != 0) {
      final Data d=Check.check(context,srcs.get(string(data.atom(cont.list[0]))));
      curr=new Nodes(d.doc(),d);
      curr.root=true;
    }
    context.prop.set(Prop.QUERYINFO,compile);
    final QueryProcessor xq=new QueryProcessor(in,curr,context);
    context.prop.set(Prop.QUERYINFO,false);
    final ArrayOutput ao=new ArrayOutput();
    final TokenBuilder files=new TokenBuilder();
    try {
      files.add(file(nodes("*:input-file",state),nodes("*:input-file/@variable",state),xq,n == 0));
      files.add(file(nodes("*:defaultCollection",state),null,xq,n == 0));
      var(nodes("*:input-URI",state),nodes("*:input-URI/@variable",state),xq);
      eval(nodes("*:input-query/@name",state),nodes("*:input-query/@variable",state),pth,xq);
      parse(xq,state);
      for (      final int p : nodes("*:module",root).list) {
        final String ns=text("@namespace",new Nodes(p,data));
        final String f=mods.get(string(data.atom(p))) + IO.XQSUFFIX;
        xq.module(ns,f);
      }
      final SerializerProp sp=new SerializerProp();
      sp.set(SerializerProp.S_INDENT,context.prop.is(Prop.CHOP) ? DataText.YES : DataText.NO);
      final XMLSerializer xml=new XMLSerializer(ao,sp);
      iter=ItemCache.get(xq.iter());
      for (Item it; (it=iter.next()) != null; ) {
        doc&=it.type == NodeType.DOC;
        it.serialize(xml);
      }
      xml.close();
    }
 catch (    final Exception ex) {
      if (!(ex instanceof QueryException || ex instanceof IOException)) {
        System.err.println("\n*** " + outname + " ***");
        System.err.println(in + "\n");
        ex.printStackTrace();
      }
      er=ex.getMessage();
      if (er.startsWith(STOPPED))       er=er.substring(er.indexOf('\n') + 1);
      if (er.startsWith("["))       er=er.replaceAll("\\[(.*?)\\] (.*)","$1 $2");
    }
    if (compile) {
      Util.errln("---------------------------------------------------------");
      Util.error(xq.info());
      Util.errln(in);
    }
    final Nodes expOut=nodes("*:output-file/text()",state);
    final TokenList result=new TokenList();
    for (int o=0; o < expOut.size(); ++o) {
      final String resFile=string(data.atom(expOut.list[o]));
      final IO exp=IO.get(expected + pth + resFile);
      result.add(read(exp));
    }
    final Nodes cmpFiles=nodes("*:output-file/@compare",state);
    boolean xml=false;
    boolean frag=false;
    boolean ignore=false;
    for (int o=0; o < cmpFiles.size(); ++o) {
      final byte[] type=data.atom(cmpFiles.list[o]);
      xml|=eq(type,XML);
      frag|=eq(type,FRAGMENT);
      ignore|=eq(type,IGNORE);
    }
    String expError=text("*:expected-error/text()",state);
    final StringBuilder log=new StringBuilder(pth + inname + IO.XQSUFFIX);
    if (files.size() != 0) {
      log.append(" [");
      log.append(files);
      log.append("]");
    }
    log.append(NL);
    log.append(norm(in));
    log.append(NL);
    final String logStr=log.toString();
    final boolean print=currTime || !logStr.contains("current-");
    boolean correctError=false;
    if (er != null && (expOut.size() == 0 || !expError.isEmpty())) {
      expError=error(pth + outname,expError);
      final String code=er.substring(0,Math.min(8,er.length()));
      for (      final String e : SLASH.split(expError)) {
        if (code.equals(e)) {
          correctError=true;
          break;
        }
      }
    }
    if (correctError) {
      if (print) {
        logOK.append(logStr);
        logOK.append("[Right] ");
        logOK.append(norm(er));
        logOK.append(NL);
        logOK.append(NL);
        addLog(pth,outname + ".log",er);
      }
      ++ok;
    }
 else     if (er == null) {
      int s=-1;
      final int rs=result.size();
      while (!ignore && ++s < rs) {
        inspect|=s < cmpFiles.list.length && eq(data.atom(cmpFiles.list[s]),INSPECT);
        final byte[] res=result.get(s), actual=ao.toArray();
        if (res.length == ao.size() && eq(res,actual))         break;
        if (xml || frag) {
          iter.reset();
          try {
            final ItemCache ic=toIter(string(res).replaceAll("^<\\?xml.*?\\?>","").trim(),frag);
            if (FNSimple.deep(null,iter,ic))             break;
            ic.reset();
            final ItemCache ia=toIter(string(actual),frag);
            if (FNSimple.deep(null,ia,ic))             break;
            if (debug) {
              iter.reset();
              ic.reset();
              final XMLSerializer ser=new XMLSerializer(System.out);
              Util.outln(NL + "=== " + testid+ " ===");
              for (Item it; (it=ic.next()) != null; )               it.serialize(ser);
              Util.outln(NL + "=== " + NAME+ " ===");
              for (Item it; (it=iter.next()) != null; )               it.serialize(ser);
              Util.outln();
            }
          }
 catch (          final IOException ex) {
          }
catch (          final Throwable ex) {
            System.err.println("\n" + outname + ":");
            ex.printStackTrace();
          }
        }
      }
      if ((rs > 0 || !expError.isEmpty()) && s == rs && !inspect) {
        if (print) {
          if (expOut.size() == 0)           result.add(error(pth + outname,expError));
          logErr.append(logStr);
          logErr.append("[" + testid + " ] ");
          logErr.append(norm(string(result.get(0))));
          logErr.append(NL);
          logErr.append("[Wrong] ");
          logErr.append(norm(ao.toString()));
          logErr.append(NL);
          logErr.append(NL);
          addLog(pth,outname + (xml ? IO.XMLSUFFIX : ".txt"),ao.toString());
        }
        correct=false;
        ++err;
      }
 else {
        if (print) {
          logOK.append(logStr);
          logOK.append("[Right] ");
          logOK.append(norm(ao.toString()));
          logOK.append(NL);
          logOK.append(NL);
          addLog(pth,outname + (xml ? IO.XMLSUFFIX : ".txt"),ao.toString());
        }
        ++ok;
      }
    }
 else {
      if (expOut.size() == 0 || !expError.isEmpty()) {
        if (print) {
          logOK2.append(logStr);
          logOK2.append("[" + testid + " ] ");
          logOK2.append(norm(expError));
          logOK2.append(NL);
          logOK2.append("[Rght?] ");
          logOK2.append(norm(er));
          logOK2.append(NL);
          logOK2.append(NL);
          addLog(pth,outname + ".log",er);
        }
        ++ok2;
      }
 else {
        if (print) {
          logErr2.append(logStr);
          logErr2.append("[" + testid + " ] ");
          logErr2.append(norm(string(result.get(0))));
          logErr2.append(NL);
          logErr2.append("[Wrong] ");
          logErr2.append(norm(er));
          logErr2.append(NL);
          logErr2.append(NL);
          addLog(pth,outname + ".log",er);
        }
        correct=false;
        ++err2;
      }
    }
    if (curr != null)     Close.close(curr.data,context);
    xq.close();
  }
  if (reporting) {
    logReport.append("    <test-case name=\"");
    logReport.append(outname);
    logReport.append("\" result='");
    logReport.append(correct ? "pass" : "fail");
    if (inspect)     logReport.append("' todo='inspect");
    logReport.append("'/>");
    logReport.append(NL);
  }
  if (verbose) {
    final long t=perf.getTime();
    if (t > 100000000)     Util.out(": " + Performance.getTimer(t,1));
    Util.outln();
  }
  return single == null || !outname.equals(single);
}
