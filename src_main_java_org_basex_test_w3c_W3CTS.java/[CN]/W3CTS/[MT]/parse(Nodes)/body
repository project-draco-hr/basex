{
  final String pth=text("@FilePath",root);
  final String outname=text("@name",root);
  if (single != null && !outname.startsWith(single))   return true;
  Performance perf=new Performance();
  if (verbose)   Main.out("- " + outname);
  boolean inspect=false;
  boolean correct=true;
  final Nodes nodes=states(root);
  for (int n=0; n < nodes.size(); ++n) {
    final Nodes state=new Nodes(nodes.nodes[n],nodes.data);
    final String inname=text("*:query/@name",state);
    context.query=IO.get(queries + pth + inname+ IO.XQSUFFIX);
    final String in=read(context.query);
    String er=null;
    ItemIter iter=null;
    boolean doc=true;
    final TokenBuilder files=new TokenBuilder();
    final CachedOutput co=new CachedOutput(1 << 19);
    final Nodes cont=nodes("*:contextItem",state);
    Nodes curr=null;
    if (cont.size() != 0) {
      final Data d=Check.check(context,srcs.get(string(data.atom(cont.nodes[0]))));
      curr=new Nodes(d.doc(),d);
      curr.doc=true;
    }
    context.prop.set(Prop.QUERYINFO,compile);
    final QueryProcessor xq=new QueryProcessor(in,curr,context);
    context.prop.set(Prop.QUERYINFO,false);
    try {
      files.add(file(nodes("*:input-file",state),nodes("*:input-file/@variable",state),xq,n == 0));
      files.add(file(nodes("*:defaultCollection",state),null,xq,n == 0));
      var(nodes("*:input-URI",state),nodes("*:input-URI/@variable",state),xq);
      eval(nodes("*:input-query/@name",state),nodes("*:input-query/@variable",state),pth,xq);
      parse(xq,state);
      for (      final int p : nodes("*:module",root).nodes) {
        final String ns=text("@namespace",new Nodes(p,data));
        final String f=mods.get(string(data.atom(p))) + IO.XQSUFFIX;
        xq.module(ns,f);
      }
      final SerializerProp sp=new SerializerProp();
      sp.set(SerializerProp.S_INDENT,context.prop.is(Prop.CHOP) ? DataText.YES : DataText.NO);
      final XMLSerializer xml=new XMLSerializer(co,sp);
      iter=ItemIter.get(xq.iter());
      Item it;
      while ((it=iter.next()) != null) {
        doc&=it.type == Type.DOC;
        it.serialize(xml);
      }
      xml.close();
    }
 catch (    final Exception ex) {
      if (!(ex instanceof QueryException || ex instanceof IOException))       ex.printStackTrace();
      er=ex.getMessage();
      if (er.startsWith(STOPPED))       er=er.substring(er.indexOf('\n') + 1);
      if (er.startsWith("["))       er=er.replaceAll("\\[(.*?)\\] (.*)","$1 $2");
    }
    if (compile) {
      Main.errln("---------------------------------------------------------");
      Main.err(xq.info());
      Main.errln(in);
    }
    final Nodes outFiles=nodes("*:output-file/text()",state);
    final Nodes cmpFiles=nodes("*:output-file/@compare",state);
    boolean xml=false;
    boolean frag=false;
    final TokenList result=new TokenList();
    for (int o=0; o < outFiles.size(); ++o) {
      final String resFile=string(data.atom(outFiles.nodes[o]));
      final IO exp=IO.get(expected + pth + resFile);
      result.add(read(exp));
      final byte[] type=data.atom(cmpFiles.nodes[o]);
      xml|=eq(type,XML);
      frag|=eq(type,FRAGMENT);
    }
    String expError=text("*:expected-error/text()",state);
    final StringBuilder log=new StringBuilder(pth + inname + IO.XQSUFFIX);
    if (files.size() != 0) {
      log.append(" [");
      log.append(files);
      log.append("]");
    }
    log.append(NL);
    log.append(norm(in));
    log.append(NL);
    final String logStr=log.toString();
    final boolean print=currTime || !logStr.contains("current-");
    boolean correctError=false;
    if (er != null && (outFiles.size() == 0 || !expError.isEmpty())) {
      expError=error(pth + outname,expError);
      final String code=er.substring(0,Math.min(8,er.length()));
      for (      final String e : SLASH.split(expError)) {
        if (code.equals(e)) {
          correctError=true;
          break;
        }
      }
    }
    if (correctError) {
      if (print) {
        logOK.append(logStr);
        logOK.append("[Right] ");
        logOK.append(norm(er));
        logOK.append(NL);
        logOK.append(NL);
        addLog(pth,outname + ".log",er);
      }
      ok++;
    }
 else     if (er == null) {
      int s=-1;
      final int rs=result.size();
      while (++s < rs) {
        inspect|=s < cmpFiles.nodes.length && eq(data.atom(cmpFiles.nodes[s]),INSPECT);
        final byte[] res=result.get(s);
        if (res.length == co.size() && eq(res,co.toArray()))         break;
        if (xml || frag) {
          iter.reset();
          String ri=string(res).trim();
          if (!doc) {
            if (ri.startsWith("<?xml"))             ri=ri.replaceAll("^<.*?>\\s*","");
            ri="<X>" + ri + "</X>";
          }
          try {
            final Data rdata=CreateDB.xml(IO.get(ri),context);
            final ItemIter ir=new ItemIter();
            for (int pre=doc ? 0 : 2; pre < rdata.meta.size; ) {
              ir.add(new DBNode(rdata,pre));
              pre+=rdata.size(pre,rdata.kind(pre));
            }
            final boolean eq=FNSimple.deep(null,iter,ir);
            if (!eq && debug) {
              iter.reset();
              ir.reset();
              final XMLSerializer ser=new XMLSerializer(System.out);
              Item it;
              Main.outln(NL + "=== " + testid+ " ===");
              while ((it=ir.next()) != null)               it.serialize(ser);
              Main.outln(NL + "=== " + NAME+ " ===");
              while ((it=iter.next()) != null)               it.serialize(ser);
              Main.outln();
            }
            rdata.close();
            if (eq)             break;
          }
 catch (          final Throwable ex) {
            ex.printStackTrace();
          }
        }
      }
      if ((rs > 0 || !expError.isEmpty()) && s == rs && !inspect) {
        if (print) {
          if (outFiles.size() == 0)           result.add(error(pth + outname,expError));
          logErr.append(logStr);
          logErr.append("[" + testid + " ] ");
          logErr.append(norm(string(result.get(0))));
          logErr.append(NL);
          logErr.append("[Wrong] ");
          logErr.append(norm(co.toString()));
          logErr.append(NL);
          logErr.append(NL);
          addLog(pth,outname + (xml ? IO.XMLSUFFIX : ".txt"),co.toString());
        }
        correct=false;
        err++;
      }
 else {
        if (print) {
          logOK.append(logStr);
          logOK.append("[Right] ");
          logOK.append(norm(co.toString()));
          logOK.append(NL);
          logOK.append(NL);
          addLog(pth,outname + (xml ? IO.XMLSUFFIX : ".txt"),co.toString());
        }
        ok++;
      }
    }
 else {
      if (outFiles.size() == 0 || !expError.isEmpty()) {
        if (print) {
          logOK2.append(logStr);
          logOK2.append("[" + testid + " ] ");
          logOK2.append(norm(expError));
          logOK2.append(NL);
          logOK2.append("[Rght?] ");
          logOK2.append(norm(er));
          logOK2.append(NL);
          logOK2.append(NL);
          addLog(pth,outname + ".log",er);
        }
        ok2++;
      }
 else {
        if (print) {
          logErr2.append(logStr);
          logErr2.append("[" + testid + " ] ");
          logErr2.append(norm(string(result.get(0))));
          logErr2.append(NL);
          logErr2.append("[Wrong] ");
          logErr2.append(norm(er));
          logErr2.append(NL);
          logErr2.append(NL);
          addLog(pth,outname + ".log",er);
        }
        correct=false;
        err2++;
      }
    }
    if (curr != null)     Close.close(context,curr.data);
    xq.close();
  }
  if (reporting) {
    logReport.append("    <test-case name=\"");
    logReport.append(outname);
    logReport.append("\" result='");
    logReport.append(correct ? "pass" : "fail");
    if (inspect)     logReport.append("' todo='inspect");
    logReport.append("'/>");
    logReport.append(NL);
  }
  if (verbose) {
    final long t=perf.getTime();
    if (t > 100000000)     Main.out(": " + Performance.getTimer(t,1));
    Main.outln();
  }
  return single == null || !outname.equals(single);
}
