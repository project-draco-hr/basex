{
  return new NodeIter(){
    final Pos[] posExpr=new Pos[preds.length];
    final long[] cPos=new long[preds.length];
    boolean skip;
    AxisIter ai;
    @Override public ANode next() throws QueryException {
      if (skip)       return null;
      if (ai == null) {
        ai=axis.iter(checkNode(qc));
        final int pl=preds.length;
        for (int p=0; p < pl; p++) {
          final Expr pred=preds[p];
          if (pred instanceof Pos) {
            posExpr[p]=(Pos)pred;
          }
 else           if (num(pred)) {
            final double dbl=toDouble(pred,qc);
            final long lng=(long)dbl;
            if (dbl != lng)             return null;
            final Expr e=Pos.get(lng,info);
            if (e instanceof Pos)             posExpr[p]=(Pos)e;
 else             return null;
          }
        }
      }
      for (ANode node; (node=ai.next()) != null; ) {
        qc.checkStop();
        if (test.eq(node) && preds(node))         return node.finish();
      }
      return null;
    }
    /** 
 * Evaluates the predicates.
 * @param node input node
 * @return result of check
 * @throws QueryException query exception
 */
    private boolean preds(    final ANode node) throws QueryException {
      final int pl=preds.length;
      for (int p=0; p < pl; p++) {
        final Expr pred=preds[p];
        final Pos pos=posExpr[p];
        if (pos == null) {
          qc.value=node;
          if (pred.test(qc,info) == null)           return false;
        }
 else {
          final long ps=++cPos[p];
          if (!pos.matches(ps))           return false;
          if (pos.skip(ps))           skip=true;
        }
      }
      return true;
    }
  }
;
}
