{
  final byte[] uri=name.uri();
  final byte[] ln=name.local();
  if (eq(uri,XSURI)) {
    final Type type=AtomType.find(name,true);
    if (type == null || type == AtomType.NOT || type == AtomType.AAT) {
      final Levenshtein ls=new Levenshtein();
      for (      final AtomType t : AtomType.values()) {
        if (t.par != null && ls.similar(lc(ln),lc(t.string()),0))         FUNSIMILAR.thrw(ii,name.string(),t.string());
      }
      FUNCUNKNOWN.thrw(ii,name.string());
    }
    if (args.length != 1)     FUNCTYPE.thrw(ii,name.string());
    final SeqType to=SeqType.get(type,Occ.ZO);
    return TypedFunc.constr(new Cast(ii,args[0],to),to);
  }
  if (startsWith(uri,JAVAPRE) && ctx.context.user.perm(User.ADMIN)) {
    return TypedFunc.java(JavaMapping.get(name,args,ctx,ii));
  }
  final StandardFunc fun=Functions.get().get(ln,uri,args,ctx,ii);
  if (fun != null) {
    for (    final Function f : Function.UPDATING) {
      if (fun.sig == f) {
        ctx.updating(true);
        break;
      }
    }
    return new TypedFunc(fun,fun.sig.type(args.length));
  }
  for (int l=0; l < func.length; ++l) {
    final QNm qn=func[l].name;
    if (eq(ln,qn.local()) && eq(uri,qn.uri()) && args.length == func[l].args.length)     return new TypedFunc(add(ii,qn,l,args),FuncType.get(func[l]));
  }
  if (!dyn && Types.find(name,false) == null) {
    return new TypedFunc(add(ii,name,add(new UserFunc(ii,name,new Var[args.length],null,null,false,false),ii),args),FuncType.arity(args.length));
  }
  return null;
}
