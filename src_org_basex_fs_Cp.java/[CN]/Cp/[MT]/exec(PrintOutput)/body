{
  String targetfile=paths.list[paths.size - 1];
  for (int p=0; p < paths.size - 1; p++) {
    String sourcefile=paths.list[p];
    final int[] sources=fs.children(curPre,sourcefile);
    sourcefile=sourcefile.substring(sourcefile.lastIndexOf('/') + 1);
    final int[] target=fs.children(curPre,targetfile);
    targetfile=targetfile.substring(targetfile.lastIndexOf('/') + 1);
    int preOfNewFile=4;
switch (sources.length) {
case 0:
      error(sourcefile,2);
    break;
case 1:
  if (fs.isDir(sources[0])) {
    if (fRecursive) {
      cpRecursive(sources[0],target,targetfile);
      break;
    }
 else {
      error(fs.name(sources[0]),100);
      break;
    }
  }
final byte[] size=fs.size(sources[0]);
final byte[] mtime=fs.currTime();
if (target.length == 1) {
if (fs.isDir(target[0])) {
final byte[] name=fs.name(sources[0]);
final byte[] suffix=fs.suffix(sources[0]);
if (!(target[0] == DataFS.ROOTDIR)) {
  preOfNewFile=target[0] + DataFS.NUMATT;
}
fs.insert(false,name,suffix,size,mtime,target[0],preOfNewFile);
}
 else {
fs.size(target[0],size);
fs.time(target[0],mtime);
}
}
 else {
final byte[] name=Token.token(targetfile);
final byte[] suffix=getSuffix(targetfile);
if (!(curPre == DataFS.ROOTDIR)) {
preOfNewFile=curPre + DataFS.NUMATT;
}
fs.insert(false,name,suffix,size,mtime,curPre,preOfNewFile);
}
break;
default :
if (target.length != 1) {
error("",99);
break;
}
if (fs.isFile(target[0])) {
error(fs.name(target[0]),20);
break;
}
if (!(target[0] == DataFS.ROOTDIR)) {
preOfNewFile=target[0] + DataFS.NUMATT;
}
final TokenList toInsert=new TokenList();
int sizeToAdd=0;
for (int i : sources) {
i+=sizeToAdd;
if (fs.isDir(i)) {
if (fRecursive) {
sizeToAdd+=fs.data.size(i,Data.ELEM);
cpRecursive(i,target,"");
continue;
}
 else {
error(fs.name(i),100);
continue;
}
}
toInsert.add(fs.name(i));
toInsert.add(fs.suffix(i));
toInsert.add(fs.size(i));
}
for (int j=0; j < toInsert.size; ++j) {
fs.insert(false,toInsert.delete(0),toInsert.delete(0),toInsert.delete(0),fs.currTime(),target[0],preOfNewFile);
}
break;
}
}
fs.flush();
}
