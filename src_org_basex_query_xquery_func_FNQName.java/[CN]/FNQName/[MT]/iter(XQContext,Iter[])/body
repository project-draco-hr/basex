{
switch (func) {
case RESQNAME:
    Item it=arg[0].atomic(this,true);
  if (it == null)   return Iter.EMPTY;
QNm name=new QNm(Token.trim(checkStr(it)),ctx);
byte[] pre=name.pre();
it=arg[1].atomic(this,false);
final Nod n=(Nod)check(it,Type.ELM);
name.uri=n.qname().uri;
if (name.uri != Uri.EMPTY) return name.iter();
Item i;
final Iter iter=inscope(ctx,n);
while ((i=iter.next()) != null) {
final byte[] ns=i.str();
if (ns.length == 0) continue;
if (Token.eq(pre,ns)) {
name.uri=ctx.ns.uri(ns);
return name.iter();
}
}
if (pre.length != 0) Err.or(NSDECL,pre);
name.uri=ctx.nsElem;
return name.iter();
case QNAME:
it=arg[0].atomic(this,true);
final Uri uri=Uri.uri(it == null ? Token.EMPTY : check(it,Type.STR).str());
it=arg[1].atomic(this,true);
it=it == null ? Str.ZERO : check(it,Type.STR);
final byte[] str=it.str();
if (!XMLToken.isQName(str)) Err.value(Type.QNM,it);
name=new QNm(str,uri);
if (name.ns()) {
if (uri == Uri.EMPTY || name.pre().length == 0) Err.value(Type.QNM,name);
ctx.ns.index(name);
}
return name.iter();
case LOCNAMEQNAME:
it=arg[0].atomic(this,true);
if (it == null) return Iter.EMPTY;
return new NCN(((QNm)check(it,Type.QNM)).ln()).iter();
case PREQNAME:
it=arg[0].atomic(this,true);
if (it == null) return Iter.EMPTY;
name=(QNm)check(it,Type.QNM);
return !name.ns() ? Iter.EMPTY : new NCN(name.pre()).iter();
case NSURIPRE:
it=arg[1].atomic(this,false);
check(it,Type.ELM);
try {
pre=checkStr(arg[0]);
return (pre.length == 0 ? ctx.nsElem : ctx.ns.uri(pre)).iter();
}
 catch (final XQException e) {
return Iter.EMPTY;
}
case INSCOPE:
it=arg[0].atomic(this,false);
return inscope(ctx,(Nod)check(it,Type.ELM));
case RESURI:
it=arg[0].atomic(this,true);
if (it == null) return Iter.EMPTY;
final Uri rel=Uri.uri(checkStr(it));
if (!rel.valid()) Err.or(URIINV,it);
final Uri base=arg.length == 1 ? ctx.baseURI : Uri.uri(checkStr(arg[1].atomic(this,false)));
if (!base.valid()) Err.or(URIINV,base);
return base.resolve(rel).iter();
default :
throw new RuntimeException("Not defined: " + func);
}
}
