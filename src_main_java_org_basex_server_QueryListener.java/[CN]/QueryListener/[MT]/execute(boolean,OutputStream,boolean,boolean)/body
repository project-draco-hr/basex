{
  check();
  boolean init=false;
  try {
    init();
    try {
      ctx.register(qp);
      init=true;
      qp.compile();
      qi.cmpl=perf.time();
      final Iter ir=qp.iter();
      qi.evlt=perf.time();
      final boolean wrap=!options.get(S_WRAP_PREFIX).isEmpty();
      final PrintOutput po=PrintOutput.get(enc ? new EncodingOutput(out) : out);
      if (iter && wrap)       po.write(1);
      final Serializer ser=Serializer.get(po,full ? null : options);
      int c=0;
      for (Item it; (it=ir.next()) != null; ) {
        if (iter && !wrap) {
          if (full) {
            po.write(it.xdmInfo());
          }
 else {
            po.write(it.typeId().asByte());
          }
          ser.reset();
        }
        ser.serialize(it);
        if (iter && !wrap) {
          po.flush();
          out.write(0);
        }
        c++;
      }
      ser.close();
      if (iter && wrap)       out.write(0);
      qi.srlz=perf.time();
      info=qi.toString(qp,po,c,ctx.prop.is(Prop.QUERYINFO));
    }
 catch (    final QueryException ex) {
      throw new BaseXException(ex);
    }
catch (    final StackOverflowError ex) {
      Util.debug(ex);
      throw new BaseXException(BASX_STACKOVERFLOW.desc);
    }
catch (    final ProgressException ex) {
      throw new BaseXException(TIMEOUT_EXCEEDED);
    }
  }
  finally {
    qp.close();
    closed=true;
    if (init)     ctx.unregister(qp);
  }
}
