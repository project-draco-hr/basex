{
  final int runs=Math.max(1,prop.num(Prop.RUNS));
  String err=null;
  String inf="";
  try {
    final boolean serial=prop.is(Prop.SERIALIZE);
    long hits=0;
    int updates=0;
    for (int i=0; i < runs; ++i) {
      final Performance per=new Performance();
      qp=progress(new QueryProcessor(query,context));
      qp.parse();
      pars+=per.getTime();
      if (i == 0)       plan(false);
      qp.compile();
      comp+=per.getTime();
      if (i == 0)       plan(true);
      final PrintOutput po=i == 0 && serial ? out : new NullOutput();
      Serializer ser;
      if (prop.is(Prop.CACHEQUERY)) {
        result=qp.execute();
        eval+=per.getTime();
        ser=qp.getSerializer(po);
        result.serialize(ser);
        hits=result.size();
      }
 else {
        final Iter ir=qp.iter();
        eval+=per.getTime();
        hits=0;
        Item it=ir.next();
        ser=qp.getSerializer(po);
        while (it != null) {
          checkStop();
          ser.openResult();
          it.serialize(ser);
          ser.closeResult();
          it=ir.next();
          ++hits;
        }
      }
      updates=qp.updates();
      ser.close();
      qp.close();
      prnt+=per.getTime();
    }
    if (prop.is(Prop.QUERYINFO))     evalInfo(query,hits,updates,runs);
    out.flush();
    return info(NL + QUERYEXEC,perf.getTimer(runs));
  }
 catch (  final QueryException ex) {
    Util.debug(ex);
    err=ex.getMessage();
  }
catch (  final IOException ex) {
    Util.debug(ex);
    err=ex.getMessage();
  }
catch (  final ProgressException ex) {
    err=PROGERR;
    inf=info();
  }
catch (  final RuntimeException ex) {
    Util.debug(qp.info());
    throw ex;
  }
  if (qp != null)   try {
    qp.close();
  }
 catch (  final IOException ex) {
  }
  error(err);
  if (Util.debug || err.startsWith(PROGERR)) {
    info(NL);
    info(QUERYSTRING + query);
    info(qp.info());
    info(inf);
  }
  return false;
}
