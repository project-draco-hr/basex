{
  final Performance p=new Performance();
  String err;
  if (qe != null) {
    err=qe.getMessage();
  }
 else {
    try {
      final boolean serial=prop.is(Prop.SERIALIZE);
      long hits=0;
      int updates=0;
      final int runs=Math.max(1,prop.num(Prop.RUNS));
      for (int r=0; r < runs; ++r) {
        if (r != 0)         qp=null;
        qp=queryProcessor(query,context);
        qp.parse();
        pars+=init + p.time();
        init=0;
        if (r == 0)         plan(false);
        qp.compile();
        comp+=p.time();
        if (r == 0)         plan(true);
        final PrintOutput po=r == 0 && serial ? out : new NullOutput();
        final Serializer ser;
        if (prop.is(Prop.CACHEQUERY)) {
          result=qp.execute();
          eval+=p.time();
          ser=qp.getSerializer(po);
          result.serialize(ser);
          hits=result.size();
        }
 else {
          final Iter ir=qp.iter();
          eval+=p.time();
          hits=0;
          Item it=ir.next();
          ser=qp.getSerializer(po);
          while (it != null) {
            checkStop();
            ser.serialize(it);
            it=ir.next();
            ++hits;
          }
        }
        updates=qp.updates();
        ser.close();
        qp.close();
        prnt+=p.time();
      }
      if (prop.is(Prop.QUERYINFO))       evalInfo(query,hits,updates,runs);
      out.flush();
      final long time=pars + comp + eval+ prnt;
      return info(NL + QUERY_EXECUTED_X,Performance.getTime(time,runs));
    }
 catch (    final QueryException ex) {
      Util.debug(ex);
      err=ex.getMessage();
      final String stack=ex.getStack();
      if (!stack.isEmpty())       err+=NL + NL + STACK_TRACE_C+ stack;
    }
catch (    final IOException ex) {
      Util.debug(ex);
      err=Util.message(ex);
    }
catch (    final ProgressException ex) {
      err=INTERRUPTED;
    }
catch (    final RuntimeException ex) {
      Util.debug(info() + NL + qp.info());
      throw ex;
    }
catch (    final StackOverflowError ex) {
      Util.debug(ex);
      err=CIRCLDECL.desc;
    }
 finally {
      if (qp != null)       qp.close();
    }
  }
  if (prop.is(Prop.QUERYINFO)) {
    final StringBuilder sb=new StringBuilder();
    final String info=info();
    if (!info.isEmpty())     sb.append(info);
    sb.append(NL + QUERY_CC + query);
    final String i=qp.info();
    if (!i.isEmpty())     sb.append(i);
    err=sb.append(NL + ERROR_C + NL+ err).toString();
  }
  return error(err);
}
