{
  final Data data=context.data();
  final int pos=Token.toInt(args[0]);
  if (pos < 0)   return error(POSINVALID,args[0]);
  Nodes src;
  Nodes trg;
  if (Prop.gui) {
    src=context.copied();
    trg=context.marked();
    context.copy(null);
  }
 else {
    src=query(args[1],null);
    trg=query(args[2],COPYTAGS);
    if (src == null || trg == null)     return false;
  }
  data.meta.update();
  final int size=src.size();
  final Data[] srcDocs=new Data[src.size()];
  for (int c=0; c < size; c++)   srcDocs[c]=copy(src.data,src.nodes[c]);
  final IntList marked=Prop.gui ? new IntList() : null;
  int copied=0;
  for (int n=trg.size() - 1; n >= 0; n--) {
    final int par=trg.nodes[n];
    if (data.kind(par) != Data.ELEM)     return error(COPYTAGS);
    for (int c=0; c < size; c++) {
      final int pre=pre(par,pos,data);
      final int s=srcDocs[c].meta.size - 1;
      final int up=s != 0 ? -1 : Insert.checkText(data,pre,par,srcDocs[c].kind(s));
      if (up != -1) {
        data.update(up,Token.concat(data.text(up),srcDocs[c].text(s)));
        if (Prop.gui && !marked.contains(up))         marked.add(up);
      }
 else {
        data.insert(pre,par,srcDocs[c]);
        if (Prop.gui)         marked.add(pre);
      }
    }
    copied+=size;
  }
  if (Prop.gui) {
    if (context.current().size() > 1 || context.current().nodes[0] == src.nodes[0]) {
      context.current(new Nodes(0,data));
    }
    context.marked(new Nodes(marked.finish(),data));
  }
  data.flush();
  return Prop.info ? info(INSERTINFO,copied,perf.getTimer()) : true;
}
