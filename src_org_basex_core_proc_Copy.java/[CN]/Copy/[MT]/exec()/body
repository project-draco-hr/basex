{
  final Data data=context.data();
  final int pos=Token.toInt(args[0]);
  if (pos < 0)   return error(POSINVALID,args[0]);
  Nodes source;
  Nodes target;
  if (gui) {
    source=context.copied();
    target=context.marked();
    context.copy(null);
  }
 else {
    query(args[1],null);
    source=(Nodes)result;
    query(args[2],COPYTAGS);
    target=(Nodes)result;
  }
  if (source == null || target == null)   return false;
  data.noIndex();
  final int size=source.size;
  final Data[] srcDocs=new Data[source.size];
  for (int c=0; c < size; c++) {
    srcDocs[c]=copy(source.data,source.nodes[c]);
  }
  final IntList marked=gui ? new IntList() : null;
  int copied=0;
  for (int n=target.size - 1; n >= 0; n--) {
    final int par=target.nodes[n];
    if (data.kind(par) != Data.ELEM)     return error(COPYTAGS);
    for (int c=0; c < size; c++) {
      final int pre=pre(par,pos,data);
      final int s=srcDocs[c].size - 1;
      final int up=s != 0 ? -1 : Insert.checkText(data,pre,par,srcDocs[c].kind(s));
      if (up != -1) {
        data.update(up,Token.concat(data.text(up),srcDocs[c].text(s)));
        if (gui && !marked.contains(up))         marked.add(up);
      }
 else {
        data.insert(pre,par,srcDocs[c]);
        if (gui)         marked.add(pre);
      }
    }
    copied+=size;
  }
  if (gui) {
    if (context.current().size > 1 || context.current().nodes[0] == source.nodes[0]) {
      context.current(new Nodes(0,data));
    }
    context.marked(new Nodes(marked.finish(),data));
  }
  data.flush();
  return Prop.info ? info(INSERTINFO,copied,perf.getTimer()) : true;
}
