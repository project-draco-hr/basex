{
  final byte[] query=toToken(exprs[0],qc);
  final HashMap<String,Value> bindings=toBindings(1,qc);
  final AsyncOptions opts=new AsyncOptions();
  if (exprs.length > 2)   toOptions(2,null,opts,qc);
  final String uri=opts.get(AsyncOptions.BASE_URI);
  final boolean cache=opts.get(AsyncOptions.CACHE);
  final Context ctx=qc.context;
  final QueryPool queries=ctx.queries;
  final QueryProcessor qp=new QueryProcessor(string(query),ctx);
  for (  final Entry<String,Value> it : bindings.entrySet()) {
    final String key=it.getKey();
    final Value val=queries.copy(it.getValue().iter(),ctx);
    if (key.isEmpty())     qp.context(val);
 else     qp.bind(key,val);
  }
  final String path=ctx.options.get(MainOptions.QUERYPATH);
  if (uri != null)   ctx.options.set(MainOptions.QUERYPATH,uri);
  try {
    qp.parse();
  }
  finally {
    ctx.options.set(MainOptions.QUERYPATH,path);
  }
  if (updating) {
    if (!sc.mixUpdates && !qp.qc.updating && !qp.qc.root.expr.isVacuous())     throw ASYNC_NONUPDATING.get(info);
  }
 else {
    if (qp.qc.updating)     throw ASYNC_UPDATING.get(info);
  }
  return Str.get(queries.add(qp,cache,info));
}
