{
  final Constr c=new Constr(ii,sc).add(ctx,expr[1]);
  if (c.errAtt)   throw UPNOATTRPER.get(info);
  if (c.duplAtt != null)   throw UPATTDUPL.get(info,new QNm(c.duplAtt));
  final Iter t=ctx.iter(expr[0]);
  final Item i=t.next();
  if (i == null)   throw UPSEQEMP.get(info,Util.className(this));
  final Type tp=i.type;
  if (!(i instanceof ANode) || tp == NodeType.DOC || t.next() != null)   throw UPTRGMULT.get(info);
  final ANode targ=(ANode)i;
  final Updates updates=ctx.resources.updates();
  final DBNode dbn=updates.determineDataRef(targ,ctx);
  final ANodeList aList=c.atts;
  ANodeList list=c.children;
  if (value) {
    final byte[] txt=list.size() < 1 ? aList.size() < 1 ? EMPTY : aList.get(0).string() : list.get(0).string();
    if (tp == NodeType.COM)     FComm.parse(txt,info);
    if (tp == NodeType.PI)     FPI.parse(txt,info);
    updates.add(new ReplaceValue(dbn.pre,dbn.data,info,txt),ctx);
  }
 else {
    final ANode par=targ.parent();
    if (par == null)     throw UPNOPAR.get(info,i);
    if (tp == NodeType.ATT) {
      if (!list.isEmpty())       throw UPWRATTR.get(info);
      list=checkNS(aList,par);
    }
 else {
      if (!aList.isEmpty())       throw UPWRELM.get(info);
    }
    updates.add(new ReplaceNode(dbn.pre,dbn.data,info,list),ctx);
  }
  return null;
}
