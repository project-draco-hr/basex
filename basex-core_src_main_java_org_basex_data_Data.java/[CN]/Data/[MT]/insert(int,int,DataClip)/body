{
  meta.update();
  if (meta.updindex)   indexBegin();
  resources.insert(pre,source);
  final int sCount=source.size();
  final int bSize=Math.min(sCount,IO.BLOCKSIZE >> IO.NODEPOWER);
  bufferSize(bSize);
  final NSScope nsScope=new NSScope(pre,this);
  final Data sdata=source.data;
  int c=0, sTopPre=source.start;
  for (int sPre=sTopPre; sPre < source.end; ++sPre, ++c) {
    if (c != 0 && c % bSize == 0)     insert(pre + c - bSize);
    final int sKind=sdata.kind(sPre);
    final int sSize=sdata.size(sPre,sKind);
    final int sPar=sdata.parent(sPre,sKind);
    final int nPre=pre + c, nDist;
    if (sPre == sTopPre) {
      nDist=nPre - par;
      sTopPre+=sSize;
    }
 else {
      nDist=sPre - sPar;
    }
    final int nsPre=sKind == DOC ? -1 : nPre - nDist;
    nsScope.loop(nsPre,c);
switch (sKind) {
case DOC:
      nsScope.open(nPre);
    doc(nPre,sSize,sdata.text(sPre,true));
  ++meta.ndocs;
break;
case ELEM:
final boolean nsFlag=nsScope.open(nPre,sdata.namespaces(sPre));
final byte[] en=sdata.name(sPre,sKind);
elem(nDist,elemNames.index(en,null,false),sdata.attSize(sPre,sKind),sSize,nspaces.uriIdForPrefix(prefix(en),true),nsFlag);
break;
case TEXT:
case COMM:
case PI:
text(nPre,nDist,sdata.text(sPre,true),sKind);
break;
case ATTR:
final byte[] an=sdata.name(sPre,sKind);
final int uriId=sdata.uriId(sPre,sKind);
if (uriId != 0 && nsScope.openAttr(nsPre,prefix(an),sdata.nspaces.uri(uriId))) {
table.write2(nsPre,1,1 << 15 | nameId(nsPre));
}
attr(nPre,nDist,attrNames.index(an,null,false),sdata.text(sPre,false),nspaces.uriIdForPrefix(prefix(an),false));
}
nsScope.shift(1);
}
nsScope.close();
if (bp != 0) insert(pre + c - 1 - (c - 1) % bSize);
bufferSize(1);
int cPre=par;
while (cPre >= 0) {
final int cKind=kind(cPre);
size(cPre,cKind,size(cPre,cKind) + sCount);
cPre=parent(cPre,cKind);
}
if (meta.updindex) {
idmap.insert(pre,id(pre),sCount);
indexAdd();
}
if (!cache) updateDist(pre + sCount,sCount);
}
