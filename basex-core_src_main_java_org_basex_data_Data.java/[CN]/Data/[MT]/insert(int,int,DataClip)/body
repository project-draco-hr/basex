{
  meta.update();
  if (meta.updindex)   indexBegin();
  resources.insert(pre,source);
  final int sCount=source.size();
  final int bSize=Math.min(sCount,IO.BLOCKSIZE >> IO.NODEPOWER);
  bufferSize(bSize);
  final TokenMap nsScope=nspaces.scope(par,this);
  final IntList preStack=new IntList();
  final NSNode nsCursor=nspaces.cursor();
  final List<NSNode> nsNodeCache=nspaces.cache(pre);
  final Data sdata=source.data;
  int c=0, sTopPre=source.start;
  for (int sPre=sTopPre; sPre < source.end; ++sPre, ++c) {
    if (c != 0 && c % bSize == 0)     insert(pre + c - bSize);
    final int sKind=sdata.kind(sPre);
    final int sSize=sdata.size(sPre,sKind);
    final int sPar=sdata.parent(sPre,sKind);
    final int cPre=pre + c, cDist;
    if (sPre == sTopPre) {
      cDist=cPre - par;
      sTopPre+=sSize;
    }
 else {
      cDist=sPre - sPar;
    }
    final int nsPre=sKind == DOC ? -1 : cPre - cDist;
    if (c == 0)     nspaces.root(nsPre,this);
    while (!preStack.isEmpty() && preStack.peek() > nsPre)     nspaces.close(preStack.pop());
switch (sKind) {
case DOC:
      nspaces.open();
    doc(cPre,sSize,sdata.text(sPre,true));
  ++meta.ndocs;
preStack.push(cPre);
break;
case ELEM:
final Atts nsp=new Atts();
if (sdata.nsFlag(sPre)) {
final Atts sNsp=sdata.namespaces(sPre);
final int as=sNsp.size();
for (int a=0; a < as; a++) {
final byte[] prefix=sNsp.name(a), uri=sNsp.value(a), ancUri=nsScope.get(prefix);
if (ancUri == null || !eq(ancUri,uri)) nsp.add(prefix,uri);
}
}
nspaces.open(cPre,nsp);
final byte[] en=sdata.name(sPre,sKind);
elem(cDist,elemNames.index(en,null,false),sdata.attSize(sPre,sKind),sSize,nspaces.uriId(en,true),!nsp.isEmpty());
preStack.push(cPre);
break;
case TEXT:
case COMM:
case PI:
text(cPre,cDist,sdata.text(sPre,true),sKind);
break;
case ATTR:
final byte[] an=sdata.name(sPre,sKind), prefix=prefix(an);
if (sdata.nsFlag(sPre) && nsScope.get(prefix) == null) {
final byte[] attUri=sdata.nspaces.uri(sdata.uriId(sPre,sKind));
nspaces.add(nsPre,-1,prefix,attUri,this);
table.write2(nsPre,1,nameId(nsPre) | 1 << 15);
}
attr(cPre,cDist,attrNames.index(an,null,false),sdata.text(sPre,false),nspaces.uriId(an,false),false);
break;
}
for (final NSNode node : nsNodeCache) node.incrementPre(1);
}
while (!preStack.isEmpty()) nspaces.close(preStack.pop());
nspaces.current(nsCursor);
if (bp != 0) insert(pre + c - 1 - (c - 1) % bSize);
bufferSize(1);
int cPre=par;
while (cPre >= 0) {
final int cKind=kind(cPre);
size(cPre,cKind,size(cPre,cKind) + sCount);
cPre=parent(cPre,cKind);
}
if (meta.updindex) {
idmap.insert(pre,id(pre),sCount);
indexAdd();
}
if (!cache) updateDist(pre + sCount,sCount);
}
