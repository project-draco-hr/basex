{
  meta.update();
  final int size=source.size();
  final Data data=source.data;
  final int tkind=kind(tpre);
  final int tsize=size(tpre,tkind);
  final int tpar=parent(tpre,tkind);
  final int diff=size - tsize;
  buffer(size);
  resources.replace(tpre,tsize,source);
  if (meta.updindex) {
    indexDelete(tpre,tsize);
    indexBegin();
  }
  int sTopPre=source.start;
  for (int spre=sTopPre; spre < source.end; ++spre) {
    final int kind=data.kind(spre);
    final int ssize=data.size(spre,kind);
    final int spar=data.parent(spre,kind);
    final int pre=tpre + spre - source.start;
    final int dist;
    if (spre == sTopPre) {
      dist=pre - tpar;
      sTopPre+=ssize;
    }
 else {
      dist=spre - spar;
    }
switch (kind) {
case DOC:
      doc(pre,ssize,data.text(spre,true));
    meta.ndocs++;
  break;
case ELEM:
byte[] nm=data.name(spre,kind);
elem(dist,elemNames.index(nm,null,false),data.attSize(spre,kind),ssize,nspaces.uri(nm,true),false);
break;
case TEXT:
case COMM:
case PI:
text(pre,dist,data.text(spre,true),kind);
break;
case ATTR:
nm=data.name(spre,kind);
attr(pre,dist,attrNames.index(nm,null,false),data.text(spre,false),nspaces.uri(nm,false),false);
break;
}
}
if (meta.updindex) {
indexEnd();
idmap.delete(tpre,id(tpre),-tsize);
idmap.insert(tpre,meta.lastid - size + 1,size);
}
table.replace(tpre,buffer(),tsize);
buffer(1);
if (diff == 0) return;
int p=tpar;
while (p >= 0) {
final int k=kind(p);
size(p,k,size(p,k) + diff);
p=parent(p,k);
}
if (!cache) updateDist(tpre + size,diff);
int spre=source.start;
if (data.kind(spre) == ATTR) {
int d=0;
while (spre < source.end && data.kind(spre++) == ATTR) d++;
if (d > 1) attSize(tpar,kind(tpar),d + attSize(tpar,ELEM) - 1);
}
}
