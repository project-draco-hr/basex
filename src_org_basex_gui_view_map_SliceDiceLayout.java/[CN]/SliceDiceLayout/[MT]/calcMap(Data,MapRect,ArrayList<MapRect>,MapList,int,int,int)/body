{
  if (ne - ns == 1) {
    putRect(d,r,mainRects,l,ns,level);
  }
 else {
    final boolean v=(level % 2) == 0 ? true : false;
    if (level == 0) {
      splitUniformly(d,r,mainRects,l,ns,ne,level,v);
    }
 else {
      int par=d.parent(l.list[ns],d.kind(l.list[ns]));
      ;
      long parsize=d.fs != null ? Token.toLong(d.attValue(d.sizeID,par)) : 0;
      int parchildren=l.list[ne] - l.list[ns];
      double xx=r.x;
      double yy=r.y;
      double ww=0;
      double hh=0;
      for (int i=0; i < l.size - 1; i++) {
        long size=d.fs != null ? Token.toLong(d.attValue(d.sizeID,l.list[i])) : 0;
        int children=l.list[i + 1] - l.list[i];
        double weight=calcWeight(size,children,parsize,parchildren,d);
        if (v) {
          yy+=hh;
          hh=weight * r.h;
          ww=r.w;
        }
 else {
          xx+=ww;
          ww=weight * r.w;
          hh=r.h;
        }
        int[] liste=new int[1];
        liste[0]=l.list[i];
        if (ww > 0 && hh > 0)         calcMap(d,new MapRect((int)xx,(int)yy,(int)ww,(int)hh,0,r.level),mainRects,new MapList(liste),0,1,level);
      }
    }
  }
}
