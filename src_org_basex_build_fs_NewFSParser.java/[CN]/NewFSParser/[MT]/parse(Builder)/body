{
  builder=build;
  builder.encoding(Prop.ENCODING);
  builder.meta.mount=mountpoint;
  builder.meta.backing=fsimportpath;
  builder.meta.deepfs=true;
  builder.startDoc(token(io.name()));
  if (singlemode) {
    file(new File(io.path()).getCanonicalFile());
  }
 else {
    atts.reset();
    final byte[] mnt=prop.is(Prop.FUSE) ? token(mountpoint) : NOTMOUNTED;
    atts.add(MOUNTPOINT,mnt);
    atts.add(BACKINGSTORE,token(fsimportpath));
    atts.add(SIZE,ZERO);
    builder.startNS(FS,FSURL);
    if (prop.is(Prop.FSMETA)) {
      builder.startNS(FSMETAPREF,FSMETAURL);
      builder.startNS(FSDCPREF,FSDCURL);
    }
    if (ADD_ATTS) {
      builder.startNS(FSXSIPREF,FSXSIURL);
    }
    final int sizeAttId=builder.startElem(DEEPFS_NS,atts) + 3;
    for (    final File f : root ? File.listRoots() : new File[]{new File(fsimportpath).getCanonicalFile()}) {
      if (f.isHidden() && !f.getAbsolutePath().equals("C:\\"))       continue;
      sizeStack[0]=0;
      for (      final File file : f.listFiles()) {
        if (!valid(file) || file.isHidden())         continue;
        if (file.isDirectory())         dir(file);
 else         file(file);
      }
    }
    setSize(sizeAttId,sizeStack[0]);
    builder.endElem(DEEPFS_NS);
  }
  builder.endDoc();
}
