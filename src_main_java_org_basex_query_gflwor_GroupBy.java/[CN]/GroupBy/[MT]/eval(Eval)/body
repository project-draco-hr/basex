{
  return new Eval(){
    /** 
 * Groups to iterate over. 
 */
    private Group[] groups;
    /** 
 * Current position. 
 */
    private int pos;
    @Override public boolean next(    final QueryContext ctx) throws QueryException {
      if (groups == null)       init(ctx);
      if (pos == groups.length)       return false;
      final Group curr=groups[pos];
      groups[pos++]=null;
      int p=0;
      for (      final Spec spec : specs) {
        if (!spec.occluded) {
          final Item key=curr.key[p++];
          ctx.set(spec.var,key == null ? Empty.SEQ : key,info);
        }
      }
      for (int i=0; i < post.length; i++)       ctx.set(post[i],curr.ngv[i].value(),info);
      return true;
    }
    /** 
 * Initializes the groups.
 * @param ctx query context
 * @throws QueryException query exception
 */
    private void init(    final QueryContext ctx) throws QueryException {
      final ArrayList<Group> grps=new ArrayList<Group>();
      final IntMap<Group> map=new IntMap<Group>();
      while (sub.next(ctx)) {
        final Item[] key=new Item[nonOcc];
        final Collation[] colls=new Collation[nonOcc];
        int p=0, hash=1;
        for (        final Spec spec : specs) {
          final Item ki=spec.item(ctx,info), atom=ki == null ? null : StandardFunc.atom(ki,info);
          if (!spec.occluded) {
            key[p]=atom;
            colls[p++]=spec.coll;
            hash=31 * hash + (atom == null ? 0 : atom.hash(info));
          }
          ctx.set(spec.var,atom == null ? Empty.SEQ : atom,info);
        }
        final Group fst=map.get(hash);
        Group grp=null;
        for (Group g=fst; g != null; g=g.next) {
          if (eq(key,g.key,colls)) {
            grp=g;
            break;
          }
        }
        if (grp == null) {
          final ValueBuilder[] ngs=new ValueBuilder[preExpr.length];
          for (int i=0; i < ngs.length; i++)           ngs[i]=new ValueBuilder();
          grp=new Group(key,ngs);
          grps.add(grp);
          if (fst == null) {
            map.add(hash,grp);
          }
 else {
            final Group nxt=fst.next;
            fst.next=grp;
            grp.next=nxt;
          }
        }
        for (int j=0; j < preExpr.length; j++)         grp.ngv[j].add(preExpr[j].value(ctx));
      }
      groups=grps.toArray(new Group[grps.size()]);
    }
  }
;
}
