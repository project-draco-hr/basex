{
  if (modifier(e))   return;
  if (PREVTAB.is(e)) {
    transferFocusBackward();
    return;
  }
  if (NEXTTAB.is(e)) {
    transferFocus();
    return;
  }
  if (FIND.is(e)) {
    if (find != null)     find.requestFocusInWindow();
    return;
  }
  cursor(true);
  final int fh=rend.fontH();
  if (SCROLLDOWN.is(e)) {
    scroll.pos(scroll.pos() + fh);
    return;
  }
  if (SCROLLUP.is(e)) {
    scroll.pos(scroll.pos() - fh);
    return;
  }
  if (COPY1.is(e) || COPY2.is(e)) {
    copy();
    return;
  }
  final int pc=text.cursor();
  text.pos(pc);
  if (!PREVLINE.is(e) && !NEXTLINE.is(e))   lastCol=-1;
  if (FINDNEXT.is(e) || FINDNEXT2.is(e)) {
    scroll(rend.find(true,true));
    return;
  }
  if (FINDPREV.is(e) || FINDPREV2.is(e)) {
    scroll(rend.find(false,true));
    return;
  }
  if (SELECTALL.is(e)) {
    selectAll();
    return;
  }
  final boolean marking=e.isShiftDown() && !DELNEXT.is(e) && !DELPREV.is(e)&& !PASTE2.is(e)&& !COMMENT.is(e)&& !DELLINE.is(e)&& !REDOSTEP.is(e);
  final boolean nomark=!text.marking();
  if (marking && nomark)   text.startMark();
  boolean down=true;
  boolean consumed=true;
  final byte[] txt=text.text();
  if (NEXTWORD.is(e)) {
    text.nextToken(marking);
  }
 else   if (PREVWORD.is(e)) {
    text.prevToken(marking);
    down=false;
  }
 else   if (TEXTSTART.is(e)) {
    if (!marking)     text.noMark();
    text.pos(0);
    down=false;
  }
 else   if (TEXTEND.is(e)) {
    if (!marking)     text.noMark();
    text.pos(text.size());
  }
 else   if (LINESTART.is(e)) {
    text.bol(marking);
    down=false;
  }
 else   if (LINEEND.is(e)) {
    text.eol(marking);
  }
 else   if (NEXTPAGE.is(e)) {
    down(getHeight() / fh,marking);
  }
 else   if (PREVPAGE.is(e)) {
    up(getHeight() / fh,marking);
    down=false;
  }
 else   if (NEXT.is(e)) {
    text.next(marking);
  }
 else   if (PREV.is(e)) {
    text.prev(marking);
    down=false;
  }
 else   if (PREVLINE.is(e)) {
    up(1,marking);
    down=false;
  }
 else   if (NEXTLINE.is(e)) {
    down(1,marking);
  }
 else   if (FINDERROR.is(e)) {
    final int p=text.error();
    if (p != -1)     setCaret(p);
  }
 else {
    consumed=false;
  }
  if (marking) {
    text.endMark();
    text.checkMark();
  }
 else   if (hist.active()) {
    if (CUT1.is(e) || CUT2.is(e)) {
      if (copy())       text.delete();
    }
 else     if (PASTE1.is(e) || PASTE2.is(e)) {
      final String clip=clip();
      if (clip != null) {
        if (text.marked())         text.delete();
        text.add(clip);
      }
    }
 else     if (UNDOSTEP.is(e)) {
      final byte[] t=hist.prev();
      if (t != null) {
        text=new BaseXTextTokens(t);
        text.pos(hist.cursor());
        rend.setText(text);
      }
    }
 else     if (REDOSTEP.is(e)) {
      final byte[] t=hist.next();
      if (t != null) {
        text=new BaseXTextTokens(t);
        text.pos(hist.cursor());
        rend.setText(text);
      }
    }
 else     if (COMMENT.is(e)) {
      text.comment(rend.getSyntax());
    }
 else     if (DELLINE.is(e)) {
      text.deleteLine();
    }
 else     if (DELLINEEND.is(e) || DELNEXTWORD.is(e) || DELNEXT.is(e)) {
      if (nomark) {
        if (text.pos() == text.size())         return;
        text.startMark();
        if (DELNEXTWORD.is(e)) {
          text.nextToken(true);
        }
 else         if (DELLINEEND.is(e)) {
          text.eol(true);
        }
 else {
          text.next(true);
        }
        text.endMark();
      }
      text.delete();
    }
 else     if (DELLINESTART.is(e) || DELPREVWORD.is(e) || DELPREV.is(e)) {
      if (nomark) {
        if (text.pos() == 0)         return;
        text.startMark();
        if (DELPREVWORD.is(e)) {
          text.prevToken(true);
        }
 else         if (DELLINESTART.is(e)) {
          text.bol(true);
        }
 else {
          text.prev();
        }
        text.endMark();
      }
      text.delete();
      down=false;
    }
 else {
      consumed=false;
    }
  }
  if (consumed)   e.consume();
  text.setCursor();
  final byte[] tmp=text.text();
  if (txt != tmp) {
    rend.calc();
    hist.store(tmp,pc,text.cursor());
  }
  showCursor(down ? 2 : 0);
}
