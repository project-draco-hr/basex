{
  if (undo == null || control(e) || DELNEXT.is(e) || DELPREV.is(e) || ESCAPE.is(e))   return;
  text.pos(text.cursor());
  String ch=String.valueOf(e.getKeyChar());
  boolean del=true;
  final byte[] txt=text.text();
  if (TAB.is(e)) {
    if (text.marked()) {
      final int s=Math.min(text.pos(),text.start());
      final int l=Math.max(text.pos(),text.start()) - 1;
      for (int p=s; p <= l && p < txt.length; p++)       del&=txt[p] != '\n';
      if (!del) {
        text.indent(s,l,e.isShiftDown());
        ch=null;
      }
    }
 else {
      boolean c=true;
      for (int p=text.pos() - 1; p >= 0 && c; p--) {
        final byte b=txt[p];
        c=ws(b);
        if (b == '\n')         break;
      }
      if (c)       ch="  ";
    }
  }
  if (text.marked() && del)   text.delete();
  if (ENTER.is(e)) {
    final StringBuilder sb=new StringBuilder(1).append(e.getKeyChar());
    int s=0;
    for (int p=text.pos() - 1; p >= 0; p--) {
      final byte b=txt[p];
      if (b == '\n')       break;
      if (b == '\t') {
        s+=2;
      }
 else       if (b == ' ') {
        s++;
      }
 else {
        s=0;
      }
    }
    for (int p=0; p < s; p++)     sb.append(' ');
    ch=sb.toString();
  }
  if (ch != null)   text.add(ch);
  text.setCaret();
  rend.calc();
  showCursor(2);
  e.consume();
}
