{
  int c=0;
  final byte[] old=text.text();
  byte[] txt=null;
  if (regex) {
    int flags=Pattern.DOTALL;
    if (!mcase)     flags|=Pattern.CASE_INSENSITIVE;
    final Pattern p=Pattern.compile(src,flags);
    if (multi) {
      txt=Token.token(p.matcher(Token.string(old)).replaceAll(replace));
      c++;
    }
 else {
      final int os=old.length;
      final TokenBuilder tb=new TokenBuilder(os);
      for (int s=0, o=0; o <= os; o++) {
        if (o < os ? old[o] == '\n' : o != s) {
          tb.add(p.matcher(Token.string(old,s,o - s)).replaceAll(replace));
          if (o < os)           tb.add('\n');
          c++;
          s=o + 1;
        }
      }
      txt=tb.finish();
    }
  }
 else {
    final byte[] srch=mcase ? Token.token(src) : Token.lc(Token.token(src));
    final byte[] rplc=Token.token(replace);
    final ByteList bl=new ByteList();
    final int ss=srch.length, os=old.length;
    for (int o=0; o < os; ) {
      int s=0;
      if (o + ss <= os) {
        if (mcase) {
          for (; s < ss && old[o + s] == srch[s]; s++)           ;
        }
 else {
          for (; s < ss && Token.lc(Token.cp(old,o + s)) == Token.cp(srch,s); s+=Token.cl(srch,s))           ;
        }
      }
      if (s == ss) {
        bl.add(rplc);
        o+=s;
        c++;
      }
 else {
        bl.add(old[o++]);
      }
    }
    if (c != 0)     txt=bl.toArray();
  }
  if (txt != null)   setText(txt);
  return c;
}
