{
  final MetaData md=data.meta;
  if (!md.uptodate) {
    data.paths.init();
    data.resources.init();
    data.elmindex.init();
    data.atnindex.init();
    md.dirty=true;
    final IntList pars=new IntList();
    final IntList elms=new IntList();
    int n=0;
    for (int pre=0; pre < md.size; ++pre) {
      final byte kind=(byte)data.kind(pre);
      final int par=data.parent(pre,kind);
      while (!pars.isEmpty() && pars.peek() > par) {
        pars.pop();
        elms.pop();
      }
      final int level=pars.size();
      if (kind == Data.DOC) {
        data.paths.put(0,Data.DOC,level);
        pars.push(pre);
        elms.push(0);
        ++n;
      }
 else       if (kind == Data.ELEM) {
        final int id=data.name(pre);
        data.elmindex.index(data.elmindex.key(id),null,true);
        data.paths.put(id,Data.ELEM,level);
        pars.push(pre);
        elms.push(id);
      }
 else       if (kind == Data.ATTR) {
        final int id=data.name(pre);
        final byte[] val=data.text(pre,false);
        data.atnindex.index(data.atnindex.key(id),val,true);
        data.paths.put(id,Data.ATTR,level,val,md);
      }
 else {
        final byte[] val=data.text(pre,true);
        if (kind == Data.TEXT && level > 1)         data.elmindex.index(elms.peek(),val);
        data.paths.put(0,kind,level,val,md);
      }
      if (cmd != null)       cmd.pre=pre;
    }
    md.ndocs=n;
    md.uptodate=true;
  }
  optimize(IndexType.ATTRIBUTE,data,md.createattr,md.attrindex,rebuild,cmd);
  optimize(IndexType.TEXT,data,md.createtext,md.textindex,rebuild,cmd);
  optimize(IndexType.FULLTEXT,data,md.createftxt,md.ftxtindex,rebuild || rebuildFT,cmd);
}
