{
  this.query=query;
  this.bindings=bindings;
  this.info=info;
  this.cache=opts.get(ScheduleOptions.CACHE);
  this.job().context=qc.context;
  final String bu=opts.get(XQueryOptions.BASE_URI);
  uri=bu != null ? bu : string(sc.baseURI().string());
  final JobPool pool=qc.context.jobs;
  final String id=job().id();
  final String del=opts.get(ScheduleOptions.START);
  final long delay=del.isEmpty() ? 0 : ms(del,qc);
  if (delay < 0)   throw JOBS_RANGE.get(info,del);
  long interval=0;
  final String inter=opts.get(ScheduleOptions.INTERVAL);
  if (!inter.isEmpty())   interval=ms(new DTDur(Token.token(inter),info));
  if (interval < 1000 && interval != 0)   throw JOBS_RANGE.get(info,inter);
  repeat=interval > 0;
  final String dur=opts.get(ScheduleOptions.END);
  final long duration=dur.isEmpty() ? Long.MAX_VALUE : ms(dur,qc);
  if (duration <= delay)   throw JOBS_RANGE.get(info,dur);
  if (cache) {
    if (repeat)     throw JOBS_CONFLICT.get(info);
    pool.results.put(id,result);
  }
  new JobTask(this,pool,delay,interval,duration);
}
