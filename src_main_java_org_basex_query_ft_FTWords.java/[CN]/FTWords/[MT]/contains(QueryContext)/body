{
  first=true;
  final FTLexer intok=ftt.copy(ctx.fttoken);
  int num=0;
  if (fast) {
    for (    final byte[] t : txt) {
      final FTTokens qtok=ftt.cache(t);
      num=Math.max(num,ftt.contains(qtok,intok) * qtok.length());
    }
    return num;
  }
  final TokenSet tm=new TokenSet();
  final Iter qu=ctx.iter(query);
  byte[] q;
switch (mode) {
case M_ALL:
case M_ANY:
    while ((q=nextToken(qu)) != null)     tm.add(q);
  break;
case M_ALLWORDS:
case M_ANYWORD:
final FTLexer l=new FTLexer(intok.ftOpt());
while ((q=nextToken(qu)) != null) {
l.init(q);
while (l.hasNext()) tm.add(l.nextToken());
}
break;
case M_PHRASE:
final TokenBuilder tb=new TokenBuilder();
while ((q=nextToken(qu)) != null) tb.add(q).add(' ');
tm.add(tb.trim().finish());
}
final boolean a=mode == FTMode.M_ALL || mode == FTMode.M_ALLWORDS;
int oc=0;
for (int i=1; i <= tm.size(); i++) {
final FTTokens qtok=ftt.cache(tm.key(i));
final int o=ftt.contains(qtok,intok);
if (a && o == 0) return 0;
num=Math.max(num,o * qtok.length());
oc+=o;
}
final long mn=occ != null ? checkItr(occ[0],ctx) : 1;
final long mx=occ != null ? checkItr(occ[1],ctx) : Long.MAX_VALUE;
if (mn == 0 && oc == 0) all=FTNot.not(all);
return oc >= mn && oc <= mx ? Math.max(1,num) : 0;
}
