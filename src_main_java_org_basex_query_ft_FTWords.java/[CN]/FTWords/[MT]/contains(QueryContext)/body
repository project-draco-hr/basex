{
  first=true;
  final FTLexer intok=ftt.copy(ctx.fttoken);
  if (fast) {
    final FTTokens qtok=ftt.cache(txt);
    return ftt.contains(qtok,intok) * qtok.tokens();
  }
  final TokenSet tm=new TokenSet();
  final Iter qu=ctx.iter(query);
  byte[] q;
switch (mode) {
case M_ALL:
case M_ANY:
    while ((q=nextToken(qu)) != null)     tm.add(q);
  break;
case M_ALLWORDS:
case M_ANYWORD:
while ((q=nextToken(qu)) != null) {
  for (  final byte[] t : split(q,' '))   tm.add(t);
}
break;
case M_PHRASE:
final TokenBuilder tb=new TokenBuilder();
while ((q=nextToken(qu)) != null) tb.add(q).add(' ');
tm.add(tb.trim().finish());
}
final boolean a=mode == FTMode.M_ALL || mode == FTMode.M_ALLWORDS;
int num=0, oc=0;
for (int i=1; i <= tm.size(); i++) {
final FTTokens qtok=ftt.cache(tm.key(i));
final int o=ftt.contains(qtok,intok);
if (a && o == 0) return 0;
num=Math.max(num,o * qtok.tokens());
oc+=o;
}
final long mn=occ != null ? checkItr(occ[0],ctx) : 1;
final long mx=occ != null ? checkItr(occ[1],ctx) : Long.MAX_VALUE;
if (mn == 0 && oc == 0) all=FTNot.not(all);
return oc >= mn && oc <= mx ? Math.max(1,num) : 0;
}
