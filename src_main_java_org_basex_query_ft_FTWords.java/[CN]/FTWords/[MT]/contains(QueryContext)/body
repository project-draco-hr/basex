{
  first=true;
  if (simple)   return ftt.contains(txt,ctx.fttoken,ctx.ftopt);
  final Iter iter=ctx.iter(query);
  int len=0;
  int o=0;
  byte[] it;
switch (mode) {
case M_ALL:
    while ((it=nextStr(iter)) != null) {
      final int oc=ftt.contains(it,ctx.fttoken,ctx.ftopt);
      if (oc == 0)       return 0;
      len+=it.length;
      o+=oc;
    }
  break;
case M_ALLWORDS:
while ((it=nextStr(iter)) != null) {
  for (  final byte[] t : split(it,' ')) {
    final int oc=ftt.contains(t,ctx.fttoken,ctx.ftopt);
    if (oc == 0)     return 0;
    len+=t.length;
    o+=oc;
  }
}
break;
case M_ANY:
while ((it=nextStr(iter)) != null) {
o+=ftt.contains(it,ctx.fttoken,ctx.ftopt);
len+=it.length;
}
break;
case M_ANYWORD:
while ((it=nextStr(iter)) != null) {
for (final byte[] t : split(it,' ')) {
o+=ftt.contains(t,ctx.fttoken,ctx.ftopt);
len+=t.length;
}
}
break;
case M_PHRASE:
final TokenBuilder tb=new TokenBuilder();
while ((it=nextStr(iter)) != null) {
tb.add(it);
tb.add(' ');
}
o+=ftt.contains(tb.finish(),ctx.fttoken,ctx.ftopt);
len+=tb.size();
break;
}
final long mn=occ != null ? checkItr(occ[0],ctx) : 1;
final long mx=occ != null ? checkItr(occ[1],ctx) : Long.MAX_VALUE;
if (mn == 0 && o == 0) all=FTNot.not(all);
return o < mn || o > mx ? 0 : Math.max(1,len);
}
