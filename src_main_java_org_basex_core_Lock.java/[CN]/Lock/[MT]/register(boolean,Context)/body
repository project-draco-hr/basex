{
  if (SKIP)   return;
  if (w) {
    if (state == State.IDLE) {
      state=State.WRITE;
      return;
    }
    final Resource lx=new Resource(false);
synchronized (lx) {
      waiting.add(lx);
      while (lx.locked) {
        try {
          lx.wait();
        }
 catch (        final InterruptedException ex) {
          Util.stack(ex);
        }
      }
      state=State.WRITE;
    }
  }
 else {
synchronized (this) {
      if (state != State.WRITE && waiting.size() == 0 && activeR < ctx.prop.num(Prop.PARALLEL)) {
        state=State.READ;
        ++activeR;
        return;
      }
    }
    final Resource ls=new Resource(true);
synchronized (ls) {
      waiting.add(ls);
      while (ls.locked) {
        try {
          ls.wait();
        }
 catch (        final InterruptedException ex) {
          Util.stack(ex);
        }
      }
      state=State.READ;
      ++activeR;
    }
  }
}
