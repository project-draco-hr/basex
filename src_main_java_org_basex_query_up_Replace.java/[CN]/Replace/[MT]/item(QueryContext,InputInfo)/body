{
  final Constr c=new Constr(ctx,expr[1]);
  if (c.errAtt)   UPNOATTRPER.thrw(input);
  if (c.duplAtt != null)   UPATTDUPL.thrw(input,c.duplAtt);
  final Iter t=ctx.iter(expr[0]);
  final Item i=t.next();
  if (i == null)   throw UPSEQEMP.thrw(input,Util.name(this));
  final Type tp=i.type;
  if (!(i instanceof ANode) || tp == Type.DOC || t.next() != null)   UPTRGMULT.thrw(input);
  final ANode targ=(ANode)i;
  final NodeCache aList=c.atts;
  NodeCache list=c.children;
  if (value) {
    final byte[] txt=list.size() < 1 ? EMPTY : list.get(0).atom();
    if (tp == Type.COM)     FComm.parse(txt,input);
    if (tp == Type.PI)     FPI.parse(txt,input);
    ctx.updates.add(tp == Type.ELM ? new ReplaceElemContent(input,targ,txt) : new ReplaceValue(input,targ,new QNm(txt)),ctx);
  }
 else {
    final ANode par=targ.parent();
    if (par == null)     UPNOPAR.thrw(input,i);
    if (tp == Type.ATT) {
      if (list.size() > 0)       UPWRATTR.thrw(input);
      list=checkNS(aList,par,ctx);
    }
 else {
      if (aList.size() > 0)       UPWRELM.thrw(input);
    }
    ctx.updates.add(new ReplacePrimitive(input,targ,list),ctx);
  }
  return null;
}
