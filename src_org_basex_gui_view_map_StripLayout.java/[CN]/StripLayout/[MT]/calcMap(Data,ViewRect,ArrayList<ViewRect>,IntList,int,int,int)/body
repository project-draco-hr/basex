{
  if (ne - ns <= 1) {
    putRect(data,r,mainRects,l,ns,level);
  }
 else {
    int nn=l.list[ne] - l.list[ns];
    long parsize=addSizes(l,ns,ne,data);
    int ni=ns;
    int start=ns;
    double xx=r.x;
    double yy=r.y;
    double ww=r.w;
    double hh=r.h;
    ArrayList<ViewRect> row=new ArrayList<ViewRect>();
    double height=0;
    while (ni < ne) {
      long size=addSizes(l,start,ni + 1,data);
      int childs=l.list[ni + 1] - l.list[start];
      double weight=calcWeight(size,childs,parsize,nn,data);
      height=weight * hh;
      ArrayList<ViewRect> tmp=new ArrayList<ViewRect>();
      double x=xx;
      for (int i=start; i <= ni; i++) {
        long tmpsize=Token.toLong(data.attValue(data.sizeID,l.list[i]));
        double w=calcWeight(tmpsize,l.list[i + 1] - l.list[i],size,childs,data) * ww;
        tmp.add(new ViewRect((int)x,(int)yy,(int)w,(int)height,l.list[i],level));
        x+=w;
      }
      if (lineRatio(tmp) > lineRatio(row)) {
        for (int i=0; i < row.size(); i++) {
          IntList newl=new IntList(1);
          newl.add(row.get(i).pre);
          calcMap(data,row.get(i),mainRects,newl,0,1,level);
        }
        hh-=row.get(0).h;
        yy+=row.get(0).h;
        tmp.clear();
        row.clear();
        start=ni;
        nn=l.list[ne] - l.list[start];
        parsize=addSizes(l,start,ne,data);
        if (ne == ni + 1) {
          row.add(new ViewRect((int)xx,(int)yy,(int)ww,(int)hh,l.list[ni],level));
          break;
        }
      }
      row=tmp;
      ni++;
    }
    for (int i=0; i < row.size(); i++) {
      IntList newl=new IntList(1);
      newl.add(row.get(i).pre);
      calcMap(data,row.get(i),mainRects,newl,0,1,level);
    }
  }
}
