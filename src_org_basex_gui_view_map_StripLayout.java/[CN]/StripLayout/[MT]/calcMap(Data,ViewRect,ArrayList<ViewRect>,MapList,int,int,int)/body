{
  if (ne - ns <= 1) {
    putRect(data,r,mainRects,l,ns,level);
  }
 else {
    if (level == 0) {
      splitUniformly(data,r,mainRects,l,ns,ne,level,r.w > r.h);
    }
 else {
      int nn=l.list[ne] - l.list[ns];
      long parsize=data.fs != null ? addSizes(l,ns,ne,data) : 0;
      int ni=ns;
      int start=ns;
      double xx=r.x;
      double yy=r.y;
      double ww=r.w;
      double hh=r.h;
      ArrayList<ViewRect> row=new ArrayList<ViewRect>();
      double height=0;
      while (ni < ne) {
        long size=data.fs != null ? addSizes(l,start,ni + 1,data) : 0;
        int childs=l.list[ni + 1] - l.list[start];
        double weight=calcWeight(size,childs,parsize,nn,data);
        height=weight * hh;
        ArrayList<ViewRect> tmp=new ArrayList<ViewRect>();
        double x=xx;
        for (int i=start; i <= ni; i++) {
          long tmpsize=data.fs != null ? Token.toLong(data.attValue(data.sizeID,l.list[i])) : 0;
          double w=i == ni ? xx + ww - x : calcWeight(tmpsize,l.list[i + 1] - l.list[i],size,childs,data) * ww;
          tmp.add(new ViewRect((int)x,(int)yy,(int)w,(int)height,l.list[i],level));
          x+=(int)w;
        }
        if (lineRatio(tmp) > lineRatio(row)) {
          for (int i=0; i < row.size(); i++) {
            MapList newl=new MapList(1);
            newl.add(row.get(i).pre);
            calcMap(data,row.get(i),mainRects,newl,0,1,level);
          }
          hh-=row.get(0).h;
          yy+=row.get(0).h;
          tmp.clear();
          row.clear();
          start=ni;
          nn=l.list[ne] - l.list[start];
          parsize=data.fs != null ? addSizes(l,start,ne,data) : 0;
          if (ne == ni + 1) {
            row.add(new ViewRect((int)xx,(int)yy,(int)ww,(int)hh,l.list[ni],level));
            break;
          }
        }
        row=tmp;
        ni++;
      }
      for (int i=0; i < row.size(); i++) {
        MapList newl=new MapList(1);
        newl.add(row.get(i).pre);
        calcMap(data,row.get(i),mainRects,newl,0,1,level);
      }
    }
  }
}
