{
  da.cursor(p);
  final IntList vals=new IntList();
  for (int c=0, lp=0; c < s; ) {
    if (lp == 0) {
      if (scm > 0)       vals.add(da.readNum());
      lp=da.readNum();
      vals.add(lp);
    }
    final int pr=lp;
    vals.add(da.readNum());
    while (++c < s) {
      lp=da.readNum();
      vals.add(lp);
      if (lp != pr)       break;
      vals.add(da.readNum());
    }
  }
  return new FTIndexIterator(){
    final byte tn=toknum;
    final FTMatches all=new FTMatches(tn);
    int c, pre, lpre;
    double sc=-1;
    @Override public synchronized boolean more(){
      if (c == vals.size())       return false;
      if (lpre == 0) {
        if (scm > 0)         sc=(Math.log(vals.get(c++)) - min) / (max - min);
        lpre=vals.get(c++);
        size=s;
      }
      pre=lpre;
      all.reset(tn);
      all.or(vals.get(c++));
      while (c < vals.size() && (lpre=vals.get(c++)) == pre) {
        final int n=vals.get(c++);
        if (!fast)         all.or(n);
      }
      return true;
    }
    @Override public synchronized FTMatches matches(){
      return all;
    }
    @Override public synchronized int next(){
      return pre;
    }
    @Override public synchronized double score(){
      return sc;
    }
  }
;
}
