{
  final Iter iter=expr[0].iter(ctx);
  final NodeCache nc=new NodeCache().random();
  for (Item it; (it=iter.next()) != null; )   nc.add(checkNode(it));
  final int len=(int)nc.size();
  if (len < 2)   return nc;
  if (nc.dbnodes()) {
    final DBNode fst=(DBNode)nc.get(outer ? 0 : len - 1);
    final Data data=fst.data;
    final ANode[] nodes=nc.item.clone();
    if (outer) {
      nc.size(0);
      final DBNode dummy=new DBNode(fst.data,0);
      final NodeCache src=new NodeCache(nodes,len);
      for (int next=0, p; next < len; next=p < 0 ? -p - 1 : p) {
        final DBNode nd=(DBNode)nodes[next];
        dummy.pre=nd.pre + data.size(nd.pre,kind(nd.type));
        p=src.binarySearch(dummy,next + 1,len - next - 1);
        nc.add(nd);
      }
    }
 else {
      nc.item[0]=fst;
      nc.size(1);
      int before=fst.pre;
      for (int i=len - 1; i-- != 0; ) {
        final DBNode nd=(DBNode)nodes[i];
        if (nd.pre + data.size(nd.pre,kind(nd.type)) <= before) {
          nc.add(nd);
          before=nd.pre;
        }
      }
      Array.reverse(nc.item,0,(int)nc.size());
    }
    return nc;
  }
  final NodeCache out=new NodeCache(new ANode[len],0);
  outer:   for (int i=0; i < len; i++) {
    final ANode nd=nc.item[i];
    final AxisIter ax=outer ? nd.anc() : nd.descendant();
    for (ANode a; (a=ax.next()) != null; )     if (nc.indexOf(a,false) != -1)     continue outer;
    out.add(nc.item[i]);
  }
  return out;
}
