{
  checkEmpty();
  for (int i=0; i != step.length; i++) {
    final Expr e=ctx.comp(step[i]);
    if (!(e instanceof Step))     return e;
    step[i]=(Step)e;
  }
  mergeDesc(ctx);
  if (iterable(root,step))   return new SimpleIterPath(root,step);
  cache=root != null && !root.uses(Using.VAR);
  for (  final Step s : step) {
    if (s.pred.length != 0 && s.uses(Using.VAR)) {
      cache=false;
      return this;
    }
  }
  if (!(ctx.item instanceof DBNode))   return this;
  final DBNode db=(DBNode)ctx.item;
  for (  final Step s : step)   if (s.uses(Using.POS) || !s.axis.vert)   return this;
  for (int i=0; i < step.length; i++) {
    final Step stp=step[i];
    IndexContext ictx=null;
    int minp=0;
    for (int p=0; p < stp.pred.length; p++) {
      final IndexContext ic=new IndexContext(db.data,stp);
      stp.pred[p].indexAccessible(ctx,ic);
      if (ic.io && ic.iu) {
        if (ictx == null || ictx.is > ic.is) {
          ictx=ic;
          minp=p;
        }
      }
    }
    if (ictx == null || !ictx.io || !ictx.iu)     continue;
    if (ictx.is == 0) {
      if (ictx.ftnot) {
        stp.pred[minp]=Bln.TRUE;
        continue;
      }
      ctx.compInfo(OPTNOINDEX,this);
      return Seq.EMPTY;
    }
    final Expr ie=stp.pred[minp].indexEquivalent(ctx,ictx);
    if (ictx.seq) {
      stp.pred[minp]=ie;
    }
 else {
      Step[] inv={};
      final Expr[] newPreds=new Expr[stp.pred.length - 1];
      int c=0;
      for (int p=0; p != stp.pred.length; p++) {
        if (p != minp)         newPreds[c++]=stp.pred[p];
      }
      for (int j=i; j >= 0; j--) {
        final Axis a=step[j].axis.invert();
        if (a == null)         break;
        if (j == 0) {
          if (a == Axis.PARENT)           inv=Array.add(inv,Step.get(a,new KindTest(Type.DOC)));
        }
 else {
          final Step prev=step[j - 1];
          if (prev.pred.length != 0)           break;
          inv=Array.add(inv,Step.get(a,prev.test));
        }
      }
      final boolean add=inv.length != 0 || newPreds.length != 0;
      AxisPath result=null;
      if (ie instanceof AxisPath) {
        result=(AxisPath)ie;
      }
 else       if (add || i + 1 < step.length) {
        result=add ? new AxisPath(ie,Step.get(Axis.SELF,Test.NODE)) : new AxisPath(ie);
      }
 else {
        return ie;
      }
      final int sl=result.step.length - 1;
      for (int p=0; p < newPreds.length; p++) {
        result.step[sl]=result.step[sl].addPred(newPreds[p]);
      }
      if (inv.length != 0) {
        result.step[sl]=result.step[sl].addPred(new AxisPath(null,inv));
      }
      for (int j=i + 1; j < step.length; j++) {
        result.step=Array.add(result.step,step[j]);
      }
      break;
    }
  }
  return this;
}
