{
  final List<byte[]> instVers=getInstalledVersions(dep.pkg);
  if (instVers.size() == 0) {
  }
  final Iterator<byte[]> instIt=instVers.iterator();
  boolean found=false;
  if (dep.versions != null) {
    final List<byte[]> accept=getAcceptVersions(dep.versions);
    final Iterator<byte[]> acceptIt=accept.iterator();
    byte[] v;
    while (acceptIt.hasNext()) {
      v=acceptIt.next();
      if (instVers.contains(v)) {
        found=true;
        break;
      }
    }
  }
 else   if (dep.semver != null) {
    while (instIt.hasNext()) {
      if (new Version(instIt.next()).isCompatible(new Version(dep.semver))) {
        found=true;
        break;
      }
    }
  }
 else   if (dep.semverMin != null && dep.semverMax == null) {
    final Version semVer=new Version(dep.semverMin);
    Version v;
    while (instIt.hasNext()) {
      v=new Version(instIt.next());
      if (v.isCompatible(semVer) || v.compareTo(semVer) >= 0) {
        found=true;
        break;
      }
    }
  }
 else   if (dep.semverMin == null && dep.semverMax != null) {
    final Version semVer=new Version(dep.semverMax);
    Version v;
    while (instIt.hasNext()) {
      v=new Version(instIt.next());
      if (v.isCompatible(semVer) || v.compareTo(semVer) <= 0) {
        found=true;
        break;
      }
    }
  }
 else   if (dep.semverMin != null && dep.semverMax != null) {
    final Version min=new Version(dep.semverMin);
    final Version max=new Version(dep.semverMax);
    Version v;
    while (instIt.hasNext()) {
      v=new Version(instIt.next());
      if (v.compareTo(min) >= 0 && v.compareTo(max) < 0) {
        found=true;
        break;
      }
    }
  }
  if (!found) {
  }
}
