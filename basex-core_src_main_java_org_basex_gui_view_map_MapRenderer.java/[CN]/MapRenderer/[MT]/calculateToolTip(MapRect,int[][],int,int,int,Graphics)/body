{
  if (r.thumbf == 0)   return null;
  final boolean sen=r.thumbal < 2;
  final boolean ds=r.thumbal < 1;
  final FTPos ftp=r.pos;
  final int ww=r.w;
  int yy=r.y + 3;
  double ll=0;
  double error=0;
  ul=-1;
  int psl=0, ppl=0, pl=0, sl=0, cc=0;
  final TokenList tl=new TokenList();
  ttcol=new BoolList();
  for (int i=0; i < data[0].length; ++i) {
    boolean ir=false;
    double wl=data[0][i] * r.thumbf;
    error+=data[0][i] * r.thumbf - wl;
    if (error >= 1) {
      wl+=error;
      error-=(int)error;
    }
    pl+=data[0][i];
    sl+=data[0][i];
    cc+=data[0][i];
    if (ll + wl + (ds && psl < data[1].length && data[1][psl] == sl ? r.thumbsw : 0) >= ww) {
      if (ds) {
        yy+=r.thumblh;
        ir=inRect(r.x,yy,wl,r.thumbfh,x,y);
        ll=wl + (psl < data[1].length && data[1][psl] == sl ? r.thumbsw : r.thumbf);
      }
 else {
        yy+=r.thumblh;
        wl-=ww - ll;
        ir=inRect(r.x,yy,wl,r.thumbfh,x,y);
        ll=wl + (psl < data[1].length && data[1][psl] == sl ? r.thumbsw : r.thumbf);
      }
    }
 else {
      ir|=inRect(r.x + ll,yy,wl,r.thumbfh,x,y);
      ll+=wl + (ds ? r.thumbf : 0);
    }
    if (ir) {
      final int si=i;
      final int[] cw=fontWidths(g.getFont());
      final int sp=BaseXLayout.width(g,cw,' ');
      final int sd=BaseXLayout.width(g,cw,'.');
      final int bpsl=data[1][psl] == sl ? psl + 1 : psl;
      final int bsl=data[1][psl] == sl ? 0 : sl;
      ll=sd * 2 + sp;
      int l;
      byte[] tok;
      int p=cc >= data[0][i] ? cc - data[0][i] : 0;
      boolean apm;
      while (p > -1 && i > -1) {
        apm=psl < data[1].length && data[1][psl] == sl;
        tok=new byte[data[0][i] + (apm ? 1 : 0)];
        for (int k=0; k < tok.length - (apm ? 1 : 0); ++k) {
          tok[k]=(byte)data[3][p + k];
        }
        if (apm) {
          tok[tok.length - 1]=(byte)data[4][psl];
          ++sl;
        }
        sl-=tok.length;
        if (sl == 0) {
          --psl;
          if (psl == -1)           psl=data[1].length;
 else           sl=data[1][psl];
        }
        l=0;
        for (int n=0; n < tok.length; n+=cl(tok,n))         l+=BaseXLayout.width(g,cw,cp(tok,n));
        if (si > i && ll + l + sp >= w / 2d)         break;
        ll+=l + sp;
        tl.add(tok);
        ttcol.add(ftp != null && ftp.contains(i));
        if (i == 0)         break;
        p-=data[0][i - 1];
        --i;
      }
      if (i > 0) {
        tl.add(new byte[]{'.','.'});
        ttcol.add(false);
      }
      i=si + 1;
      p=cc;
      ul=tl.size() - 1;
      final byte[][] toks=tl.toArray();
      final boolean[] tc=ttcol.toArray();
      tl.reset();
      ttcol.reset();
      for (int j=toks.length - 1; j >= 0; j--) {
        tl.add(toks[j]);
        ttcol.add(tc[j]);
      }
      ll=0;
      sl=bsl;
      psl=bpsl;
      while (p < data[3].length && i < data[0].length) {
        apm=false;
        if (psl < data[1].length && data[1][psl] == sl + data[0][i]) {
          apm=true;
          sl=0;
          ++psl;
        }
        tok=new byte[data[0][i] + (apm ? 1 : 0)];
        l=0;
        for (int k=0; k < tok.length - (apm ? 1 : 0); ++k) {
          tok[k]=(byte)data[3][p + k];
        }
        if (apm)         tok[tok.length - 1]=(byte)data[4][psl - 1];
        sl+=apm ? sl : tok.length;
        for (int n=0; n < tok.length; n+=cl(tok,n))         l+=BaseXLayout.width(g,cw,cp(tok,n));
        if (ll + l + sp+ 2 * sd >= w / 2d)         break;
        ll+=l + sp;
        tl.add(tok);
        ttcol.add(ftp != null && ftp.contains(i));
        p+=tok.length - (apm ? 1 : 0);
        ++i;
      }
      if (i < data[0].length) {
        tl.add(new byte[]{'.','.'});
        ttcol.add(false);
      }
      return tl;
    }
    if (ds && psl < data[1].length && data[1][psl] == sl) {
      if (ll + r.thumbsw >= ww) {
        yy+=r.thumblh;
        ll-=ww;
      }
      ll+=r.thumbsw;
      sl=0;
      ++psl;
    }
    if (ppl < data[2].length && data[2][ppl] == pl) {
      pl=0;
      ++ppl;
      if (sen) {
        yy+=r.thumblh;
        ll=0;
      }
    }
  }
  return tl;
}
