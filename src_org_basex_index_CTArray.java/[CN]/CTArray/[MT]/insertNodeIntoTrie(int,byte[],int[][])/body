{
  if (cn == 0) {
    if (next[0] != null) {
      final int positionToInsert=getInsertingPosition(cn,v[0]);
      if (!found) {
        if (!(countNodes < nodes.length - 1)) {
          reSize();
        }
        nodes[countNodes]=v;
        if (d != null) {
          addDataToNode(countNodes,d,d[0].length);
        }
        insertNodeInNextArray(cn,countNodes,positionToInsert);
        countNodes++;
        return countNodes - 1;
      }
 else {
        return insertNodeIntoTrie(next[cn][positionToInsert],v,d);
      }
    }
  }
  final byte[] intersection=calculateIntersection(nodes[cn],v);
  byte[] remain1=nodes[cn];
  byte[] remain2=v;
  if (intersection != null) {
    remain1=getBytes(nodes[cn],intersection.length,nodes[cn].length);
    remain2=getBytes(v,intersection.length,v.length);
  }
  if (intersection != null) {
    if (remain1 == null) {
      if (remain2 == null) {
        if (d != null) {
          addDataToNode(cn,d,d[0].length);
        }
        return cn;
      }
 else {
        final int positionToInsert=getInsertingPosition(cn,remain2[0]);
        if (!found) {
          if (!(countNodes < nodes.length - 1)) {
            reSize();
          }
          nodes[countNodes]=remain2;
          if (d != null) {
            addDataToNode(countNodes,d,d[0].length);
          }
          insertNodeInNextArray(cn,countNodes,positionToInsert);
          countNodes++;
          return countNodes - 1;
        }
 else {
          return insertNodeIntoTrie(next[cn][positionToInsert],remain2,d);
        }
      }
    }
 else {
      if (remain2 == null) {
        nodes[cn]=intersection;
        final int[][] dataCurrentNode=(int[][])this.data[cn];
        final int dataCurrentNodeSize=dataSize[cn];
        this.data[cn]=null;
        dataSize[cn]=0;
        if (d != null) {
          addDataToNode(cn,d,d[0].length);
        }
        if (!found) {
          if (!(countNodes < nodes.length - 1)) {
            reSize();
          }
          addDataToNode(countNodes,dataCurrentNode,dataCurrentNodeSize);
          next[countNodes]=next[cn];
          next[cn]=new int[]{countNodes};
          totDataSize++;
          countNodes++;
          return countNodes - 1;
        }
 else {
          if (!(countNodes < nodes.length - 1)) {
            reSize();
          }
          nodes[countNodes]=remain1;
          this.data[countNodes]=dataCurrentNode;
          this.dataSize[countNodes]=dataCurrentNodeSize;
          next[countNodes]=next[cn];
          next[cn]=new int[]{countNodes};
          totDataSize++;
          this.data[cn]=null;
          dataSize[cn]=0;
          if (d != null) {
            addDataToNode(cn,d,d[0].length);
          }
          countNodes++;
          return countNodes - 1;
        }
      }
 else {
        final int[][] dataCurrentNode=(int[][])this.data[cn];
        final int dataCurrentNodeSize=dataSize[cn];
        this.data[cn]=null;
        dataSize[cn]=0;
        nodes[cn]=intersection;
        if (!(countNodes < nodes.length - 2)) {
          reSize();
        }
        nodes[countNodes]=remain2;
        if (d != null) {
          addDataToNode(countNodes,d,d[0].length);
        }
        nodes[countNodes + 1]=remain1;
        addDataToNode(countNodes + 1,dataCurrentNode,dataCurrentNodeSize);
        next[countNodes + 1]=next[cn];
        next[cn]=new int[]{countNodes + 1};
        totDataSize++;
        final int insertingPos=getInsertingPosition(cn,nodes[countNodes][0]);
        insertNodeInNextArray(cn,countNodes,insertingPos);
        countNodes+=2;
        return countNodes - 1;
      }
    }
  }
 else {
    nodes[countNodes]=v;
    if (d != null) {
      addDataToNode(countNodes,d,d[0].length);
    }
    final int insertingPos=getInsertingPosition(cn,v[0]);
    insertNodeInNextArray(cn,countNodes,insertingPos);
    countNodes++;
    return countNodes - 1;
  }
}
