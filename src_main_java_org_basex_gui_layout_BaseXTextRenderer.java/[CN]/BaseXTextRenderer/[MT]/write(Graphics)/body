{
  if (high) {
    high=false;
  }
 else {
    color=isEnabled() ? syntax.getColor(text) : Color.gray;
  }
  final int ch=text.curr();
  if (y > 0 && y < h) {
    if (ch == TokenBuilder.MARK) {
      color=GUIConstants.GREEN;
      high=true;
    }
    int xx=x;
    if (text.markStart()) {
      final int p=text.pos();
      while (text.more()) {
        final int cw=charW(g,text.curr());
        if (text.inMark()) {
          g.setColor(GUIConstants.color(2));
          g.fillRect(xx,y - fontH * 4 / 5,cw,fontH);
        }
        xx+=cw;
        text.next();
      }
      text.pos(p);
    }
    if (found()) {
      int cw=0;
      for (int c=0; c < keyword.length(); ++c)       cw+=charW(g,keyword.charAt(c));
      g.setColor(GUIConstants.color(text.cursor() == text.pos() ? 4 : 1));
      g.fillRect(x,y - fontH * 4 / 5,cw,fontH);
    }
    if (text.erroneous()) {
      final int s=Math.max(1,fontH / 8);
      g.setColor(GUIConstants.LRED);
      g.fillRect(x,y + 2,wordW,s);
      g.setColor(GUIConstants.RED);
      for (int xp=x; xp < x + wordW; xp++) {
        if ((xp & 1) == 0)         g.drawLine(xp,y + 2,xp,y + s + 1);
      }
    }
    if (ch > ' ') {
      g.setColor(color);
      String n=text.nextWord();
      int ww=w - x;
      if (x + wordW > ww) {
        int c=0;
        for (final int nl=n.length(); c < nl && ww > 0; c++) {
          ww-=charW(g,n.charAt(c));
        }
        n=n.substring(0,c);
      }
      g.drawString(n,x,y);
    }
 else     if (ch <= TokenBuilder.MARK) {
      g.setFont(font);
    }
    if (cursor && text.edited()) {
      xx=x;
      final int p=text.pos();
      while (text.more()) {
        if (text.cursor() == text.pos()) {
          cursor(g,xx);
          break;
        }
        xx+=charW(g,text.next());
      }
      text.pos(p);
    }
  }
  next();
}
