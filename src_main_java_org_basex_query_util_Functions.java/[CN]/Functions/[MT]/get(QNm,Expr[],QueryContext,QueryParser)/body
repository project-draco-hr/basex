{
  final byte[] uri=name.uri().atom();
  final byte[] ln=name.ln();
  if (eq(uri,XSURI)) {
    final Type type=AtomType.find(name,true);
    if (type == null || type == AtomType.NOT || type == AtomType.AAT) {
      final Levenshtein ls=new Levenshtein();
      for (      final AtomType t : AtomType.values()) {
        if (t.par() != null && ls.similar(lc(ln),lc(t.nam()),0))         qp.error(FUNSIMILAR,name,t.nam());
      }
      qp.error(FUNCUNKNOWN,name.atom());
    }
    if (args.length != 1)     qp.error(FUNCTYPE,name.atom());
    return new Cast(qp.input(),args[0],SeqType.get(type,SeqType.Occ.ZO));
  }
  if (startsWith(uri,JAVAPRE) && ctx.context.user.perm(User.ADMIN)) {
    final String c=string(substring(uri,JAVAPRE.length));
    final StringBuilder sb=new StringBuilder(c);
    sb.append(".");
    boolean dash=false;
    for (    final char b : string(ln).toCharArray()) {
      if (dash) {
        sb.append(Character.toUpperCase(b));
        dash=false;
      }
 else {
        dash=b == '-';
        if (!dash)         sb.append(b);
      }
    }
    final String java=sb.toString();
    final int i=java.lastIndexOf(".");
    final Class<?> cls=Reflect.find(java.substring(0,i));
    if (cls == null)     qp.error(FUNCJAVA,java);
    final String mth=java.substring(i + 1);
    return new FunJava(qp.input(),cls,mth,args);
  }
  final Fun fun=FNIndex.get().get(ln,uri,args,qp);
  if (fun != null) {
    ctx.updating|=fun.def == FunDef.PUT;
    return fun;
  }
  for (int l=0; l < func.length; ++l) {
    final QNm qn=func[l].var.name;
    if (eq(ln,qn.ln()) && eq(uri,qn.uri().atom()) && args.length == func[l].args.length)     return add(qp.input(),qn,l,args);
  }
  if (Types.find(name,false) == null) {
    return add(qp.input(),name,add(new Func(qp.input(),new Var(name),new Var[args.length],false),qp),args);
  }
  return null;
}
