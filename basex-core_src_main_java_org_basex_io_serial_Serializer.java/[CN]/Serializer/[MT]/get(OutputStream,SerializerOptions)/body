{
  final SerializerOptions so=sopts == null ? SerializerOptions.get(true) : sopts;
  final String enc=Strings.normEncoding(so.get(SerializerOptions.ENCODING),true);
  final PrintOutput po;
  if (enc == Strings.UTF8) {
    po=PrintOutput.get(os);
  }
 else {
    try {
      po=new EncoderOutput(os,Charset.forName(enc));
    }
 catch (    final Exception ex) {
      throw SERENCODING_X.getIO(enc);
    }
  }
  final int limit=so.get(SerializerOptions.LIMIT);
  if (limit != -1)   po.setLimit(so.get(SerializerOptions.LIMIT));
switch (so.get(SerializerOptions.METHOD)) {
case XHTML:
    return new XHTMLSerializer(po,so);
case HTML:
  return new HTMLSerializer(po,so);
case TEXT:
return new TextSerializer(po,so);
case RAW:
return new RawSerializer(po,so);
case CSV:
final CsvOptions copts=so.get(SerializerOptions.CSV);
return copts.get(CsvOptions.FORMAT) == CsvFormat.MAP ? new CsvMapSerializer(po,so) : new CsvDirectSerializer(po,so);
case JSON:
final JsonSerialOptions jopts=so.get(SerializerOptions.JSON);
final JsonFormat jformat=jopts.get(JsonOptions.FORMAT);
return jformat == JsonFormat.JSONML ? new JsonMLSerializer(po,so) : jformat == JsonFormat.BASIC ? new JsonBasicSerializer(po,so) : new JsonNodeSerializer(po,so);
case XML:
return new XMLSerializer(po,so);
default :
return new AdaptiveSerializer(po,so);
}
}
