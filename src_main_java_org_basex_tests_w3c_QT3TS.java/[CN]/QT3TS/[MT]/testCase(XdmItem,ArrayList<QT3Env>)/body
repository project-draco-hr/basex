{
  if (total++ % 500 == 0)   Util.out(".");
  if (!supported(test)) {
    if (ignoring)     ignore.add(asString("@name",test)).add(NL);
    ignored++;
    return;
  }
  final String name=asString("@name",test);
  if (!name.startsWith(single)) {
    if (ignoring)     ignore.add(name).add(NL);
    ignored++;
    return;
  }
  tested++;
  final XQuery qexp=new XQuery("*:result/*[1]",ctx).context(test);
  final XdmValue expected=qexp.value();
  final XQuery q=new XQuery("*:dependency[@type='spec']" + "[matches(@value,'(XQ10|XP20)([^+]|$)')]",ctx);
  if (q.context(test).next() != null)   ctx.prop.set(Prop.XQUERY3,false);
  q.close();
  QT3Env e=null;
  final XQuery qenv=new XQuery("*:environment[*]",ctx).context(test);
  final XdmValue ienv=qenv.next();
  if (ienv != null)   e=new QT3Env(ctx,ienv);
  qenv.close();
  String b=base;
  if (e == null) {
    final String env=asString("*:environment/@ref",test);
    if (!env.isEmpty()) {
      e=envs(envs,env);
      if (e == null) {
        e=envs(genvs,env);
        b=null;
      }
      if (e == null)       Util.errln("%: environment '%' not found.",name,env);
    }
  }
  final Performance perf=new Performance();
  final String qfile=asString("*:test/@file",test);
  String string;
  if (qfile.isEmpty()) {
    string=asString("*:test",test);
  }
 else {
    string=string(new IOFile(base,qfile).read());
  }
  final XQuery query=new XQuery(string,ctx);
  if (b != null)   query.baseURI(b);
  final String qm="for $m in *:module return ($m/@uri, $m/@file)";
  final XQuery qmod=new XQuery(qm,ctx).context(test);
  while (true) {
    final XdmItem uri=qmod.next();
    if (uri == null)     break;
    final XdmItem file=qmod.next();
    if (file == null)     break;
    query.addModule(uri.getString(),base + file.getString());
  }
  final QT3Result result=new QT3Result();
  try {
    if (e != null) {
      for (      final HashMap<String,String> ns : e.namespaces) {
        query.namespace(ns.get(PREFIX),ns.get(URI));
      }
      for (      final HashMap<String,String> par : e.params) {
        query.bind(par.get(NNAME),new XQuery(par.get(SELECT),ctx).value());
      }
      for (      final HashMap<String,String> src : e.sources) {
        final String file=(b != null ? b : "") + src.get(FILE);
        query.addDocument(src.get(URI),file);
        final String role=src.get(ROLE);
        if (role == null)         continue;
        final Object call=Function.DOC.get(Str.get(file));
        if (role.equals("."))         query.context(call);
 else         query.bind(role,call);
      }
      for (      final HashMap<String,String> src : e.resources) {
        query.addResource(src.get(URI),(b != null ? b : "") + src.get(FILE));
      }
      query.addCollection(e.collURI,e.collSources.toArray());
      if (e.collContext) {
        query.context(Function.COLLECTION.get(Str.get(e.collURI)));
      }
      if (e.baseURI != null)       query.baseURI(e.baseURI);
    }
    result.value=query.value();
    final Value v=result.value.internal();
    if (v instanceof Streamable) {
      try {
        ((Streamable)v).input(null).close();
      }
 catch (      final QueryException ex) {
        throw new XQueryException(ex);
      }
    }
  }
 catch (  final XQueryException ex) {
    result.exc=ex;
    result.value=null;
  }
catch (  final Throwable ex) {
    result.error=ex;
    Util.errln("Query: " + name);
    ex.printStackTrace();
  }
  final long time=perf.time() / 1000000;
  if (verbose)   Util.outln(name + ": " + time+ " ms");
  ctx.prop.set(Prop.XQUERY3,true);
  final String msg=test(result,expected);
  final TokenBuilder tmp=new TokenBuilder();
  tmp.add(name).add(NL);
  tmp.add(noComments(string)).add(NL);
  boolean err=result.value == null;
  String res;
  try {
    res=result.error != null ? result.error.toString() : result.exc != null ? result.exc.getCode() + ": " + result.exc.getLocalizedMessage() : asString("serialize(., map { 'indent' := 'no' })",result.value);
  }
 catch (  final XQueryException ex) {
    res=ex.getCode() + ": " + ex.getLocalizedMessage();
    err=true;
  }
  tmp.add(err ? "Error : " : "Result: ").add(noComments(res)).add(NL);
  if (msg == null) {
    tmp.add(NL);
    right.add(tmp.finish());
    correct++;
  }
 else {
    tmp.add("Expect: " + noComments(msg)).add(NL).add(NL);
    wrong.add(tmp.finish());
  }
  query.close();
  qexp.close();
}
