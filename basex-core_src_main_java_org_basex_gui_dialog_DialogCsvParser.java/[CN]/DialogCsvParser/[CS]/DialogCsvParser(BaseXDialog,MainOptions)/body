{
  try {
    copts=new CsvOptions(opts.get(MainOptions.CSVPARSER));
  }
 catch (  final IOException ex) {
    copts=new CsvOptions();
  }
  BaseXBack pp=new BaseXBack(new TableLayout(2,1,0,8));
  BaseXBack p=new BaseXBack(new TableLayout(4,2,8,4));
  p.add(new BaseXLabel(ENCODING + COL,true,true));
  encoding=DialogExport.encoding(d,copts.get(CsvOptions.ENCODING));
  p.add(encoding);
  final BaseXBack sep=new BaseXBack().layout(new TableLayout(1,2,6,0));
  final StringList sl=new StringList();
  for (  final CsvSep cs : CsvSep.values())   sl.add(cs.toString());
  final String[] sa=sl.toArray();
  seps=new BaseXCombo(d,sl.add("").toArray());
  sep.add(seps);
  String f="";
  final String s=copts.get(CsvOptions.SEPARATOR);
  if (Token.eq(s,sa)) {
    seps.setSelectedItem(s);
  }
 else {
    seps.setSelectedIndex(sa.length);
    final int ch=Token.toInt(s);
    f=ch > 0 ? String.valueOf((char)ch) : "";
  }
  sepchar=new BaseXTextField(f,d);
  sep.add(sepchar);
  BaseXLayout.setWidth(sepchar,35);
  p.add(new BaseXLabel(SEPARATOR,true,true));
  p.add(sep);
  p.add(new BaseXLabel(FORMAT + COL,true,true));
  sl.reset();
  for (  final CsvFormat cf : CsvFormat.values())   sl.add(cf.toString());
  format=new BaseXCombo(d,sl.toArray());
  format.setSelectedItem(copts.get(CsvOptions.FORMAT));
  p.add(format);
  pp.add(p);
  p=new BaseXBack(new TableLayout(2,1));
  header=new BaseXCheckBox(FIRST_LINE_HEADER,copts.get(CsvOptions.HEADER),0,d);
  p.add(header);
  lax=new BaseXCheckBox(LAX_NAME_CONVERSION,copts.get(CsvOptions.LAX),0,d);
  p.add(lax);
  pp.add(p);
  add(pp,BorderLayout.WEST);
  example=new Editor(false,d);
  BaseXLayout.setWidth(example,300);
  add(example,BorderLayout.CENTER);
  action(true);
}
