{
  if (r.thumbf == 0)   return;
  final FTPos ftp=r.pos;
  final int ww=r.w;
  int yy=r.y + 3;
  int wl=0;
  double ll=0;
  double error=0;
  ul=-1;
  int psl=0, ppl=0, pl=0, sl=0, cc=0;
  int pp=0;
  tl=new TokenList();
  ttcol=new IntList();
  boolean ir;
  for (int i=0; i < data[0].length; i++) {
    ir=false;
    wl=(int)(data[0][i] * r.thumbf);
    error+=data[0][i] * r.thumbf - wl;
    if (error >= 1) {
      wl+=(int)error;
      error-=(int)error;
    }
    pl+=data[0][i];
    sl+=data[0][i];
    cc+=data[0][i];
    if (ll + wl + (ds && psl < data[1].length && data[1][psl] == sl ? r.thumbsw : 0) >= ww) {
      if (ds) {
        yy+=r.thumblh;
        ir=inRect(r.x,yy,wl,r.thumbfh,x,y);
        ll=wl + (psl < data[1].length && data[1][psl] == sl ? r.thumbsw : r.thumbf);
      }
 else {
        ir=inRect(r.x + (int)ll,yy,ww - (int)ll,r.thumbfh,x,y);
        yy+=r.thumblh;
        wl-=ww - ll;
        ir=inRect(r.x,yy,wl,r.thumbfh,x,y);
        ll=wl + (psl < data[1].length && data[1][psl] == sl ? r.thumbsw : r.thumbf);
      }
    }
 else {
      ir|=inRect(r.x + ll,yy,wl,r.thumbfh,x,y);
      ll+=wl + (ds ? r.thumbf : 0);
    }
    if (ir) {
      final int si=i;
      final int[] cw=fontWidths(g.getFont());
      final int sp=BaseXLayout.width(g,cw,' ');
      final int sd=BaseXLayout.width(g,cw,'.');
      while (ftp != null && pp < ftp.size() && i > ftp.pos[pp])       pp++;
      final int pps=pp;
      final int bpsl=data[1][psl] == sl ? psl + 1 : psl;
      final int bsl=data[1][psl] == sl ? 0 : sl;
      ll=sd * 2 + sp;
      int l=0;
      byte[] tok;
      int p=cc >= data[0][i] ? cc - data[0][i] : 0;
      boolean apm=false;
      while (p > -1 && i > -1) {
        apm=psl < data[1].length && data[1][psl] == sl;
        tok=new byte[data[0][i] + (apm ? 1 : 0)];
        for (int k=0; k < tok.length - (apm ? 1 : 0); k++) {
          tok[k]=(byte)data[3][p + k];
        }
        if (apm) {
          tok[tok.length - 1]=(byte)data[4][psl];
          sl+=1;
        }
        sl-=tok.length;
        if (sl == 0) {
          psl--;
          if (psl == -1)           psl=data[1].length;
 else           sl=data[1][psl];
        }
        l=0;
        for (int n=0; n < tok.length; n+=cl(tok[n]))         l+=BaseXLayout.width(g,cw,cp(tok,n));
        if (si > i && ll + l + sp >= w / 2)         break;
        ll+=l + sp;
        tl.add(tok);
        if (ftp != null) {
          while (pp < ftp.size() && pp > -1 && i < ftp.pos[pp])           pp--;
          if (pp < ftp.size() && pp > -1 && i == ftp.pos[pp]) {
            ttcol.add(ftp.poi[pp]);
            pp++;
          }
 else           ttcol.add(-1);
        }
 else         ttcol.add(-1);
        if (i == 0)         break;
        p-=data[0][i - 1];
        i--;
      }
      if (i > 0) {
        tl.add(new byte[]{'.','.'});
        ttcol.add(-1);
      }
      i=si + 1;
      p=cc;
      final byte[][] toks=tl.finish();
      final int[] tc=ttcol.finish();
      tl=new TokenList();
      ttcol=new IntList();
      for (int j=toks.length - 1; j > -1; j--) {
        tl.add(toks[j]);
        ttcol.add(tc[j]);
      }
      ul=tl.size - 1;
      ll=0;
      pp=pps;
      sl=bsl;
      psl=bpsl;
      while (p < data[3].length && i < data[0].length) {
        apm=false;
        if (psl < data[1].length && data[1][psl] == sl + data[0][i]) {
          apm=true;
          sl=0;
          psl++;
        }
        tok=new byte[data[0][i] + (apm ? 1 : 0)];
        l=0;
        for (int k=0; k < tok.length - (apm ? 1 : 0); k++) {
          tok[k]=(byte)data[3][p + k];
        }
        if (apm) {
          tok[tok.length - 1]=(byte)data[4][psl - 1];
        }
        sl+=apm ? sl : tok.length;
        for (int n=0; n < tok.length; n+=cl(tok[n]))         l+=BaseXLayout.width(g,cw,cp(tok,n));
        if (ll + l + sp+ 2 * sd >= w / 2)         break;
        ll+=l + sp;
        tl.add(tok);
        pp=0;
        if (ftp != null) {
          while (pp < ftp.size() && i > ftp.pos[pp])           pp++;
          if (pp < ftp.size() && i == ftp.pos[pp]) {
            ttcol.add(ftp.poi[pp]);
            pp++;
          }
 else           ttcol.add(-1);
        }
 else         ttcol.add(-1);
        p+=tok.length - (apm ? 1 : 0);
        i++;
      }
      if (i < data[0].length) {
        tl.add(new byte[]{'.','.'});
        ttcol.add(-1);
      }
      return;
    }
    if (ds && psl < data[1].length && data[1][psl] == sl) {
      if (ll + r.thumbsw >= ww) {
        yy+=r.thumblh;
        ll=ll - ww;
      }
      ll+=r.thumbsw;
      sl=0;
      psl++;
    }
    if (ppl < data[2].length && data[2][ppl] == pl) {
      pl=0;
      ppl++;
      if (sen) {
        yy+=r.thumblh;
        wl=0;
        ll=0;
      }
    }
  }
}
