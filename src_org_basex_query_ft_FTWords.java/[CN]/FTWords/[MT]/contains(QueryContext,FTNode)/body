{
  final FTOpt opt=ctx.ftopt;
  if (mode == FTMode.ANY && word != null && occ == null)   return opt.contains(word,ctx.fttoken,node) == 0 ? 0 : word.length;
  final Iter iter=ctx.iter(query);
  int len=0;
  int o=0;
  byte[] it;
switch (mode) {
case ALL:
    while ((it=nextStr(iter)) != null) {
      final int oc=opt.contains(it,ctx.fttoken,node);
      if (oc == 0)       return 0;
      len+=it.length;
      o+=oc / ctx.ftopt.qu.count();
    }
  break;
case ALLWORDS:
while ((it=nextStr(iter)) != null) {
  for (  final byte[] txt : split(it,' ')) {
    final int oc=opt.contains(txt,ctx.fttoken,node);
    if (oc == 0)     return 0;
    len+=txt.length;
    o+=oc;
  }
}
break;
case ANY:
while ((it=nextStr(iter)) != null) {
final int oc=opt.contains(it,ctx.fttoken,node);
len+=it.length;
final int c=opt.qu.count();
o+=c > 0 ? oc / c : 0;
}
break;
case ANYWORD:
while ((it=nextStr(iter)) != null) {
for (final byte[] txt : split(it,' ')) {
final int oc=opt.contains(txt,ctx.fttoken,node);
len+=txt.length;
o+=oc;
}
}
break;
case PHRASE:
final TokenBuilder tb=new TokenBuilder();
while ((it=nextStr(iter)) != null) {
tb.add(it);
tb.add(' ');
}
final int oc=opt.contains(tb.finish(),ctx.fttoken,node);
len+=tb.size;
final int c=opt.qu.count();
o+=c > 0 ? oc / c : 0;
break;
}
long mn=1;
long mx=Long.MAX_VALUE;
if (occ != null) {
mn=checkItr(occ[0],ctx);
mx=checkItr(occ[1],ctx);
}
return o < mn || o > mx ? 0 : Math.max(1,len);
}
