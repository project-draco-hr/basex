{
  int len=0;
  int o=0;
  if (mode == FTMode.ANY && word != null) {
    final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,word);
    len=word.length;
    final int c=ctx.ftopt.qu.count();
    o+=c > 0 ? oc / ctx.ftopt.qu.count() : len == 0 ? 1 : 0;
  }
 else {
    final Iter iter=ctx.iter(query);
    byte[] it;
switch (mode) {
case ALL:
      while ((it=nextStr(iter)) != null) {
        final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,it);
        if (oc == 0)         return 0;
        len+=it.length;
        o+=oc / ctx.ftopt.qu.count();
      }
    break;
case ALLWORDS:
  while ((it=nextStr(iter)) != null) {
    for (    final byte[] txt : split(it,' ')) {
      final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt);
      if (oc == 0)       return 0;
      len+=txt.length;
      o+=oc;
    }
  }
break;
case ANY:
while ((it=nextStr(iter)) != null) {
final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,it);
len+=it.length;
o+=oc / ctx.ftopt.qu.count();
}
break;
case ANYWORD:
while ((it=nextStr(iter)) != null) {
for (final byte[] txt : split(it,' ')) {
final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt);
len+=txt.length;
o+=oc;
}
}
break;
case PHRASE:
final TokenBuilder tb=new TokenBuilder();
while ((it=nextStr(iter)) != null) {
tb.add(it);
tb.add(' ');
}
final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,tb.finish());
len+=tb.size;
o+=oc / ctx.ftopt.qu.count();
break;
}
}
long mn=1;
long mx=Long.MAX_VALUE;
if (occ != null) {
mn=checkItr(occ[0],ctx);
mx=checkItr(occ[1],ctx);
}
return o < mn || o > mx ? 0 : Math.max(1,len);
}
