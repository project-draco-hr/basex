{
  int len=0;
  int o=0;
  if (mode == FTMode.ANY && word != null) {
    final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,word);
    len=word.length;
    o+=oc / ctx.ftopt.sb.count();
  }
 else {
    final Iter iter=ctx.iter(query);
    Item i;
switch (mode) {
case ALL:
      while ((i=iter.next()) != null) {
        final byte[] txt=i.str();
        final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt);
        if (oc == 0)         return 0;
        len+=txt.length;
        o+=oc / ctx.ftopt.sb.count();
      }
    break;
case ALLWORDS:
  while ((i=iter.next()) != null) {
    for (    final byte[] txt : split(i.str(),' ')) {
      final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt);
      if (oc == 0)       return 0;
      len+=txt.length;
      o+=oc;
    }
  }
break;
case ANY:
while ((i=iter.next()) != null) {
final byte[] txt=i.str();
final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt);
len+=txt.length;
o+=oc / ctx.ftopt.sb.count();
}
break;
case ANYWORD:
while ((i=iter.next()) != null) {
for (final byte[] txt : split(i.str(),' ')) {
final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt);
len+=txt.length;
o+=oc;
}
}
break;
case PHRASE:
final TokenBuilder tb=new TokenBuilder();
while ((i=iter.next()) != null) {
tb.add(i.str());
tb.add(' ');
}
final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,tb.finish());
len+=tb.size;
o+=oc / ctx.ftopt.sb.count();
break;
}
}
long mn=1;
long mx=Long.MAX_VALUE;
if (occ != null) {
mn=checkItr(ctx.iter(occ[0]));
mx=checkItr(ctx.iter(occ[1]));
}
return o < mn || o > mx ? 0 : Math.max(1,len);
}
