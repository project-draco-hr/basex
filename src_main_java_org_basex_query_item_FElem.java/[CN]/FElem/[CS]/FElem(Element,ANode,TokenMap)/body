{
  super(NodeType.ELM);
  final String nu=elem.getNamespaceURI();
  name=new QNm(token(elem.getNodeName()),nu == null ? EMPTY : token(nu));
  par=p;
  children=new NodeCache();
  atts=new NodeCache();
  ns=new Atts();
  final NamedNodeMap at=elem.getAttributes();
  final int as=at.getLength();
  for (int i=0; i < as; ++i) {
    final Attr att=(Attr)at.item(i);
    final byte[] nm=token(att.getName()), uri=token(att.getValue());
    if (Token.eq(nm,XMLNS)) {
      ns.add(EMPTY,uri);
    }
 else     if (startsWith(nm,XMLNSC)) {
      ns.add(ln(nm),uri);
    }
 else {
      add(new FAttr(att));
    }
  }
  for (int i=0; i < ns.size(); ++i)   nss.add(ns.key(i),ns.val(i));
  if (p == null) {
    nsScope(elem.getParentNode(),nss);
    for (    final byte[] key : nss.keys()) {
      if (!ns.contains(key))       ns.add(key,nss.get(key));
    }
  }
  final byte[] pref=name.pref();
  final byte[] uri=name.uri().string();
  final byte[] old=nss.get(pref);
  if (old == null || !Token.eq(uri,old)) {
    ns.add(pref,uri);
    nss.add(pref,uri);
  }
  final NodeList ch=elem.getChildNodes();
  for (int i=0; i < ch.getLength(); ++i) {
    final Node child=ch.item(i);
switch (child.getNodeType()) {
case Node.TEXT_NODE:
      add(new FTxt((Text)child));
    break;
case Node.COMMENT_NODE:
  add(new FComm((Comment)child));
break;
case Node.PROCESSING_INSTRUCTION_NODE:
add(new FPI((ProcessingInstruction)child));
break;
case Node.ELEMENT_NODE:
add(new FElem((Element)child,this,nss));
break;
default :
break;
}
}
}
