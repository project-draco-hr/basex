{
  super(Type.ELM);
  if (elem.getNamespaceURI() != null) {
    name=new QNm(token(elem.getNodeName()),Uri.uri(token(elem.getNamespaceURI())));
  }
 else {
    name=new QNm(token(elem.getNodeName()));
  }
  par=p;
  final String b=elem.getBaseURI();
  base=b == null ? EMPTY : token(b);
  ns=new Atts();
  final NamedNodeMap at=elem.getAttributes();
  final int as=at.getLength();
  final Nod[] attArr=new Nod[as];
  int pos=0;
  for (int i=0; i < as; i++) {
    final Attr att=(Attr)at.item(i);
    final byte[] nm=token(att.getName()), uri=token(att.getValue());
    if (Token.eq(nm,XMLNS)) {
      ns.add(EMPTY,uri);
    }
 else     if (startsWith(nm,XMLNSC)) {
      ns.add(ln(nm),uri);
    }
 else {
      attArr[pos++]=new FAttr(att,this);
    }
  }
  atts=new NodIter(attArr,pos);
  if (p == null) {
    final Atts nss=nsScope(elem.getParentNode());
    for (int i=0; i < nss.size; i++) {
      if (!ns.contains(nss.key[i])) {
        ns.add(nss.key[i],nss.val[i]);
      }
    }
  }
  final NodeList ch=elem.getChildNodes();
  final int s=ch.getLength();
  final Nod[] childArr=new Nod[s];
  children=new NodIter(childArr,childArr.length);
  for (int i=0; i < ch.getLength(); i++) {
    final Node child=ch.item(i);
switch (child.getNodeType()) {
case Node.TEXT_NODE:
      childArr[i]=new FTxt((Text)child,this);
    break;
case Node.COMMENT_NODE:
  childArr[i]=new FComm((Comment)child,this);
break;
case Node.PROCESSING_INSTRUCTION_NODE:
childArr[i]=new FPI((ProcessingInstruction)child,this);
break;
case Node.ELEMENT_NODE:
childArr[i]=new FElem((Element)child,this);
break;
default :
break;
}
}
}
