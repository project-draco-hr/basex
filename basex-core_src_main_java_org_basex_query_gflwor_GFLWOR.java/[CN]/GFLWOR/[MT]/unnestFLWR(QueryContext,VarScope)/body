{
  boolean change=false, thisRound;
  do {
    thisRound=false;
    final ListIterator<Clause> iter=clauses.listIterator();
    while (iter.hasNext()) {
      final Clause cl=iter.next();
      final boolean isFor=cl instanceof For, isLet=cl instanceof Let;
      if (isFor) {
        final For fr=(For)cl;
        if (!fr.empty && fr.pos == null && fr.expr instanceof GFLWOR) {
          final GFLWOR fl=(GFLWOR)fr.expr;
          if (fl.isFLWR()) {
            qc.compInfo(QueryText.OPTFLAT,this);
            iter.remove();
            for (            final Clause c : fl.clauses)             iter.add(c);
            fr.expr=fl.ret;
            iter.add(fr);
            thisRound=change=true;
          }
        }
      }
      if (!thisRound && (isFor || isLet)) {
        final Expr e=isFor ? ((For)cl).expr : ((Let)cl).expr;
        if (e instanceof GFLWOR) {
          final GFLWOR fl=(GFLWOR)e;
          final LinkedList<Clause> cls=fl.clauses;
          if (cls.getFirst() instanceof Let) {
            iter.remove();
            do             iter.add(cls.removeFirst());
 while (!cls.isEmpty() && cls.getFirst() instanceof Let);
            final Expr rest=fl.clauses.isEmpty() ? fl.ret : fl.optimize(qc,scp);
            if (isFor)             ((For)cl).expr=rest;
 else             ((Let)cl).expr=rest;
            iter.add(cl);
            thisRound=change=true;
          }
        }
      }
    }
  }
 while (thisRound);
  return change;
}
