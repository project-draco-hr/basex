{
  final IntList start=new IntList();
  final IntList end=new IntList();
  if (search.isEmpty())   return new IntList[]{start,end};
  final byte[] text=txt;
  if (regex) {
    int flags=Pattern.DOTALL;
    if (!mcase)     flags|=Pattern.CASE_INSENSITIVE;
    final Pattern pattern=Pattern.compile(search,flags);
    if (multi) {
      int c=0, p=0;
      final Matcher m=pattern.matcher(Token.string(text));
      while (m.find()) {
        final int s=m.start(), e=m.end();
        while (c < s) {
          p+=Token.cl(text,p);
          c++;
        }
        start.add(p);
        while (c < e) {
          p+=Token.cl(text,p);
          c++;
        }
        end.add(p);
      }
    }
 else {
      final int os=text.length;
      final TokenBuilder tb=new TokenBuilder(os);
      for (int t=0, o=0; o <= os; o++) {
        if (o < os ? text[o] == '\n' : o != t) {
          int c=0, p=t;
          final Matcher m=pattern.matcher(Token.string(text,t,o - t));
          while (m.find()) {
            final int s=m.start(), e=m.end();
            while (c < s) {
              p+=Token.cl(text,p);
              c++;
            }
            start.add(p);
            while (c < e) {
              p+=Token.cl(text,p);
              c++;
            }
            end.add(p);
          }
          if (o < os)           tb.add('\n');
          t=o + 1;
        }
      }
    }
  }
 else {
    final byte[] srch=Token.token(search);
    final int ss=srch.length, os=text.length;
    for (int o=0; o < os; ) {
      int sp=0;
      if (o + ss <= os) {
        if (mcase) {
          for (; sp < ss && text[o + sp] == srch[sp]; sp++)           ;
        }
 else {
          for (; sp < ss && Token.lc(Token.cp(text,o + sp)) == Token.cp(srch,sp); sp+=Token.cl(srch,sp))           ;
        }
      }
      if (sp == ss) {
        start.add(o);
        end.add(o + ss);
        o+=ss;
      }
 else {
        o++;
      }
    }
  }
  nr=start.size();
  return new IntList[]{start,end};
}
