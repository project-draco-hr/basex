{
  final FTOptions opt=ctx.ftopt;
  byte[] tk=ctx.ftitem;
  byte[] sb=opt.wc.bool() ? sub : FTCont.norm(new TokenBuilder(),sub).finish();
  if (opt.stem.bool()) {
    sb=STEM.stem(sb);
    tk=STEM.stem(tk);
  }
  if (!opt.diacr.bool()) {
    sb=dc(sb);
    tk=dc(tk);
  }
  if (opt.uc.bool()) {
    sb=uc(sb);
  }
 else   if (!opt.sens.bool() || opt.lc.bool()) {
    sb=lc(sb);
    if (!opt.lc.bool())     tk=lc(tk);
  }
  final int sl=sb.length;
  final int tl=tk.length;
  final TokenBuilder st=new TokenBuilder();
  final TokenBuilder tt=new TokenBuilder();
  IntList il=null;
  int p=-1;
  if (opt.wc.bool()) {
    final String cmp=string(sb);
    for (    final String s : string(tk).split("[\\p{Punct}\\s]")) {
      p++;
      if (s.matches(cmp)) {
        if (il == null)         il=new IntList();
        il.add(p);
      }
    }
  }
 else {
    if (tl < sl || sl == 0)     return 0;
    for (int i=0; i <= tl - sl; i++) {
      if (i > 0 && (tk[i] < 0 || tk[i] > ' '))       continue;
      while (i < tl - sl && !letterOrDigit(tk[i]))       i++;
      p++;
      int s=-1;
      int t=i - 1;
      if (opt.sw == null) {
        while (++t < tl & ++s < sl) {
          byte sv=sb[s];
          byte tv=tk[t];
          if (sv != tv && (sv < 0 || sv > ' ' || tv < 0 || tv > ' '))           break;
        }
      }
 else {
        while (s < sl) {
          st.reset();
          tt.reset();
          while (++s < sl && letterOrDigit(sb[s]))           st.add(sb[s]);
          while (++t < tl && letterOrDigit(tk[t]))           tt.add(tk[t]);
          final byte[] s1=st.finish();
          if (!opt.sw.contains(s1) && !eq(s1,tt.finish())) {
            s=0;
            break;
          }
        }
      }
      if (s == sl && (t == tl || !letterOrDigit(tk[t]))) {
        if (il == null)         il=new IntList();
        il.add(p);
      }
    }
  }
  if (il != null)   ctx.ftselect.add(sub,il);
  return il == null ? 0 : il.size;
}
