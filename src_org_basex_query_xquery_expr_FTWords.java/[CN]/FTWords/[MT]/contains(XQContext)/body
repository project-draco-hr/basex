{
  final Iter iter=ctx.iter(expr);
  final long mn=checkItr(ctx.iter(occ[0]));
  final long mx=checkItr(ctx.iter(occ[1]));
  int len=0;
  int o=0;
  Item i;
switch (mode) {
case ALL:
    while ((i=iter.next()) != null) {
      final byte[] txt=i.str();
      final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt);
      if (oc == 0)       return 0;
      len+=txt.length * oc;
      o+=oc / ctx.ftopt.sb.count();
    }
  break;
case ALLWORDS:
while ((i=iter.next()) != null) {
  for (  final byte[] txt : split(i.str(),' ')) {
    final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt);
    if (oc == 0)     return 0;
    len+=txt.length * oc;
    o+=oc;
  }
}
break;
case ANY:
while ((i=iter.next()) != null) {
final byte[] txt=i.str();
final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt);
len+=txt.length * oc;
o+=oc / ctx.ftopt.sb.count();
}
break;
case ANYWORD:
while ((i=iter.next()) != null) {
for (final byte[] txt : split(i.str(),' ')) {
final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt);
len+=txt.length * oc;
o+=oc;
}
}
break;
case PHRASE:
final TokenBuilder txt=new TokenBuilder();
while ((i=iter.next()) != null) {
if (txt.size != 0) txt.add(' ');
txt.add(i.str());
}
final int oc=ctx.ftopt.contains(ctx.ftitem,ctx.ftpos,txt.finish());
len+=txt.size * oc;
o+=oc / ctx.ftopt.sb.count();
break;
}
return o < mn || o > mx ? 0 : Math.max(1,len);
}
