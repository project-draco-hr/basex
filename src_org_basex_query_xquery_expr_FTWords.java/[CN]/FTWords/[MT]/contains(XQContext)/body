{
  final Iter iter=ctx.iter(expr);
  final long mn=checkItr(ctx.iter(occ[0]));
  final long mx=checkItr(ctx.iter(occ[1]));
  int len=0;
  int o=0;
  Item i;
switch (mode) {
case ALL:
    while ((i=iter.next()) != null) {
      final byte[] txt=norm(i.str());
      final int oc=cont(ctx,txt);
      if (oc == 0)       return 0;
      len+=txt.length * oc;
      o+=oc;
    }
  break;
case ALLWORDS:
while ((i=iter.next()) != null) {
  for (  final byte[] txt : split(norm(i.str()),' ')) {
    final int oc=cont(ctx,txt);
    if (oc == 0)     return 0;
    len+=txt.length * oc;
    o+=oc;
  }
}
break;
case ANY:
while ((i=iter.next()) != null) {
final byte[] txt=norm(i.str());
final int oc=cont(ctx,txt);
len+=txt.length * oc;
o+=oc;
}
break;
case ANYWORD:
while ((i=iter.next()) != null) {
for (final byte[] txt : split(norm(i.str()),' ')) {
final int oc=cont(ctx,txt);
len+=txt.length * oc;
o+=oc;
}
}
break;
case PHRASE:
final TokenBuilder tb=new TokenBuilder();
boolean more=false;
while ((i=iter.next()) != null) {
if (more) tb.add(' ');
tb.add(norm(i.str()));
more=true;
}
final int oc=cont(ctx,tb.finish());
len+=tb.size * oc;
o+=oc;
break;
}
return o < mn || o > mx ? 0 : len;
}
