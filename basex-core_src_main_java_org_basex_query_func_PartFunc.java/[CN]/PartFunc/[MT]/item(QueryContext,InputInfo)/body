{
  final Expr fn=expr[expr.length - 1];
  final FItem f=(FItem)checkType(fn.item(ctx,ii),FuncType.ANY_FUN);
  final FuncType ft=f.funcType();
  final int arity=expr.length + holes.length - 1;
  if (f.arity() != arity)   throw INVARITY.get(ii,f,arity);
  final Expr[] args=new Expr[arity];
  final VarScope scp=new VarScope(sc);
  final Var[] vars=new Var[holes.length];
  int p=-1;
  for (int i=0; i < holes.length; i++) {
    while (++p < holes[i])     args[p]=expr[p - i].value(ctx);
    vars[i]=scp.newLocal(ctx,f.argName(holes[i]),null,false);
    args[p]=new VarRef(info,vars[i]);
    vars[i].refineType(ft.args[p],ctx,ii);
  }
  while (++p < args.length)   args[p]=expr[p - holes.length].value(ctx);
  final Expr call=new DynFuncCall(info,f,args);
  final FuncType tp=FuncType.get(f.annotations(),vars,ft.ret);
  return new FuncItem(sc,f.annotations(),null,vars,tp,call,ctx.value,ctx.pos,ctx.size,scp.stackSize());
}
