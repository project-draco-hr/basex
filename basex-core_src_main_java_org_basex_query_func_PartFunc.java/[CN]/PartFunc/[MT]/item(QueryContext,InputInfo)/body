{
  final FItem f=toFunc(exprs[exprs.length - 1],qc);
  final int hl=holes.length;
  final int ar=exprs.length + hl - 1;
  if (f.arity() != ar)   throw INVARITY_X_X_X_X.get(info,f,ar,ar == 1 ? "" : "s",f.arity());
  final FuncType ft=f.funcType();
  final Expr[] args=new Expr[ar];
  final VarScope scp=new VarScope(sc);
  final Var[] vars=new Var[hl];
  int a=-1;
  for (int h=0; h < hl; h++) {
    while (++a < holes[h])     args[a]=exprs[a - h].value(qc);
    vars[h]=scp.newLocal(qc,f.argName(holes[h]),null,false);
    args[a]=new VarRef(info,vars[h]);
    vars[h].refineType(ft.argTypes[a],qc,ii);
  }
  final int al=args.length;
  while (++a < al)   args[a]=exprs[a - hl].value(qc);
  final AnnList anns=f.annotations();
  final FuncType tp=FuncType.get(anns,vars,ft.retType);
  final DynFuncCall fc=new DynFuncCall(info,sc,anns.contains(Annotation.UPDATING),f,args);
  return new FuncItem(sc,anns,null,vars,tp,fc,qc.value,qc.pos,qc.size,scp.stackSize());
}
