{
  final FItem f=toFunc(exprs[exprs.length - 1],qc);
  final int ar=exprs.length + holes.length - 1;
  if (f.arity() != ar)   throw INVARITY_X_X_X_X.get(info,f,ar,ar == 1 ? "" : "s",f.arity());
  final FuncType ft=f.funcType();
  final Expr[] args=new Expr[ar];
  final VarScope scp=new VarScope(sc);
  final Var[] vars=new Var[holes.length];
  int p=-1;
  for (int i=0; i < holes.length; i++) {
    while (++p < holes[i])     args[p]=exprs[p - i].value(qc);
    vars[i]=scp.newLocal(qc,f.argName(holes[i]),null,false);
    args[p]=new VarRef(info,vars[i]);
    vars[i].refineType(ft.argTypes[p],qc,ii);
  }
  while (++p < args.length)   args[p]=exprs[p - holes.length].value(qc);
  final Ann ann=f.annotations();
  final FuncType tp=FuncType.get(ann,vars,ft.retType);
  final DynFuncCall fc=new DynFuncCall(info,sc,ann.contains(Ann.Q_UPDATING),f,args);
  return new FuncItem(sc,ann,null,vars,tp,fc,qc.value,qc.pos,qc.size,scp.stackSize());
}
