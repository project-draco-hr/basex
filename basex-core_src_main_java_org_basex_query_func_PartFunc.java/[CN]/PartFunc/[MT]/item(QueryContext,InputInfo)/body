{
  final Expr fn=expr[expr.length - 1];
  final FItem f=(FItem)checkType(fn.item(ctx,ii),FuncType.ANY_FUN);
  final FuncType ft=f.funcType();
  final int arity=expr.length + holes.length - 1;
  if (f.arity() != arity)   throw INVARITY.get(ii,f,arity);
  final Expr[] args=new Expr[arity];
  final VarScope scp=new VarScope(sc);
  final Var[] vars=new Var[holes.length];
  int p=-1;
  for (int i=0; i < holes.length; i++) {
    while (++p < holes[i])     args[p]=expr[p - i].value(ctx);
    vars[i]=scp.newLocal(ctx,f.argName(holes[i]),ft.args[p],true);
    args[p]=new VarRef(info,vars[i]);
  }
  while (++p < args.length)   args[p]=expr[p - holes.length].value(ctx);
  final Expr call=new DynFuncCall(info,f,args).optimize(ctx,scp);
  final InlineFunc func=new InlineFunc(info,ft.ret,vars,call,f.annotations(),sc,scp);
  return func.optimize(ctx,null).item(ctx,ii);
}
