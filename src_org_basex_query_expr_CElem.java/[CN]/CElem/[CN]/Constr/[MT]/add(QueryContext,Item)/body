{
  if (it == null)   return false;
  if (it.node() && it.type != Type.TXT) {
    Nod node=(Nod)it;
    if (it.type == Type.ATT) {
      if (text.size() != 0 || children.size() != 0)       Err.or(NOATTALL);
      final QNm name=node.qname();
      final byte[] ln=name.ln();
      final byte[] pre=name.pre();
      if (eq(pre,XML) && eq(ln,BASE))       base=it.str();
      final QNm qname=node.qname();
      for (int a=0; a < ats.size(); a++) {
        if (qname.eq(ats.get(a).qname())) {
          final byte[] nm=qname.str();
          if (!contains(nm,':'))           Err.or(ATTDUPL,nm);
 else           Err.or(ATTNSDUPL,qname,ats.get(a).qname());
        }
      }
      ats.add(node.copy());
    }
 else     if (it.type == Type.DOC) {
      final NodeIter iter=node.child();
      Nod ch;
      while ((ch=iter.next()) != null)       add(ctx,ch);
    }
 else {
      if (text.size() != 0) {
        children.add(new FTxt(text.finish(),null));
        text.reset();
      }
      node=node.copy();
      children.add(node);
      final Atts atts=node.ns();
      if (atts != null && atts.size != 0) {
        node=node.parent();
        while (node != null && node.type == Type.ELM) {
          final Atts ns=node.ns();
          for (int a=0; a < ns.size; a++) {
            if (!atts.contains(ns.key[a]))             atts.add(ns.key[a],ns.val[a]);
          }
          node=node.parent();
        }
      }
    }
    more=false;
  }
 else {
    if (more && it.type != Type.TXT)     text.add(' ');
    text.add(it.str());
    more=it.type != Type.TXT;
  }
  return true;
}
