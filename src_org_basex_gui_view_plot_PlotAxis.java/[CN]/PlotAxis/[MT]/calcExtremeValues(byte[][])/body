{
  min=Integer.MAX_VALUE;
  max=Integer.MIN_VALUE;
  for (int i=0; i < vals.length; i++) {
    if (vals[i].length < 1)     continue;
    double d=toDouble(vals[i]);
    if (d < min)     min=d;
    if (d > max)     max=d;
  }
  if (max - min == 0)   return;
  final Data data=GUI.context.data();
  int fsplus=6;
  final boolean fss=data.fs != null && eq(data.atts.key(attrID),SIZE);
  final double range=max - min;
  final double lmin=min - range / 2;
  final double lmax=max + range / 2;
  final double rangePow=Math.floor(fss ? Math.log(Math.pow(Math.E,Math.exp(2))) : Math.log10(range) + .5d);
  final double lstep=(int)(Math.pow(fss ? 2 : 10,fss ? rangePow + fsplus : rangePow));
  calculatedCaptionStep=(int)(Math.pow(fss ? 2 : 10,rangePow - (fss ? -fsplus : 1)));
  double c=Math.floor(min);
  double m=c - c % calculatedCaptionStep;
  if (m > lmin)   min=m;
  m=c - c % lstep;
  if (m > lmin)   min=m;
  c=Math.ceil(max);
  boolean f=false;
  while (c < lmax) {
    if (c % lstep == 0) {
      max=c;
      break;
    }
    if (!f && c % calculatedCaptionStep == 0 && ((c - min) / calculatedCaptionStep) % 2 == 0) {
      max=c;
      f=true;
    }
    c-=c % calculatedCaptionStep;
    c+=calculatedCaptionStep;
  }
}
