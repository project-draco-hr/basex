{
  cond=checkUp(cond,ctx).comp(ctx);
  for (  final SwitchCase sc : cases)   sc.comp(ctx);
  final Expr[] tmp=new Expr[cases.length];
  for (int i=0; i < tmp.length; ++i)   tmp[i]=cases[i].expr[0];
  checkUp(ctx,tmp);
  Expr ex=this;
  if (cond.isValue()) {
    final Item it=cond.item(ctx,input);
    LOOP:     for (    final SwitchCase sc : cases) {
      final int sl=sc.expr.length;
      for (int e=1; e < sl; e++) {
        if (!sc.expr[e].isValue())         break LOOP;
        final Item cs=sc.expr[e].item(ctx,input);
        if (it == cs || cs != null && it != null && it.equiv(input,cs)) {
          ex=sc.expr[0];
          break LOOP;
        }
      }
      if (sl == 1)       ex=sc.expr[0];
    }
  }
  if (ex != this)   return optPre(ex,ctx);
  type=cases[0].expr[0].type();
  for (int c=1; c < cases.length; c++) {
    type=type.intersect(cases[c].expr[0].type());
  }
  return ex;
}
