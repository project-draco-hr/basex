{
  final FElem suite=new FElem(TESTSUITE).add(NAME,file.url());
  final ArrayList<StaticFunc> before=new ArrayList<>(0);
  final ArrayList<StaticFunc> after=new ArrayList<>(0);
  final ArrayList<StaticFunc> beforeModule=new ArrayList<>(0);
  final ArrayList<StaticFunc> afterModule=new ArrayList<>(0);
  final ArrayList<StaticFunc> test=new ArrayList<>(0);
  final Performance perf=new Performance();
  final QueryContext qc=new QueryContext(ctx);
  try {
    input=string(file.read());
    qc.parse(input,file.path(),null);
    for (    final StaticFunc sf : qc.funcs.funcs()) {
      final Ann ann=sf.ann;
      final int as=ann.size();
      boolean xq=false;
      for (int a=0; !xq && a < as; a++) {
        xq|=eq(ann.names[a].uri(),QueryText.UNITURI);
      }
      if (!xq)       continue;
      if (sf.ann.contains(Ann.Q_PRIVATE))       throw UNIT_PRIVATE.get(null,sf.name.local());
      if (sf.args.length > 0)       throw UNIT_ARGS.get(null,sf.name.local());
      if (indexOf(sf,BEFORE) != -1)       before.add(sf);
      if (indexOf(sf,AFTER) != -1)       after.add(sf);
      if (indexOf(sf,BEFORE_MODULE) != -1)       beforeModule.add(sf);
      if (indexOf(sf,AFTER_MODULE) != -1)       afterModule.add(sf);
      if (indexOf(sf,TEST) != -1)       test.add(sf);
    }
    for (    final StaticFunc sf : beforeModule)     eval(sf);
    for (    final StaticFunc sf : test) {
      final Value values=sf.ann.values[indexOf(sf,TEST)];
      final long vs=values.size();
      byte[] code=null;
      if (vs != 0) {
        if (vs == 2 && eq(EXPECTED,values.itemAt(0).string(null))) {
          code=values.itemAt(1).string(null);
        }
 else {
          throw UNIT_ANN.get(null,'%',sf.ann.names[0]);
        }
      }
      final FElem testcase=new FElem(TESTCASE).add(NAME,sf.name.local());
      tests++;
      final Performance perf2=new Performance();
      final int skip=indexOf(sf,IGNORE);
      if (skip == -1) {
        try {
          for (          final StaticFunc fn : before)           eval(fn);
          eval(sf);
          for (          final StaticFunc fn : after)           eval(fn);
          if (code != null) {
            failures++;
            testcase.add(new FElem(FAILURE).add(new FElem(EXPECTED).add(code)));
          }
        }
 catch (        final QueryException ex) {
          final QNm name=ex.qname();
          if (code == null || !eq(code,name.local())) {
            final FElem error;
            final boolean fail=Err.UNIT_ASSERT.eq(name);
            if (fail) {
              failures++;
              error=new FElem(FAILURE);
            }
 else {
              errors++;
              error=new FElem(ERROR);
            }
            addError(ex,error,fail);
            testcase.add(error);
          }
        }
      }
 else {
        final Value sv=sf.ann.values[skip];
        testcase.add(SKIPPED,sv.isEmpty() ? EMPTY : sv.itemAt(0).string(null));
        skipped++;
      }
      testcase.add(TIME,time(perf2));
      suite.add(testcase);
    }
    for (    final StaticFunc sf : afterModule)     eval(sf);
  }
 catch (  final QueryException ex) {
    final FElem error;
    if (current == null) {
      error=new FElem(ERROR);
      try {
        addError(ex,error,true);
      }
 catch (      final QueryException ignored) {
      }
    }
 else {
      error=new FElem(TESTCASE).add(NAME,current.name.local());
      error.add(TIME,time(perf));
    }
    suite.add(error);
    errors++;
  }
 finally {
    qc.close();
  }
  if (suite.hasChildren()) {
    suite.add(TIME,time(perf));
    suite.add(TESTS,token(tests));
    suite.add(FAILURES,token(failures));
    suite.add(ERRORS,token(errors));
    suite.add(SKIPPED,token(skipped));
    suites.add(suite);
  }
}
