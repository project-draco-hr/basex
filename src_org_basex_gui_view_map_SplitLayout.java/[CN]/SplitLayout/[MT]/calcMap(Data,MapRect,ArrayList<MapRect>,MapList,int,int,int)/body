{
  if (ne - ns == 1) {
    putRect(data,r,mainRects,l,ns,level);
  }
 else {
    final boolean v=r.w > r.h;
    if (level == 0) {
      splitUniformly(data,r,mainRects,l,ns,ne,level,v);
    }
 else {
      double weight=0;
      int ni=ns;
      long parsize=data.fs != null ? addSizes(l,ni,ne,data) : 0;
      int parchilds=l.list[ne] - l.list[ni];
      if (parsize == 0)       parsize=l.list[ne] - l.list[ns];
      weight=0;
      for (; ni < ne - 1; ni++) {
        long size=data.fs != null ? Token.toLong(data.attValue(data.sizeID,l.list[ni])) : 0;
        int childs=l.list[ni + 1] - l.list[ni];
        if (weight >= 0.5)         break;
        weight+=calcWeight(size,childs,parsize,parchilds,data);
      }
      int xx=r.x;
      int yy=r.y;
      int ww=!v ? r.w : (int)(r.w * weight);
      int hh=v ? r.h : (int)(r.h * weight);
      if (ww > 0 && hh > 0)       calcMap(data,new MapRect(xx,yy,ww,hh,0,r.level),mainRects,l,ns,ni,level);
      if (v) {
        xx+=ww;
        ww=r.w - ww;
      }
 else {
        yy+=hh;
        hh=r.h - hh;
      }
      if (ww > 0 && hh > 0)       calcMap(data,new MapRect(xx,yy,ww,hh,0,r.level),mainRects,l,ni,ne,level);
    }
  }
}
