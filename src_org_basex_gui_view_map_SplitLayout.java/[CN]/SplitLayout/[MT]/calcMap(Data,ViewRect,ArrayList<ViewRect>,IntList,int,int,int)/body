{
  if (ne - ns == 1) {
    putRect(data,r,mainRects,l,ns,level);
  }
 else {
    long nn, ln;
    int ni;
    nn=ne - ns;
    ln=nn >> 1;
    ni=(int)(ns + ln);
    if (!GUIProp.mapsimple && level != 0) {
      nn=l.list[ne] - l.list[ns];
      ni=ns;
      if (data.fs != null && GUIProp.mapaggr) {
        int par=data.parent(l.list[ns],Data.ELEM);
        long parsize=Token.toLong(data.attValue(data.sizeID,par));
        long sum=0;
        for (; ni < ne - 1; ni++) {
          if (sum >= parsize / 2)           break;
          sum+=Token.toLong(data.attValue(data.sizeID,l.list[ni]));
        }
        nn=parsize;
        ln=sum;
      }
 else {
        for (; ni < ne - 1; ni++) {
          if (l.list[ni] - l.list[ns] >= (nn >> 1))           break;
        }
        ln=l.list[ni] - l.list[ns];
      }
    }
    final int p=GUIProp.mapprop;
    final boolean v=p > 4 ? r.w > r.h * (p + 4) / 8 : r.w * (13 - p) / 8 > r.h;
    int xx=r.x;
    int yy=r.y;
    int ww=!v ? r.w : (int)(r.w * ln / nn);
    int hh=v ? r.h : (int)(r.h * ln / nn);
    if (ww > 0 && hh > 0)     calcMap(data,new ViewRect(xx,yy,ww,hh,0,r.level),mainRects,l,ns,ni,level);
    if (v) {
      xx+=ww;
      ww=r.w - ww;
    }
 else {
      yy+=hh;
      hh=r.h - hh;
    }
    if (ww > 0 && hh > 0)     calcMap(data,new ViewRect(xx,yy,ww,hh,0,r.level),mainRects,l,ni,ne,level);
  }
}
