{
  try {
    try {
      ctx.register(parse());
      qp.compile();
      qi.cmpl=perf.time();
      final Iter ir=qp.iter();
      qi.evlt=perf.time();
      options();
      final boolean wrap=!options.get(S_WRAP_PREFIX).isEmpty();
      final PrintOutput po=PrintOutput.get(enc ? new EncodingOutput(out) : out);
      if (iter && wrap)       po.write(1);
      final Serializer ser=Serializer.get(po,full ? null : options);
      int c=0;
      for (Item it; (it=ir.next()) != null; ) {
        if (iter && !wrap) {
          if (full) {
            po.write(it.xdmInfo());
          }
 else {
            po.write(it.typeId().asByte());
          }
          ser.reset();
        }
        ser.serialize(it);
        if (iter && !wrap) {
          po.flush();
          out.write(0);
        }
        c++;
      }
      ser.close();
      if (iter && wrap)       out.write(0);
      qi.srlz=perf.time();
      info=qi.toString(qp,po,c,ctx.prop.is(Prop.QUERYINFO));
    }
 catch (    final QueryException ex) {
      throw new BaseXException(ex);
    }
catch (    final StackOverflowError ex) {
      Util.debug(ex);
      throw new BaseXException(BASX_STACKOVERFLOW.desc);
    }
catch (    final ProcException ex) {
      throw new BaseXException(TIMEOUT_EXCEEDED);
    }
  }
  finally {
    if (qp != null) {
      qp.close();
      if (parsed) {
        ctx.unregister(qp);
        parsed=false;
      }
      qp=null;
    }
  }
}
