{
  final Constr c=new Constr(ctx,expr[1]);
  final NodIter seq=c.children;
  final NodIter aSeq=c.ats;
  if (c.errAtt)   Err.or(UPNOATTRPER);
  if (c.duplAtt != null)   Err.or(UPATTDUPL,c.duplAtt);
  final Iter t=expr[0].iter(ctx);
  Item i=t.next();
  if (i == null)   Err.or(UPSEQEMP,i);
  final Type type=i.type;
  if (!(i instanceof Nod) || type == Type.DOC || t.next() != null)   Err.or(UPTRGMULT,i);
  final Nod n=(Nod)i;
  if (!value) {
    if (n.parent() == null)     Err.or(UPNOPAR,i);
    if (type != Type.ATT) {
      if (aSeq.size() > 0)       Err.or(UPWRELM,i);
      ctx.updates.add(new ReplacePrimitive(n,seq,false),ctx);
    }
 else {
      if (seq.size() > 0)       Err.or(UPWRATTR,i);
      ctx.updates.add(new ReplacePrimitive(n,aSeq,true),ctx);
    }
  }
 else {
    final byte[] txt=seq.size() < 1 ? EMPTY : seq.get(0).str();
    if (type == Type.COM)     CComm.check(txt);
    if (type == Type.PI)     CPI.check(txt);
    ctx.updates.add(type == Type.ELM ? new ReplaceElemContent(n,txt) : new ReplaceValue(n,new QNm(txt)),ctx);
  }
  return Seq.EMPTY;
}
