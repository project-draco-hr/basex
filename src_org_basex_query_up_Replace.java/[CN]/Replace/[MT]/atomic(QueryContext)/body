{
  final Constr c=new Constr(ctx,expr[1]);
  final NodIter seq=c.children;
  final NodIter aSeq=c.ats;
  if (c.errAtt)   Err.or(UPNOATTRPER);
  if (c.duplAtt != null)   Err.or(UPATTDUPL,c.duplAtt);
  final Iter t=SeqIter.get(expr[0].iter(ctx));
  Item i=t.next();
  if (i == null)   Err.or(UPSEQEMP,i);
  final int k=Nod.kind(i.type);
  if (t.size() > 1 || !(i instanceof Nod) || k == Data.DOC)   Err.or(UPTRGMULT,i);
  final Nod n=(Nod)i;
  final Nod p=n.parent();
  if (p == null)   Err.or(UPNOPAR,i);
  if (!value) {
    if (k != Data.ATTR) {
      if (aSeq.size() > 0)       Err.or(UPWRELM,i);
      ctx.updates.add(new ReplacePrimitive(n,seq,false),ctx);
    }
 else {
      if (seq.size() > 0)       Err.or(UPWRATTR,i);
      if (!UpdateFunctions.checkAttNames(p.attr(),aSeq,string(n.nname())))       Err.or(UPATTDUPL,n.nname());
      ctx.updates.add(new ReplacePrimitive(n,aSeq,true),ctx);
    }
  }
 else {
    final byte[] txt=seq.size() < 1 ? EMPTY : seq.get(0).str();
    if (k == Data.COMM)     CComm.check(txt);
    if (k == Data.PI)     CPI.check(txt);
    ctx.updates.add(k == Data.ELEM ? new ReplaceElemContent(n,txt) : new ReplaceValue(n,new QNm(txt)),ctx);
  }
  return Seq.EMPTY;
}
