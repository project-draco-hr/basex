{
  final Constr c=new Constr(ctx,expr[1]);
  if (c.errAtt)   Err.or(UPNOATTRPER);
  if (c.duplAtt != null)   Err.or(UPATTDUPL,c.duplAtt);
  final Iter t=expr[0].iter(ctx);
  Item i=t.next();
  if (i == null)   Err.or(UPSEQEMP,Main.name(this));
  final Type type=i.type;
  if (!(i instanceof Nod) || type == Type.DOC || t.next() != null)   Err.or(UPTRGMULT,i);
  final Nod targ=(Nod)i;
  final NodIter aList=c.ats;
  NodIter list=c.children;
  if (value) {
    final byte[] txt=list.size() < 1 ? EMPTY : list.get(0).str();
    if (type == Type.COM)     CComm.check(txt);
    if (type == Type.PI)     CPI.check(txt);
    ctx.updates.add(type == Type.ELM ? new ReplaceElemContent(targ,txt) : new ReplaceValue(targ,new QNm(txt)),ctx);
  }
 else {
    final Nod par=targ.parent();
    if (par == null)     Err.or(UPNOPAR,i);
    if (type == Type.ATT) {
      if (list.size() > 0)       Err.or(UPWRATTR,i);
      for (int a=0; a < aList.size(); a++) {
        final QNm name=aList.get(a).qname();
        final byte[] uri=par.uri(name.pref(),ctx);
        if (uri != null && !eq(name.uri.str(),uri))         Err.or(UPNSCONFL);
      }
      list=aList;
    }
 else {
      if (aList.size() > 0)       Err.or(UPWRELM,i);
    }
    ctx.updates.add(new ReplacePrimitive(targ,list),ctx);
  }
  return Seq.EMPTY;
}
