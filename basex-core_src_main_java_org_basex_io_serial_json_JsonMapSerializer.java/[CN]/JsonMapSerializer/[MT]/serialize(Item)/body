{
  if (sep && level == 0)   print(' ');
  try {
    if (item instanceof Map) {
      final Map map=(Map)item;
      level++;
      final Value keys=map.keys();
      long num=0;
      boolean object=false;
      for (      final Item k : keys) {
        if (k.type == AtomType.ITR) {
          final long n=k.itr(null);
          if (n <= 0)           throw BXJS_SERIAL.getIO("Integer key " + k + " ist not positive");
          num=Math.max(num,n);
        }
 else {
          object=true;
          if (k.type != AtomType.STR)           num=-1;
        }
        if (object && num != 0)         throw BXJS_SERIAL.getIO("Keys must either be strings or integers");
      }
      object=num == 0;
      print(object ? '{' : '[');
      if (object)       num=keys.size();
      boolean f=false;
      for (int i=0; i < num; i++) {
        final Item k=object ? keys.itemAt(i) : Int.get(i + 1);
        if (f)         print(',');
        indent();
        if (object) {
          serialize(k);
          print(':');
          if (indent)           print(' ');
        }
        final Value v=map.get(k,null);
        if (v.size() > 1)         throw BXJS_SERIAL.getIO("More than one item specified for key " + k);
        serialize(v.isEmpty() ? null : (Item)v);
        f=true;
      }
      level--;
      indent();
      print(object ? '}' : ']');
    }
 else     if (level == 0 && spec == JsonSpec.RFC4627) {
      throw BXJS_SERIAL.getIO("Top level must be a map; " + item.type + " found");
    }
 else     if (item == null) {
      print(NULL);
    }
 else {
      final byte[] str=item.string(null);
      final boolean quote=item.type != AtomType.BLN && (!item.type.isNumber() || eq(str,NAN,INF,NINF));
      if (quote)       print('"');
      final byte[] atom=item.string(null);
      for (int a=0; a < atom.length; a+=cl(atom,a))       encode(cp(atom,a));
      if (quote)       print('"');
    }
  }
 catch (  final QueryException ex) {
    throw new QueryIOException(ex);
  }
  sep=true;
}
