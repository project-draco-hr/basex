{
  if (ne - ns == 1) {
    final MapRect t=new MapRect(r.x,r.y,r.w,r.h,l.list[ns],r.l);
    mainRects.add(t);
    final int x=t.x + layout.x;
    final int y=t.y + layout.y;
    final int w=t.w - layout.w;
    final int h=t.h - layout.h;
    final int o=GUIProp.fontsize + 4;
    if ((w >= o || h >= o) && w > 0 && h > 0 && !ViewData.isLeaf(GUI.context.data(),t.p)) {
      final IntList ch=children(t.p);
      if (ch.size != 0)       calcMap(new MapRect(x,y,w,h,l.list[ns],r.l + 1),ch,0,ch.size - 1,level + 1);
    }
  }
 else {
    int nn, ln, ni;
    nn=ne - ns;
    ln=nn >> 1;
    ni=ns + ln;
    if (!GUIProp.mapsimple && level != 0) {
      nn=l.list[ne] - l.list[ns];
      ni=ns + 1;
      final Data data=GUI.context.data();
      if (data.fs != null && GUIProp.mapaggr) {
        int par=data.parent(l.list[ns],Data.ELEM);
        long parsize=Token.toLong(data.attValue(data.sizeID,par));
        long sum=0;
        for (; ni < ne - 1; ni++) {
          if (sum >= parsize / 2)           break;
          sum+=Token.toLong(data.attValue(data.sizeID,par));
        }
      }
 else {
        for (; ni < ne - 1; ni++) {
          if (l.list[ni] - l.list[ns] >= (nn >> 1))           break;
        }
      }
      ln=l.list[ni] - l.list[ns];
    }
    final int p=GUIProp.mapprop;
    final boolean v=p > 4 ? r.w > r.h * (p + 4) / 8 : r.w * (13 - p) / 8 > r.h;
    int xx=r.x;
    int yy=r.y;
    int ww=!v ? r.w : (int)((long)r.w * ln / nn);
    int hh=v ? r.h : (int)((long)r.h * ln / nn);
    if (ww > 0 && hh > 0)     calcMap(new MapRect(xx,yy,ww,hh,0,r.l),l,ns,ni,level);
    if (v) {
      xx+=ww;
      ww=r.w - ww;
    }
 else {
      yy+=hh;
      hh=r.h - hh;
    }
    if (ww > 0 && hh > 0)     calcMap(new MapRect(xx,yy,ww,hh,0,r.l),l,ni,ne,level);
  }
}
