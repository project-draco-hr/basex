{
  final Data data=GUI.context.data();
  if (ne - ns == 1) {
    final MapRect t=new MapRect(r.x,r.y,r.w,r.h,l.list[ns],r.l);
    final int x=t.x + layout.x;
    final int y=t.y + layout.y;
    final int w=t.w - layout.w;
    final int h=t.h - layout.h;
    mainRects.add(t);
    if (w > 0 && h > 0 && !ViewData.isLeaf(GUI.context.data(),t.p)) {
      final IntList ch=children(t.p);
      if (ch.size >= 0)       calcSliceMap(new MapRect(x,y,w,h,l.list[ns],t.l + 1),ch,0,ch.size - 1,level + 1);
    }
  }
 else {
    int nn=l.size - 1;
    int par=data.parent(l.list[ns],Data.ELEM);
    long parsize=Token.toLong(data.attValue(par + FSParser.SIZEOFFSET));
    int lines=1;
    int perline=(int)Math.ceil((float)nn / lines);
    final boolean v=(level % 2) == 0 ? true : false;
    float xx=r.x;
    float yy=r.y;
    float hh=0;
    float ww=0;
    for (int i=0; i < l.size - 1; i++) {
      if (v) {
        yy+=hh;
        float hoehe=(float)Token.toLong(data.attValue(l.list[i] + FSParser.SIZEOFFSET)) * r.h / parsize;
        hh=hoehe;
        ww=r.w / lines;
      }
 else {
        xx+=ww;
        float breite=(float)Token.toLong(data.attValue(l.list[i] + FSParser.SIZEOFFSET)) * r.w / parsize;
        ww=breite;
        hh=r.h / lines;
      }
      int[] liste=new int[1];
      liste[0]=l.list[i];
      calcSliceMap(new MapRect((int)xx,(int)yy,(int)ww,(int)hh,0,r.l),new IntList(liste),0,1,level);
    }
  }
}
