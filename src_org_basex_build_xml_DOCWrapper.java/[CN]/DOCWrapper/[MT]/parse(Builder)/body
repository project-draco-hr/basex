{
  builder.startDoc(token(filename));
  final Stack<NodeIterator> stack=new Stack<NodeIterator>();
  stack.push(new NodeIterator(doc));
  while (!stack.empty()) {
    final NodeIterator ni=stack.peek();
    if (ni.more()) {
      final Node n=ni.curr();
      if (n instanceof Element) {
        stack.push(new NodeIterator(n));
        final NamedNodeMap at=n.getAttributes();
        final int as=at.getLength();
        byte[][] atts=null;
        if (as != 0) {
          atts=new byte[as << 1][];
          for (int a=0; a < as; a++) {
            atts[a << 1]=Token.token(at.item(a).getNodeName());
            atts[(a << 1) + 1]=Token.token(at.item(a).getNodeValue());
          }
        }
        builder.startElem(Token.token(n.getNodeName()),atts);
      }
 else       if (n instanceof Text) {
        builder.text(new TokenBuilder(n.getNodeValue()),false);
      }
 else       if (n instanceof Comment) {
        builder.comment(new TokenBuilder(n.getNodeValue()));
      }
 else       if (n instanceof ProcessingInstruction) {
        builder.pi(new TokenBuilder(n.getNodeName() + ' ' + n.getNodeValue()));
        builder.text(new TokenBuilder(n.getNodeValue()),false);
      }
      nodes++;
    }
 else {
      stack.pop();
      if (stack.empty())       break;
      builder.endElem(Token.token(stack.peek().curr().getNodeName()));
    }
  }
  builder.endDoc();
}
