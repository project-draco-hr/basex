{
  int z='0';
  if (map != null) {
    for (int m=1; m <= map.size(); m++) {
      final String key=string(map.key(m));
      final byte[] val=map.value(m);
      if (key.equals(DF_INF)) {
        inf=val;
      }
 else       if (key.equals(DF_NAN)) {
        nan=val;
      }
 else       if (val.length != 0 && cl(val,0) == val.length) {
        final int cp=cp(val,0);
        if (key.equals(DF_DEC))         decimal=cp;
 else         if (key.equals(DF_GRP))         grouping=cp;
 else         if (key.equals(DF_PAT))         pattern=cp;
 else         if (key.equals(DF_MIN))         minus=cp;
 else         if (key.equals(DF_DIG))         optional=cp;
 else         if (key.equals(DF_PC))         percent=cp;
 else         if (key.equals(DF_PM))         permille=cp;
 else         if (key.equals(DF_ZG)) {
          z=zeroes(cp);
          if (z == -1)           INVDECFORM.thrw(ii,key,val);
          if (z != cp)           INVDECZERO.thrw(ii,(char)cp);
        }
      }
 else {
        INVDECSINGLE.thrw(ii,key,val);
      }
    }
  }
  zero=z;
  final IntSet is=new IntSet();
  final int[] ss={decimal,grouping,percent,permille,zero,optional,pattern};
  for (  final int s : ss)   if (is.add(s) < 0)   DUPLDECFORM.thrw(ii,(char)s);
  final TokenBuilder tb=new TokenBuilder();
  for (int i=0; i < 10; i++)   tb.add(zero + i);
  digits=tb.finish();
  active=tb.add(decimal).add(grouping).add(optional).finish();
}
