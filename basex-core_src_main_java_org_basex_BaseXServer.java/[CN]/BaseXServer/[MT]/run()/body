{
  final GlobalOptions gopts=context.globalopts;
  final int port=gopts.get(GlobalOptions.SERVERPORT);
  context.log.writeServer(OK,Util.info(SRV_STARTED_PORT_X,port));
  if (!quiet)   Util.outln(S_CONSOLE + Util.info(SRV_STARTED_PORT_X,port),S_SERVER);
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      context.log.writeServer(OK,Util.info(SRV_STOPPED_PORT_X,port));
      if (!quiet)       Util.outln(SRV_STOPPED_PORT_X,port);
    }
  }
);
  running=true;
  while (running) {
    try {
      final Socket s=socket.accept();
      if (stopFile.exists()) {
        if (!stopFile.delete()) {
          context.log.writeServer(ERROR + COL + Util.info(FILE_NOT_DELETED_X,stopFile));
        }
        quit();
      }
 else {
        final long ka=gopts.get(GlobalOptions.KEEPALIVE) * 1000L;
        if (ka > 0) {
          final long ms=System.currentTimeMillis();
          for (          final ClientListener cs : context.sessions) {
            if (ms - cs.last > ka)             cs.quit();
          }
        }
        final ClientListener cl=new ClientListener(s,context,this);
        final long to=gopts.get(GlobalOptions.KEEPALIVE) * 1000L;
        if (to > 0) {
          cl.auth.schedule(new TimerTask(){
            @Override public void run(){
              cl.quitAuth();
            }
          }
,to);
          auth.add(cl);
        }
        cl.start();
      }
    }
 catch (    final SocketException ex) {
      break;
    }
catch (    final Throwable ex) {
      Util.errln(ex);
      context.log.writeError(ex);
      break;
    }
  }
}
