{
  final int es=exprs.length;
  final ExprList el=new ExprList(es);
  for (int i=0; i < es; i++) {
    Expr e=exprs[i];
    if (e instanceof CmpG) {
      while (i + 1 < es && exprs[i + 1] instanceof CmpG) {
        final Expr tmp=((CmpG)e).union((CmpG)exprs[i + 1],qc,scp);
        if (tmp != null) {
          e=tmp;
          i++;
        }
 else {
          break;
        }
      }
    }
 else     if (e.isValue()) {
      e=optPre(value(qc),qc);
    }
    if (e == Bln.TRUE)     return optPre(Bln.TRUE,qc);
    if (e != Bln.FALSE)     el.add(e);
  }
  if (el.isEmpty())   return optPre(Bln.FALSE,qc);
  if (exprs.length != el.size()) {
    qc.compInfo(OPTWRITE,this);
    exprs=el.finish();
  }
  compFlatten(qc);
  boolean not=true;
  for (  final Expr e : exprs) {
    if (!e.isFunction(Function.NOT)) {
      not=false;
      break;
    }
  }
  if (not) {
    qc.compInfo(OPTWRITE,this);
    final Expr[] inner=new Expr[exprs.length];
    for (int i=0; i < inner.length; i++)     inner[i]=((Arr)exprs[i]).exprs[0];
    final Expr and=new And(info,inner).optimize(qc,scp);
    return Function.NOT.get(null,info,and).optimize(qc,scp);
  }
  return exprs.length == 1 ? compBln(exprs[0],info) : this;
}
